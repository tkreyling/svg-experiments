{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["MARGIN_TOP","MARGIN_SIDE","ELEMENT_WIDTH","ELEMENT_HEIGHT","SYMBOL_WIDTH","SYMBOL_SPACING","GROUP_MARGIN_TOP","GROUP_MARGIN_BOTTOM","GROUP_MARGIN_SIDE","HORIZONTAL_SPACING","VERTICAL_SPACING","TEXT_PADDING","EDGE_SPACING","STROKE_WIDTH","width","element","kind","Math","max","elements","map","index","reduce","sum","add","size","heightOfNodes","stack","n","length","fromIsUpper","edge","from","layerIndex","to","getUpperNode","getLowerNode","heightOfEdges","edges","numberOfLayers","groupedByLayerIndex","Map","forEach","grouped","get","push","set","Array","keys","edgeIndices","addLayerPositionToNodeG","graph","addLayerPositionToNode","numberOfElements","fullWidth","layerOffset","accumulator","Object","assign","groups","layerWidth","resultElements","group","resultGroup","node","resultElement","key","relativePosition","addCoordinatesToNodeG","heightOfAllEdges","addCoordinatesToNode","x","additionalEdgeHeight","layer","slice","y","addLayerPositionToEdgeG","addLayerPositionToEdge","values","addLayerPositionToEdgeForLayer","groupedByUpperNode","nodeKeys","sort","indexOffset","nodeKey","sameLayer","filter","sameLayerBefore","sameLayerAfter","otherLayer","otherLayerBefore","otherLayerAfter","edge1","edge2","before","concat","after","addLayerPosition","indexInArray","beforeOrAfter","addConnectionIndexAndNumberOfEdgesG","addConnectionIndexAndNumberOfEdges","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","edgeEnds","reverseNode","fromIndex","toIndex","edgeEnd","edgeEnd1","edgeEnd2","upperSideEdges","lowerSideEdges","addPositionToGroupG","addPositionToGroup","groupIndex","ComponentSymbol","symbol","barWidthAbsolute","barHeightAbsolute","symbolKey","height","fill","strokeWidth","stroke","Rect","isComponent","rectWidth","data-testid","clipPath","name","id","Group","contentWidth","Path","fromNodeOnLowerSide","fromNodeCenteringOffset","fromNodeX","fromNodeY","upperNodeEdgesY","toNodeOnLowerSide","toNodeCenteringOffset","toNodeX","toNodeY","d","convertStringsToNodes","stringsToNodes","strings","graphAsString","initialGraph","eval","allNodes","flatMap","Diagram","overallWidth","viewBox","parseGraph","text","undefined","layers","aNodeIsUndefined","elementIndex","every","e","message","App","useState","setGraph","errorMessage","setErrorMessage","className","cols","rows","onChange","changeEvent","result","target","value","defaultValue","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9739f23c.chunk.js","sourcesContent":["import React, {useState} from 'react';\nimport './App.css';\n\nexport type Coordinates = {\n    x: number\n    y: number\n}\n\nexport type LayerPosition = {\n    key: string\n    index: number\n    relativePosition: number\n    layerIndex: number\n}\n\nexport type GroupPosition = {\n    key: string\n    index: number\n    layerIndex: number\n}\n\ntype Symbols = \"component\"\n\nexport type Node = {\n    kind: 'node'\n    name: string\n    symbol?: Symbols\n    size?: number\n}\n\nexport type Edge<T> = {\n    from: T\n    to: T\n}\n\ntype ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\n\ntype NumberOfEdges = {\n    upperSideEdges: number\n    lowerSideEdges: number\n}\n\nexport type Group<N> = {\n    kind: 'group'\n    name: string\n    elements: (Group<N> | N)[]\n}\n\nexport type Layer<N, G> = {\n    kind: 'layer'\n    elements: (Group<N> & G)[]\n}\n\nexport type Stack<N, G> = {\n    kind: 'stack'\n    elements: Layer<N, G>[]\n}\n\nexport type Graph<N, E, G> = {\n    stack: Stack<N, G>\n    edges: (Edge<N> & E)[]\n}\n\nexport const MARGIN_TOP = 5;\nexport const MARGIN_SIDE = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const SYMBOL_WIDTH = 12;\nexport const SYMBOL_SPACING = 3;\nexport const GROUP_MARGIN_TOP = 30;\nexport const GROUP_MARGIN_BOTTOM = 10;\nexport const GROUP_MARGIN_SIDE = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const TEXT_PADDING = 5;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;\n\nexport function width(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return Math.max(...element.elements.map(width));\n        case \"layer\":\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"group\": {\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0) + 2 * GROUP_MARGIN_SIDE;\n        }\n        case \"node\":\n            return ELEMENT_WIDTH * (element.size || 1);\n    }\n}\n\nfunction heightOfNodes(stack: Stack<unknown, unknown>) {\n    let n = stack.elements.length;\n    return n * ELEMENT_HEIGHT + n * VERTICAL_SPACING + n * GROUP_MARGIN_TOP + n * GROUP_MARGIN_BOTTOM;\n}\n\nfunction fromIsUpper<T extends LayerPosition>(edge: Edge<T>) {\n    if (edge.from.layerIndex === edge.to.layerIndex) {\n        return edge.from.index <= edge.to.index;\n    }\n    return edge.from.layerIndex < edge.to.layerIndex;\n}\n\nfunction getUpperNode<T extends LayerPosition>(edge: Edge<T>): T {\n    return fromIsUpper(edge) ? edge.from : edge.to;\n}\n\nfunction getLowerNode<T extends LayerPosition>(edge: Edge<T>): T {\n    return fromIsUpper(edge) ? edge.to : edge.from;\n}\n\nexport function heightOfEdges(edges: (Edge<LayerPosition> & LayerPosition)[], numberOfLayers: number): number[] {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerPosition> & LayerPosition)[]>();\n    edges.forEach(edge => {\n        let layerIndex = getUpperNode(edge).layerIndex;\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\n        grouped.push(edge);\n        groupedByLayerIndex.set(layerIndex, grouped);\n    });\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\n    return layerIndices.map(layerIndex => {\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\n        return Math.max(...edgeIndices) * EDGE_SPACING;\n    })\n}\n\nfunction addLayerPositionToNodeG<N extends Node, E, G>(graph: Graph<N, E, G>): Graph<N & LayerPosition, E, G> {\n    return {\n        stack: addLayerPositionToNode(graph.stack) as Stack<N & LayerPosition, G>,\n        edges: graph.edges as unknown as (Edge<N & LayerPosition> & E)[]\n    }\n}\n\nfunction numberOfElements<N extends Node, G>(element: Node | Group<N> | Layer<N, G> | Stack<N, G>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return Math.max(...element.elements.map(numberOfElements));\n        case \"layer\":\n            return element.elements.map(numberOfElements).reduce((sum, add) => sum + add, 0);\n        case \"group\":\n            return element.elements.map(numberOfElements).reduce((sum, add) => sum + add, 0);\n        case \"node\":\n            return 1;\n    }\n}\n\nexport function addLayerPositionToNode<N extends Node, G>(\n    element: N | Group<N> | Layer<N, G> | Stack<N, G>,\n    fullWidth: number = 0,\n    layerIndex: number = 0,\n    layerOffset: number = 0,\n    accumulator: { index: number } = {index: 0}\n): N | Group<N & LayerPosition> | Layer<N & LayerPosition, G> | Stack<N & LayerPosition, G> {\n\n    switch (element.kind) {\n        case \"stack\": {\n            let fullWidth = numberOfElements(element);\n\n            return Object.assign(element, {\n                elements: element.elements.map((groups, layerIndex) =>\n                    addLayerPositionToNode(groups, fullWidth, layerIndex) as Layer<N & LayerPosition, G>\n                )\n            });\n        }\n        case \"layer\": {\n            let layerWidth = numberOfElements(element);\n            let layerOffset = (fullWidth - layerWidth) / 2;\n\n            let resultElements: (Group<N & LayerPosition> & G)[] = [];\n            let accumulator = {index: 0};\n            element.elements.forEach(group => {\n                let resultGroup = addLayerPositionToNode(group, fullWidth, layerIndex, layerOffset, accumulator);\n                resultElements.push(resultGroup as (Group<N & LayerPosition> & G));\n            });\n\n            return Object.assign(element, {\n                elements: resultElements\n            });\n        }\n        case \"group\": {\n            return Object.assign(element, {\n                elements: element.elements.map(node => {\n                    let resultNode = addLayerPositionToNode(node, fullWidth, layerIndex, layerOffset, accumulator);\n                    return resultNode as N & LayerPosition;\n                })\n            });\n        }\n        case \"node\": {\n            let resultElement = Object.assign(element, {\n                key: layerIndex + \"_\" + accumulator.index,\n                index: accumulator.index,\n                relativePosition: layerOffset + accumulator.index,\n                layerIndex: layerIndex\n            });\n            accumulator.index++;\n            return resultElement;\n        }\n    }\n}\n\nfunction addCoordinatesToNodeG<N extends (Node & LayerPosition), E extends LayerPosition, G>(graph: Graph<N, E, G>):\n    Graph<N & Coordinates, E, G> {\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n    addCoordinatesToNode(graph.stack, {x: 0}, heightOfAllEdges);\n    return graph as unknown as Graph<N & Coordinates, E, G>;\n}\n\nexport function addCoordinatesToNode<N extends (Node & LayerPosition), G>(\n    element: N | Group<N> | Layer<N, G> | Stack<N, G>,\n    accumulator: { x: number },\n    heightOfEdges: number[],\n    fullWidth: number = 0,\n    additionalEdgeHeight: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let fullWidth = width(element);\n            element.elements.forEach((layer, layerIndex) => {\n                let additionalEdgeHeight = heightOfEdges.slice(0, layerIndex).reduce((sum, add) => sum + add, 0);\n                addCoordinatesToNode(layer, accumulator, heightOfEdges, fullWidth, additionalEdgeHeight);\n            });\n            return;\n        }\n        case \"layer\": {\n            accumulator.x = MARGIN_SIDE + (fullWidth - width(element)) / 2;\n            element.elements.forEach(group => {\n                addCoordinatesToNode(group, accumulator, heightOfEdges, fullWidth, additionalEdgeHeight);\n            });\n            return;\n        }\n        case \"group\": {\n            accumulator.x += GROUP_MARGIN_SIDE;\n            element.elements.forEach(node => {\n                addCoordinatesToNode(node, accumulator, heightOfEdges, fullWidth, additionalEdgeHeight);\n            });\n            accumulator.x += GROUP_MARGIN_SIDE;\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                x: accumulator.x,\n                y: MARGIN_TOP + GROUP_MARGIN_TOP + element.layerIndex * (ELEMENT_HEIGHT + VERTICAL_SPACING + GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM) + additionalEdgeHeight\n            });\n            accumulator.x += ELEMENT_WIDTH * (element.size || 1) + HORIZONTAL_SPACING;\n            return;\n        }\n    }\n}\n\nfunction addLayerPositionToEdgeG<N extends LayerPosition, E, G>(graph: Graph<N, E, G>):\n    Graph<N, E & LayerPosition, G> {\n    addLayerPositionToEdge(graph.edges);\n    return {\n        stack: graph.stack,\n        edges: graph.edges as unknown as (Edge<N> & E & LayerPosition)[]\n    }\n}\n\nexport function addLayerPositionToEdge(edges: Edge<LayerPosition>[]) {\n    let groupedByLayerIndex = new Map<number, Edge<LayerPosition>[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperNode(edge).layerIndex;\n        let edges = groupedByLayerIndex.get(key) || [];\n        edges.push(edge);\n        groupedByLayerIndex.set(key, edges);\n    });\n\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\n}\n\nfunction addLayerPositionToEdgeForLayer(edges: Edge<LayerPosition>[]) {\n    let groupedByUpperNode = new Map<string, Edge<LayerPosition>[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperNode(edge).key;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerNode(edge).layerIndex === getUpperNode(edge).layerIndex);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerNode(edge).index <= getUpperNode(edge).index);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerNode(edge).index > getUpperNode(edge).index);\n        let otherLayer = edges.filter(edge => getLowerNode(edge).layerIndex !== getUpperNode(edge).layerIndex);\n        let otherLayerBefore = otherLayer.filter(edge => getLowerNode(edge).relativePosition <= getUpperNode(edge).relativePosition);\n        let otherLayerAfter = otherLayer.filter(edge => getLowerNode(edge).relativePosition > getUpperNode(edge).relativePosition);\n\n        sameLayerBefore.sort((edge1, edge2) => getLowerNode(edge1).index - getLowerNode(edge2).index);\n        otherLayerBefore.sort((edge1, edge2) => getLowerNode(edge1).index - getLowerNode(edge2).index);\n        otherLayerAfter.sort((edge1, edge2) => getLowerNode(edge2).index - getLowerNode(edge1).index);\n        sameLayerAfter.sort((edge1, edge2) => getLowerNode(edge1).index - getLowerNode(edge2).index);\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<LayerPosition>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let layerIndex = getUpperNode(edge).layerIndex;\n            let index = indexOffset + indexInArray;\n            Object.assign(edge, {\n                key: nodeKey + \"_\" + beforeOrAfter + \"_\" + index,\n                index: index,\n                layerIndex: layerIndex\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}\n\nfunction addConnectionIndexAndNumberOfEdgesG<N extends LayerPosition, E, G>(graph: Graph<N, E, G>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex, G> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    return {\n        stack: graph.stack as unknown as Stack<N & NumberOfEdges, G>,\n        edges: graph.edges as unknown as (Edge<N & NumberOfEdges> & E & ConnectionIndex)[]\n    }\n}\n\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerPosition>[]) {\n    type NodeSide = {\n        node: LayerPosition\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        reverseNode: LayerPosition\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(firstNode: LayerPosition, secondNode: LayerPosition, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.key + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index <= node.index);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index >= node.index);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\n\n        before.sort((edgeEnd1, edgeEnd2) => edgeEnd2.reverseNode.index - edgeEnd1.reverseNode.index);\n        otherLayer.sort((edgeEnd1, edgeEnd2) => edgeEnd1.reverseNode.index - edgeEnd2.reverseNode.index);\n        after.sort((edgeEnd1, edgeEnd2) => edgeEnd2.reverseNode.index - edgeEnd1.reverseNode.index);\n\n        let all = before.concat(otherLayer).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}\n\nfunction addPositionToGroupG<N, E, G>(graph: Graph<N, E, G>): Graph<N, E, G & GroupPosition> {\n    return {\n        stack: addPositionToGroup(graph.stack),\n        edges: graph.edges\n    }\n}\n\nexport function addPositionToGroup<N, G>(stack: Stack<N, G>): Stack<N, G & GroupPosition> {\n    return {\n        kind: 'stack',\n        elements: stack.elements.map((layer, layerIndex) => ({\n            kind: layer.kind,\n            elements: layer.elements.map((group, groupIndex) =>\n                Object.assign(group, {\n                    key: \"G_\" + layerIndex + \"_\" + groupIndex,\n                    index: groupIndex,\n                    layerIndex: layerIndex\n                }))\n        }))\n    };\n}\n\ntype Symbol = {\n    x: number\n    y: number\n    width: number\n    symbolKey: string\n}\n\nexport const ComponentSymbol: React.FC<Symbol> = symbol => {\n    const symbolHeightRelative = 1.1;\n    const barWidthRelative = 0.4;\n    const barHeightRelative = 0.15;\n    const barWidthAbsolute = symbol.width * barWidthRelative;\n    const barHeightAbsolute = symbol.width * barHeightRelative;\n    return (\n        <g key={symbol.symbolKey}>\n            <rect\n                x={symbol.x + barWidthAbsolute / 2} y={symbol.y}\n                width={symbol.width * (1 - barWidthRelative / 2)} height={symbol.width * symbolHeightRelative}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute * 3}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n        </g>\n    );\n};\n\nexport const Rect: React.FC<Node & LayerPosition & Coordinates> = node => {\n    let isComponent = node.symbol === \"component\";\n    let rectWidth = ELEMENT_WIDTH * (node.size || 1);\n    return (\n        <g key={node.key}>\n            <rect data-testid=\"rect\"\n                  x={node.x} y={node.y}\n                  width={rectWidth} height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n\n            <text x={node.x + TEXT_PADDING} y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + node.key}>\n                <rect\n                    x={node.x + TEXT_PADDING} y={node.y}\n                    width={rectWidth - 2 * TEXT_PADDING - (isComponent ? (SYMBOL_WIDTH + SYMBOL_SPACING) : 0)}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n\n            {isComponent ?\n                <ComponentSymbol\n                    symbolKey={node.key + \"CS\"}\n                    x={node.x + ELEMENT_WIDTH - SYMBOL_WIDTH - SYMBOL_SPACING}\n                    y={node.y + SYMBOL_SPACING}\n                    width={SYMBOL_WIDTH}/>\n                : \"\"}\n        </g>\n    );\n};\n\nconst Group: React.FC<Group<Node & Coordinates> & GroupPosition> = group => {\n    let nodes = group.elements.filter(element => element.kind === \"node\") as (Node & Coordinates)[];\n    let firstNode = nodes[0];\n    let n = group.elements.length;\n\n    let x = firstNode.x - GROUP_MARGIN_SIDE;\n    let y = firstNode.y - GROUP_MARGIN_TOP;\n    let contentWidth = n * ELEMENT_WIDTH + (n - 1) * HORIZONTAL_SPACING;\n    return (\n        <g key={group.key}>\n            <rect\n                x={x} y={y}\n                width={contentWidth + 2 * GROUP_MARGIN_SIDE}\n                height={ELEMENT_HEIGHT + GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text x={x + GROUP_MARGIN_SIDE} y={y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + group.key + \")\"}>{group.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + group.key}>\n                <rect\n                    x={x + GROUP_MARGIN_SIDE} y={y}\n                    width={contentWidth}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};\n\nexport const Path: React.FC<Edge<LayerPosition & Coordinates & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\n    let fromNodeOnLowerSide = edge.from.layerIndex <= edge.to.layerIndex;\n    let fromNodeCenteringOffset = (ELEMENT_WIDTH - ((fromNodeOnLowerSide ? edge.from.lowerSideEdges : edge.from.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    let fromNodeX = edge.from.x + fromNodeCenteringOffset + edge.fromIndex * EDGE_SPACING;\n    let fromNodeY = edge.from.y + (fromNodeOnLowerSide ? ELEMENT_HEIGHT : 0);\n    let upperNodeEdgesY = getUpperNode(edge).y + ELEMENT_HEIGHT + VERTICAL_SPACING / 2 + GROUP_MARGIN_BOTTOM + edge.index * EDGE_SPACING;\n    let toNodeOnLowerSide = edge.from.layerIndex >= edge.to.layerIndex;\n    let toNodeCenteringOffset = (ELEMENT_WIDTH - ((toNodeOnLowerSide ? edge.to.lowerSideEdges : edge.to.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    let toNodeX = edge.to.x + toNodeCenteringOffset + edge.toIndex * EDGE_SPACING;\n    let toNodeY = edge.to.y + (toNodeOnLowerSide ? ELEMENT_HEIGHT : 0);\n    return (\n        <path key={edge.key} d={\n            \"M \" + fromNodeX + \" \" + fromNodeY + \" \" +\n            \"L \" + fromNodeX + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNodeX + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNodeX + \" \" + toNodeY\n        }\n              stroke=\"black\"\n              strokeWidth={STROKE_WIDTH}\n              fill=\"none\"\n        />\n    );\n};\n\nfunction convertStringsToNodes(group: Group<string | Node>): Group<Node> {\n    return {\n        kind: 'group',\n        name: group.name,\n        elements: group.elements.map(element => {\n            if (typeof element === 'string') {\n                return {\n                    kind: 'node',\n                    name: element\n                }\n            } else if (\"elements\" in element) {\n                return convertStringsToNodes(element);\n            } else {\n                return Object.assign(element, {\n                    kind: 'node'\n                });\n            }\n        })\n    }\n}\n\nexport function stringsToNodes(strings: Group<string | Node>[][]): Stack<Node, unknown> {\n    return {\n        kind: 'stack',\n        elements: strings.map(layer => {\n            return {\n                kind: 'layer',\n                elements: layer.map(convertStringsToNodes)\n            }\n        })\n    };\n}\n\nlet graphAsString =\n    `var stack = stringsToNodes([\n    [\n        {name: \"group 1\", elements: [\n            \"element 11\", \n            {name: \"element 2\", size: 1.5, symbol: \"component\"}, \n            {name: \"an element with long text\", symbol: \"component\"}            \n        ]},\n        {name: \"group 2\", elements: [\"element 4\"]}\n    ],\n    [\n        {name: \"group 3\", elements: [\"element 1\", \"element 2\"]},\n        {name: \"group 4\", elements: [\"element 3\"]}\n    ],\n    [\n        {name: \"group 5\", elements: [\n            \"element 1\", \"element 2\", \"element 3\", \n            {name: \"element with changed name\", size: 1.5}, \n            {name: \"element 5\", size: 0.7}]}\n    ]\n]);\nvar layers = stack.elements;\n\nvar edges = [\n    {from: layers[0].elements[0].elements[1], to: layers[1].elements[0].elements[0]},\n    {from: layers[0].elements[0].elements[2], to: layers[1].elements[1].elements[0]},\n    {from: layers[0].elements[1].elements[0], to: layers[1].elements[0].elements[1]},\n    {from: layers[1].elements[1].elements[0], to: layers[2].elements[0].elements[2]},\n    {from: layers[1].elements[0].elements[1], to: layers[2].elements[0].elements[4]},\n    {from: layers[1].elements[0].elements[1], to: layers[2].elements[0].elements[3]},\n    {from: layers[1].elements[0].elements[1], to: layers[2].elements[0].elements[2]},\n    {from: layers[1].elements[0].elements[1], to: layers[2].elements[0].elements[1]},\n    {from: layers[1].elements[0].elements[1], to: layers[2].elements[0].elements[0]},\n    {from: layers[2].elements[0].elements[0], to: layers[1].elements[0].elements[0]},\n    {from: layers[2].elements[0].elements[1], to: layers[1].elements[0].elements[0]},\n    {from: layers[2].elements[0].elements[0], to: layers[2].elements[0].elements[3]},\n    {from: layers[2].elements[0].elements[1], to: layers[2].elements[0].elements[3]},\n    {from: layers[2].elements[0].elements[4], to: layers[2].elements[0].elements[3]},\n    {from: layers[0].elements[0].elements[0], to: layers[0].elements[0].elements[2]},\n    {from: layers[0].elements[0].elements[0], to: layers[0].elements[0].elements[1]},\n    {from: layers[0].elements[0].elements[0], to: layers[1].elements[0].elements[0]},\n    {from: layers[0].elements[0].elements[0], to: layers[1].elements[0].elements[0]},\n    {from: layers[1].elements[0].elements[1], to: layers[1].elements[0].elements[0]},\n    {from: layers[1].elements[0].elements[1], to: layers[1].elements[1].elements[0]}\n];\n\nvar graph = {\n    stack: stack,\n    edges: edges\n};\n\ngraph\n`;\n\n// eslint-disable-next-line\nconst initialGraph: Graph<Node, unknown, unknown> = eval(graphAsString);\n\nexport function allNodes<N extends Node, G, E>(element: Stack<N, G> | Group<N> | N): N[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allNodes);\n        case \"group\":\n            return element.elements.flatMap(allNodes);\n        case \"node\":\n            return [element];\n    }\n}\n\nexport const Diagram: React.FC<Graph<Node, unknown, unknown>> = graph => {\n    return [graph]\n        .map(addLayerPositionToNodeG)\n        .map(addLayerPositionToEdgeG)\n        .map(addCoordinatesToNodeG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(addPositionToGroupG)\n        .map(graph => {\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n            let overallWidth = width(graph.stack) + 2 * MARGIN_SIDE;\n            let height = heightOfNodes(graph.stack) + heightOfAllEdges.reduce((sum, add) => sum + add) + 2 * MARGIN_TOP;\n\n            return (\n                <svg viewBox={\"0 0 \" + overallWidth + \" \" + height}>\n                    {allNodes(graph.stack).map(Rect)}\n                    {graph.stack.elements.flatMap(layer => layer.elements).map(Group)}\n                    {graph.edges.map(Path)}\n                </svg>\n            );\n        })[0];\n};\n\nexport function parseGraph(text: string): Graph<Node, unknown, unknown> | string {\n    try {\n// eslint-disable-next-line\n        let graph: Graph<Node, unknown, unknown> = eval(text);\n\n        if (graph === undefined) return \"Script is not returning a graph object!\";\n\n        if (graph.stack === undefined) return \"Property layers is missing in graph object!\";\n        if (graph.edges === undefined) return \"Property edges is missing in graph object!\";\n\n        let layers = graph.stack.elements;\n        let aNodeIsUndefined = false;\n        // It is necessary to go through the nested arrays by index,\n        // because the array operations `every`, `map` and `flat` bypass empty array elements.\n        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n            let groups = layers[layerIndex].elements;\n            for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n                let elements = groups[groupIndex].elements;\n                for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\n                    if (elements[elementIndex] === undefined) aNodeIsUndefined = true;\n                }\n            }\n        }\n        if (aNodeIsUndefined) return \"Every node must be defined!\";\n\n        if (!graph.edges.every((edge: Edge<Node>) => edge.from !== undefined))\n            return \"Property from must be defined on every edge!\";\n        if (!graph.edges.every((edge: Edge<Node>) => edge.to !== undefined))\n            return \"Property to must be defined on every edge!\";\n\n        return graph;\n    } catch (e) {\n        return e.message;\n    }\n}\n\nconst App: React.FC = () => {\n    const [graph, setGraph] = useState(initialGraph);\n    const [errorMessage, setErrorMessage] = useState(\"\");\n\n    function handleChange(changeEvent: React.ChangeEvent<HTMLTextAreaElement>) {\n        let result = parseGraph(changeEvent.target.value);\n        if (typeof result === 'string') {\n            setErrorMessage(result);\n        } else {\n            setGraph(result);\n            setErrorMessage(\"\");\n        }\n    }\n\n    return (\n        <div id=\"parent\" className=\"App\">\n            <div id=\"graph\">\n                <Diagram stack={graph.stack} edges={graph.edges}/>\n            </div>\n            <div>\n                <textarea cols={100} rows={45} onChange={handleChange} defaultValue={graphAsString}/>\n                <p className=\"error-message\">{errorMessage}</p>\n            </div>\n        </div>\n    );\n};\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}