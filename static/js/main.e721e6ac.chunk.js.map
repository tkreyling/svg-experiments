{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["MARGIN_TOP","MARGIN_SIDE","ELEMENT_WIDTH","ELEMENT_HEIGHT","HORIZONTAL_SPACING","VERTICAL_SPACING","EDGE_SPACING","widthOfLayers","layers","Math","max","map","widthOfElements","elements","n","length","fromIsUpper","edge","from","layerIndex","to","index","getUpperNode","getLowerNode","heightOfEdges","edges","numberOfLayers","groupedByLayerIndex","Map","forEach","grouped","get","push","set","Array","keys","edgeIndices","addLayerPositionToNodeG","graph","addLayerPositionToNode","fullWidth","nodes","width","layerOffset","element","Object","assign","key","relativePosition","addCoordinatesToNodeG","heightOfAllEdges","layout","additionalEdgeHeight","slice","reduce","sum","add","offsetToCenter","x","y","layoutHorizontally","addLayerPositionToEdgeG","values","addLayerPositionToEdgeForLayer","addLayerPositionToEdge","groupedByUpperNode","nodeKeys","sort","indexOffset","nodeKey","sameLayer","filter","sameLayerBefore","sameLayerAfter","otherLayer","otherLayerBefore","otherLayerAfter","edge1","edge2","before","concat","after","addLayerPosition","indexInArray","addConnectionIndexAndNumberOfEdgesG","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","node","edgeEnds","reverseNode","fromIndex","toIndex","edgeEnd","edgeEnd1","edgeEnd2","upperSideEdges","lowerSideEdges","addConnectionIndexAndNumberOfEdges","Rect","data-testid","height","fill","strokeWidth","stroke","clipPath","name","id","Path","fromNodeOnLowerSide","fromNodeCenteringOffset","fromNodeX","fromNodeY","upperNodeEdgesY","toNodeOnLowerSide","toNodeCenteringOffset","toNodeX","toNodeY","d","layer","Diagram","heightOfNodes","viewBox","flat","App","className","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e721e6ac.chunk.js","sourcesContent":["import React from 'react';\r\nimport './App.css';\r\n\r\nexport type Coordinates = {\r\n    x: number\r\n    y: number\r\n}\r\n\r\nexport type LayerPosition = {\r\n    key: string\r\n    index: number\r\n    relativePosition: number\r\n    layerIndex: number\r\n}\r\n\r\nexport type Node = {\r\n    name: string\r\n}\r\n\r\nexport type Edge<T> = {\r\n    from: T\r\n    to: T\r\n}\r\n\r\ntype ConnectionIndex = {\r\n    fromIndex: number\r\n    toIndex: number\r\n}\r\n\r\ntype NumberOfEdges = {\r\n    upperSideEdges: number\r\n    lowerSideEdges: number\r\n}\r\n\r\ntype Graph<N, E> = {\r\n    layers: N[][]\r\n    edges: (Edge<N> & E)[]\r\n}\r\n\r\nexport const MARGIN_TOP = 5;\r\nexport const MARGIN_SIDE = 5;\r\nexport const ELEMENT_WIDTH = 150;\r\nexport const ELEMENT_HEIGHT = 40;\r\nexport const HORIZONTAL_SPACING = 10;\r\nexport const VERTICAL_SPACING = 20;\r\nexport const TEXT_PADDING = 5;\r\nexport const EDGE_SPACING = 10;\r\n\r\nexport function widthOfLayers(layers: any[][]) {\r\n    return Math.max(...layers.map(widthOfElements));\r\n}\r\n\r\nexport function widthOfElements(elements: any[]) {\r\n    const n = elements.length;\r\n    if (n === 0) return 0;\r\n    return n*ELEMENT_WIDTH + (n - 1)*HORIZONTAL_SPACING;\r\n}\r\n\r\nfunction heightOfNodes(layers: Node[][]) {\r\n    let n = layers.length;\r\n    return n*ELEMENT_HEIGHT + n*VERTICAL_SPACING;\r\n}\r\n\r\nfunction fromIsUpper<T extends LayerPosition>(edge: Edge<T>) {\r\n    if (edge.from.layerIndex === edge.to.layerIndex) {\r\n        return edge.from.index <= edge.to.index;\r\n    }\r\n    return edge.from.layerIndex < edge.to.layerIndex;\r\n}\r\n\r\nfunction getUpperNode<T extends LayerPosition>(edge: Edge<T>): T {\r\n    return fromIsUpper(edge) ? edge.from : edge.to;\r\n}\r\n\r\nfunction getLowerNode<T extends LayerPosition>(edge: Edge<T>): T {\r\n    return fromIsUpper(edge) ? edge.to : edge.from;\r\n}\r\n\r\nexport function heightOfEdges(edges: (Edge<LayerPosition> & LayerPosition)[], numberOfLayers: number): number[] {\r\n    let groupedByLayerIndex = new Map<number, (Edge<LayerPosition> & LayerPosition)[]>();\r\n    edges.forEach(edge => {\r\n        let layerIndex = getUpperNode(edge).layerIndex;\r\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\r\n        grouped.push(edge);\r\n        groupedByLayerIndex.set(layerIndex, grouped);\r\n    });\r\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\r\n    return layerIndices.map(layerIndex => {\r\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\r\n        return Math.max(...edgeIndices) * EDGE_SPACING;\r\n    })\r\n}\r\n\r\nfunction addLayerPositionToNodeG<N, E>(graph: Graph<N, E>): Graph<N & LayerPosition, E> {\r\n    return {\r\n        layers: addLayerPositionToNode(graph.layers),\r\n        edges: graph.edges as unknown as (Edge<N & LayerPosition> & E)[]\r\n    }\r\n}\r\n\r\nexport function addLayerPositionToNode<N>(layers: N[][]): (N & LayerPosition)[][] {\r\n    let fullWidth = Math.max(...layers.map(nodes => nodes.length));\r\n    return layers.map((elements, layerIndex) => {\r\n        let width = elements.length;\r\n        let layerOffset = (fullWidth - width) / 2;\r\n        return elements.map((element, index) => {\r\n            return Object.assign(element, {\r\n                key: layerIndex + \"_\" + index,\r\n                index: index,\r\n                relativePosition : layerOffset + index,\r\n                layerIndex: layerIndex\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\nfunction addCoordinatesToNodeG<N extends LayerPosition, E extends LayerPosition>(graph: Graph<N, E>):\r\n    Graph<N & Coordinates, E> {\r\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.layers.length);\r\n    return {\r\n        layers: layout(graph.layers, heightOfAllEdges),\r\n        edges: graph.edges as unknown as (Edge<N & Coordinates> & E)[]\r\n    }\r\n}\r\n\r\nexport function layout<N>(layers: (N & LayerPosition)[][], heightOfEdges: number[]): (N & LayerPosition & Coordinates)[][] {\r\n    let fullWidth = widthOfLayers(layers);\r\n    return layers.map((elements, layerIndex) => {\r\n        let additionalEdgeHeight = heightOfEdges.slice(0, layerIndex).reduce((sum, add) => sum + add, 0);\r\n        return layoutHorizontally(elements, fullWidth, additionalEdgeHeight)\r\n    });\r\n}\r\n\r\nexport function layoutHorizontally<N>(elements: (N & LayerPosition)[], fullWidth: number, additionalEdgeHeight: number): (N & LayerPosition & Coordinates)[] {\r\n    let offsetToCenter = (fullWidth - widthOfElements(elements)) / 2;\r\n    return elements.map(element =>\r\n        Object.assign(element, {\r\n            x: element.index * (ELEMENT_WIDTH + HORIZONTAL_SPACING) + MARGIN_SIDE + offsetToCenter,\r\n            y: element.layerIndex * (ELEMENT_HEIGHT + VERTICAL_SPACING) + MARGIN_TOP + additionalEdgeHeight\r\n        }));\r\n}\r\n\r\nfunction addLayerPositionToEdgeG<N extends LayerPosition, E>(graph: Graph<N, E>): Graph<N, E & LayerPosition> {\r\n    addLayerPositionToEdge(graph.edges);\r\n    return {\r\n        layers: graph.layers,\r\n        edges: graph.edges as unknown as (Edge<N> & E & LayerPosition)[]\r\n    }\r\n}\r\n\r\nexport function addLayerPositionToEdge(edges: Edge<LayerPosition>[]) {\r\n    let groupedByLayerIndex = new Map<number, Edge<LayerPosition>[]>();\r\n\r\n    edges.forEach(edge => {\r\n        let key = getUpperNode(edge).layerIndex;\r\n        let edges = groupedByLayerIndex.get(key) || [];\r\n        edges.push(edge);\r\n        groupedByLayerIndex.set(key, edges);\r\n    });\r\n\r\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\r\n}\r\n\r\nfunction addLayerPositionToEdgeForLayer(edges: Edge<LayerPosition>[]) {\r\n    let groupedByUpperNode = new Map<string, Edge<LayerPosition>[]>();\r\n\r\n    edges.forEach(edge => {\r\n        let key = getUpperNode(edge).key;\r\n        let edges = groupedByUpperNode.get(key) || [];\r\n        edges.push(edge);\r\n        groupedByUpperNode.set(key, edges);\r\n    });\r\n\r\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\r\n    nodeKeys.sort();\r\n\r\n    let indexOffset = 0;\r\n    nodeKeys.forEach(nodeKey => {\r\n        let edges = groupedByUpperNode.get(nodeKey)!;\r\n\r\n        let sameLayer = edges.filter(edge => getLowerNode(edge).layerIndex === getUpperNode(edge).layerIndex);\r\n        let sameLayerBefore = sameLayer.filter(edge => getLowerNode(edge).index <= getUpperNode(edge).index);\r\n        let sameLayerAfter = sameLayer.filter(edge => getLowerNode(edge).index > getUpperNode(edge).index);\r\n        let otherLayer = edges.filter(edge => getLowerNode(edge).layerIndex !== getUpperNode(edge).layerIndex);\r\n        let otherLayerBefore = otherLayer.filter(edge => getLowerNode(edge).relativePosition <= getUpperNode(edge).relativePosition);\r\n        let otherLayerAfter = otherLayer.filter(edge => getLowerNode(edge).relativePosition > getUpperNode(edge).relativePosition);\r\n\r\n        sameLayerBefore.sort((edge1, edge2) =>  getLowerNode(edge1).index - getLowerNode(edge2).index);\r\n        otherLayerBefore.sort((edge1, edge2) =>  getLowerNode(edge1).index - getLowerNode(edge2).index);\r\n        otherLayerAfter.sort((edge1, edge2) =>  getLowerNode(edge2).index - getLowerNode(edge1).index);\r\n        sameLayerAfter.sort((edge1, edge2) =>  getLowerNode(edge1).index - getLowerNode(edge2).index);\r\n\r\n        let before = sameLayerBefore.concat(otherLayerBefore);\r\n        let after = sameLayerAfter.concat(otherLayerAfter);\r\n\r\n        function addLayerPosition(edge: Edge<LayerPosition>, indexInArray: number) {\r\n            let layerIndex = getUpperNode(edge).layerIndex;\r\n            let index = indexOffset + indexInArray;\r\n            Object.assign(edge, {\r\n                key: layerIndex + \"_\" + index,\r\n                index: index,\r\n                layerIndex: layerIndex\r\n            });\r\n        }\r\n\r\n        before.forEach((edge, index) => addLayerPosition(edge, index));\r\n        after.forEach((edge, index) => addLayerPosition(edge, index));\r\n\r\n        indexOffset += Math.max(before.length, after.length);\r\n    });\r\n}\r\n\r\nfunction addConnectionIndexAndNumberOfEdgesG<N extends LayerPosition, E>(graph: Graph<N, E>):\r\n    Graph<N & NumberOfEdges, E & ConnectionIndex> {\r\n    addConnectionIndexAndNumberOfEdges(graph.edges);\r\n    return {\r\n        layers: graph.layers as unknown as (N & NumberOfEdges)[][],\r\n        edges: graph.edges as unknown as (Edge<N & NumberOfEdges> & E & ConnectionIndex)[]\r\n    }\r\n}\r\n\r\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerPosition>[]) {\r\n    type NodeSide = {\r\n        node: LayerPosition\r\n        side: \"LOWER\" | \"UPPER\"\r\n        edgeEnds: EdgeEnd[]\r\n    }\r\n\r\n    type EdgeEnd = {\r\n        reverseNode: LayerPosition\r\n        setIndex: (index: number) => void\r\n    }\r\n\r\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\r\n\r\n    function addEdgeEnd(firstNode: LayerPosition, secondNode: LayerPosition, setIndex: (index: number) => void) {\r\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\r\n        let key = firstNode.key + side;\r\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\r\n            node: firstNode,\r\n            side: side,\r\n            edgeEnds: []\r\n        };\r\n        nodeSide.edgeEnds.push({\r\n            reverseNode: secondNode,\r\n            setIndex: setIndex\r\n        });\r\n        groupedByNodeAndSide.set(key, nodeSide);\r\n    }\r\n\r\n    edges.forEach(edge => {\r\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\r\n        addEdgeEnd(edge.to, edge.from, index=> Object.assign(edge, {toIndex: index}));\r\n    });\r\n\r\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\r\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\r\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index <= node.index);\r\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index >= node.index);\r\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\r\n\r\n        before.sort((edgeEnd1, edgeEnd2) => edgeEnd2.reverseNode.index - edgeEnd1.reverseNode.index);\r\n        otherLayer.sort((edgeEnd1, edgeEnd2) => edgeEnd1.reverseNode.index - edgeEnd2.reverseNode.index);\r\n        after.sort((edgeEnd1, edgeEnd2) => edgeEnd2.reverseNode.index - edgeEnd1.reverseNode.index);\r\n\r\n        let all = before.concat(otherLayer).concat(after);\r\n        all.forEach((edgeEnd, index) => {\r\n            edgeEnd.setIndex(index);\r\n        });\r\n        if (side === \"UPPER\") {\r\n            Object.assign(node, {\r\n                upperSideEdges: edgeEnds.length\r\n            });\r\n        } else {\r\n            Object.assign(node, {\r\n                lowerSideEdges: edgeEnds.length\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport const Rect: React.FC<Node & LayerPosition & Coordinates> = node => {\r\n    return (\r\n        <g key={node.key}>\r\n            <rect data-testid=\"rect\"\r\n                  x={node.x} y={node.y}\r\n                  width={ELEMENT_WIDTH} height={ELEMENT_HEIGHT}\r\n                  fill=\"lightgrey\" strokeWidth={1} stroke=\"black\"/>\r\n\r\n            <text x={node.x + TEXT_PADDING } y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\r\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\r\n            </text>\r\n\r\n            <clipPath id={\"clip-element-text-\" + node.key}>\r\n                <rect x={node.x + TEXT_PADDING} y={node.y} width={ELEMENT_WIDTH - 2 * TEXT_PADDING} height={ELEMENT_HEIGHT}/>\r\n            </clipPath>\r\n        </g>\r\n    );\r\n};\r\n\r\nexport const Path: React.FC<Edge<LayerPosition & Coordinates & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\r\n    let fromNodeOnLowerSide = edge.from.layerIndex <= edge.to.layerIndex;\r\n    let fromNodeCenteringOffset = (ELEMENT_WIDTH - ((fromNodeOnLowerSide ? edge.from.lowerSideEdges : edge.from.upperSideEdges) - 1) * EDGE_SPACING) / 2;\r\n    let fromNodeX = edge.from.x + fromNodeCenteringOffset + edge.fromIndex * EDGE_SPACING;\r\n    let fromNodeY = edge.from.y + (fromNodeOnLowerSide ? ELEMENT_HEIGHT : 0);\r\n    let upperNodeEdgesY = getUpperNode(edge).y + ELEMENT_HEIGHT + VERTICAL_SPACING / 2 + edge.index * EDGE_SPACING;\r\n    let toNodeOnLowerSide = edge.from.layerIndex >= edge.to.layerIndex;\r\n    let toNodeCenteringOffset = (ELEMENT_WIDTH - ((toNodeOnLowerSide ? edge.to.lowerSideEdges : edge.to.upperSideEdges) - 1) * EDGE_SPACING) / 2;\r\n    let toNodeX = edge.to.x + toNodeCenteringOffset + edge.toIndex * EDGE_SPACING;\r\n    let toNodeY = edge.to.y + (toNodeOnLowerSide ? ELEMENT_HEIGHT : 0);\r\n    return (\r\n        <path d={\r\n            \"M \" + fromNodeX + \" \" + fromNodeY + \" \" +\r\n            \"L \" + fromNodeX + \" \" + upperNodeEdgesY + \" \" +\r\n            \"L \" + toNodeX + \" \" + upperNodeEdgesY + \" \" +\r\n            \"L \" + toNodeX + \" \" + toNodeY\r\n        }\r\n              stroke=\"black\"\r\n              strokeWidth={1}\r\n              fill=\"none\"\r\n        />\r\n    );\r\n};\r\n\r\nconst layers: Node[][] = [\r\n    [\"element 1\", \"element 2\", \"an element with long text\", \"element 4\"],\r\n    [\"element 1\", \"element 2\", \"element 3\"],\r\n    [\"element 1\", \"element 2\", \"element 3\", \"element 4\", \"element 5\"]\r\n].map(layer => {\r\n    return layer.map(name => {\r\n        return {name: name}\r\n    })\r\n});\r\n\r\nconst edges = [\r\n    {from: layers[0][1], to: layers[1][0]},\r\n    {from: layers[0][2], to: layers[1][2]},\r\n    {from: layers[0][3], to: layers[1][1]},\r\n    {from: layers[1][2], to: layers[2][2]},\r\n    {from: layers[1][1], to: layers[2][4]},\r\n    {from: layers[1][1], to: layers[2][3]},\r\n    {from: layers[1][1], to: layers[2][2]},\r\n    {from: layers[1][1], to: layers[2][1]},\r\n    {from: layers[1][1], to: layers[2][0]},\r\n    {from: layers[2][0], to: layers[1][0]},\r\n    {from: layers[2][1], to: layers[1][0]},\r\n    {from: layers[2][0], to: layers[2][3]},\r\n    {from: layers[2][1], to: layers[2][3]},\r\n    {from: layers[0][0], to: layers[0][2]},\r\n    {from: layers[0][0], to: layers[0][1]},\r\n    {from: layers[0][0], to: layers[1][0]},\r\n    {from: layers[0][0], to: layers[1][0]},\r\n    {from: layers[1][1], to: layers[1][0]},\r\n    {from: layers[1][1], to: layers[1][2]}\r\n];\r\n\r\nexport const Diagram: React.FC<Graph<Node, unknown>> = graph => {\r\n    return [graph]\r\n        .map(addLayerPositionToNodeG)\r\n        .map(addLayerPositionToEdgeG)\r\n        .map(addCoordinatesToNodeG)\r\n        .map(addConnectionIndexAndNumberOfEdgesG)\r\n        .map(graph => {\r\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.layers.length);\r\n            let width = widthOfLayers(graph.layers) + 2 * MARGIN_SIDE;\r\n            let height = heightOfNodes(graph.layers) + heightOfAllEdges.reduce((sum, add) => sum + add) + 2 * MARGIN_TOP;\r\n\r\n            return (\r\n                <svg viewBox={\"0 0 \" + width + \" \" + height}>\r\n                    {graph.layers.flat().map(Rect)}\r\n                    {graph.edges.map(Path)}\r\n                </svg>\r\n            );\r\n        })[0];\r\n};\r\n\r\nconst App: React.FC = () => {\r\n    return (\r\n        <div className=\"App\">\r\n            <Diagram layers={layers} edges={edges}/>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}