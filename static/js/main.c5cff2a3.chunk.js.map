{"version":3,"sources":["App.tsx","parseGraph.tsx","addIndexAndKeyToNode.tsx","styling.tsx","width.tsx","addXToNode.tsx","sorting.tsx","graphModel.tsx","addLayerPositionToEdge.tsx","heightOfEdges.tsx","addYToNode.tsx","addConnectionIndexAndNumberOfEdges.tsx","allNodes.tsx","allGroups.tsx","Symbols.tsx","NodeShape.tsx","GroupShape.tsx","EdgeShape.tsx","addLayerIndexToNode.tsx","insertPlaceholdersInMultilayerEdges.tsx","Diagram.tsx","serviceWorker.ts","index.tsx","indicesToReferences.tsx","stringsToNodes.tsx"],"names":["graphAsString","indicesToReferences","indicesToReferencesImport","stringsToNodes","stringsToNodesImport","initialGraph","eval","App","useState","graph","setGraph","errorMessage","setErrorMessage","id","className","stack","edges","cols","rows","onChange","changeEvent","result","parseGraph","target","value","defaultValue","text","undefined","every","edge","from","to","e","message","addIndexAndKeyToNodeG","addIndexAndKeyToNode","element","layerIndex","accumulator","index","groupIndex","kind","elements","forEach","groups","group","Object","assign","key","node","MARGIN_TOP","MARGIN_SIDE","ELEMENT_WIDTH","ELEMENT_HEIGHT","GROUP_MARGIN_TOP","GROUP_MARGIN_BOTTOM","GROUP_MARGIN_SIDE","HORIZONTAL_SPACING","VERTICAL_SPACING","EDGE_SPACING","width","Math","max","map","reduce","sum","add","size","addXToNodeG","addXToNode","fullWidth","layer","x","ascending","property","o1","o2","descending","and","sortFunctions","i","length","fromIsUpper","getUpperNode","getLowerNode","addLayerPositionToEdgeG","groupedByLayerIndex","Map","edgeIndex","get","push","set","Array","values","addLayerPositionToEdgeForLayer","addLayerPositionToEdge","groupedByUpperNode","nodeKeys","keys","sort","indexOffset","nodeKey","sameLayer","filter","sameLayerBefore","sameLayerAfter","otherLayer","otherLayerBefore","otherLayerAfter","before","concat","after","addLayerPosition","indexInArray","beforeOrAfter","heightOfEdges","numberOfLayers","grouped","edgeIndices","heightOfNodes","isPlaceholder","groupNestingLevel","addYToNodeG","heightOfAllEdges","addYToNode","additionalEdgeHeight","y","slice","nodeY","groupHeight","belowLayerY","height","addConnectionIndexAndNumberOfEdgesG","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","edgeEnds","reverseNode","fromIndex","toIndex","edgeEnd","upperSideEdges","lowerSideEdges","addConnectionIndexAndNumberOfEdges","allNodes","flatMap","allGroups","ComponentSymbol","symbol","barWidthAbsolute","barHeightAbsolute","symbolKey","fill","strokeWidth","stroke","NodeShape","isComponent","data-testid","clipPath","name","SYMBOL_WIDTH","GroupShape","edgeEndCoordinates","otherNode","onLowerSide","nodeCenteringOffset","EdgeShape","fromNode","upperNodeEdgesY","toNode","d","addLayerIndexToNodeG","addLayerIndexToNode","insertPlaceholdersInMultilayerEdges","abs","min","newEdges","last","end","placeholder","splice","Diagram","overallWidth","viewBox","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","indexToReference","Error","indexPairs","indexPair","indexPairToReference","convertStringsToNodes","strings"],"mappings":"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","file":"static/js/main.c5cff2a3.chunk.js","sourcesContent":["import React, {useState} from 'react';\nimport './App.css';\nimport {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\nimport {Diagram} from \"./Diagram\";\nimport {parseGraph} from \"./parseGraph\";\nimport {Graph, Node} from \"./graphModel\";\n\nlet graphAsString =\n    `var stack = stringsToNodes([\n    [\n        {name: \"group 1\", elements: [\n            \"element 11\", \n            {name: \"element 2\", size: 1.5, symbol: \"component\"}, \n            {name: \"an element with long text\", symbol: \"component\"}            \n        ]},\n        {name: \"group 2\", elements: [\"element 4\"]}\n    ],\n    [\n        {name: \"group 3\", elements: [\"element 1\", \"element 2\"]},\n        {name: \"group 4\", elements: [\n            {name: \"group 6\", elements: [\"element 4\"]}, \n            {name: \"placeholder\", size: 0.3, isPlaceholder: true}, \n            \"element 3\"\n        ]},\n        \"node on top level\", \n        {name: \"an element with long text\", symbol: \"component\"}     \n    ],\n    [\n        {name: \"group 5\", elements: [\n            \"element 1\", \"element 2\", \"element 3\", \n            {name: \"element with changed name\", size: 1.5}, \n            {name: \"element 5\", size: 0.7}]}\n    ]\n]);\n\nvar edgeIndices = [\n    {from: [0, 0, 0],    to: [1, 3]},\n    {from: [0, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 2],    to: [1, 1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 0, 1]},\n    {from: [1, 1, 0, 0], to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 4]},\n    {from: [1, 0, 1],    to: [2, 0, 3]},\n    {from: [1, 0, 1],    to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [2, 0, 0]},\n    {from: [2, 0, 0],    to: [1, 0, 0]},\n    {from: [2, 0, 1],    to: [1, 0, 0]},\n    {from: [2, 0, 0],    to: [2, 0, 3]},\n    {from: [2, 0, 1],    to: [2, 0, 3]},\n    {from: [2, 0, 4],    to: [2, 0, 3]},\n    {from: [0, 0, 0],    to: [0, 0, 2]},\n    {from: [0, 0, 0],    to: [0, 0, 1]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 1, 1]},\n    {from: [1, 1, 1],    to: [2, 0, 2]},\n    {from: [0, 1, 0],    to: [1, 1, 2]},\n    {from: [1, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [1, 1, 0, 0]}\n];\nvar edges = indicesToReferences(stack, edgeIndices);\n\nvar graph = {\n    stack: stack,\n    edges: edges\n};\n\ngraph\n`;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\n// eslint-disable-next-line no-eval\nconst initialGraph: Graph<Node, unknown, unknown> = eval(graphAsString);\n\nconst App: React.FC = () => {\n    const [graph, setGraph] = useState(initialGraph);\n    const [errorMessage, setErrorMessage] = useState(\"\");\n\n    function handleChange(changeEvent: React.ChangeEvent<HTMLTextAreaElement>) {\n        let result = parseGraph(changeEvent.target.value);\n        if (typeof result === 'string') {\n            setErrorMessage(result);\n        } else {\n            setGraph(result);\n            setErrorMessage(\"\");\n        }\n    }\n\n    return (\n        <div id=\"parent\" className=\"App\">\n            <div id=\"graph\">\n                <Diagram stack={graph.stack} edges={graph.edges}/>\n            </div>\n            <div>\n                <textarea cols={100} rows={45} onChange={handleChange} defaultValue={graphAsString}/>\n                <p className=\"error-message\">{errorMessage}</p>\n            </div>\n        </div>\n    );\n};\n\nexport default App;","import {Edge, Graph, Node} from \"./graphModel\";\nimport {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\nexport function parseGraph(text: string): Graph<Node, unknown, unknown> | string {\n    try {\n// eslint-disable-next-line\n        let graph: Graph<Node, unknown, unknown> = eval(text);\n\n        if (graph === undefined) return \"Script is not returning a graph object!\";\n\n        if (graph.stack === undefined) return \"Property layers is missing in graph object!\";\n        if (graph.edges === undefined) return \"Property edges is missing in graph object!\";\n\n        if (!graph.edges.every((edge: Edge<Node>) => edge.from !== undefined))\n            return \"Property from must be defined on every edge!\";\n        if (!graph.edges.every((edge: Edge<Node>) => edge.to !== undefined))\n            return \"Property to must be defined on every edge!\";\n\n        return graph;\n    } catch (e) {\n        return e.message;\n    }\n}","import {Graph, Group, IndexAndKey, Layer, Node, Stack} from \"./graphModel\";\n\nexport function addIndexAndKeyToNodeG<N extends Node, E, G>(graph: Graph<N, E, G>):\n    Graph<N & IndexAndKey, E, G & IndexAndKey> {\n    addIndexAndKeyToNode(graph.stack);\n    return graph as unknown as Graph<N & IndexAndKey, E, G & IndexAndKey>;\n}\n\nexport function addIndexAndKeyToNode<N extends Node, G>(\n    element: N | Group<N, G> | Layer<N, G> | Stack<N, G>,\n    layerIndex: number = 0,\n    accumulator: { index: number, groupIndex: number } = {index: 0, groupIndex: 0}\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach((groups, layerIndex) => {\n                addIndexAndKeyToNode(groups, layerIndex);\n            });\n            return;\n        }\n        case \"layer\": {\n            let accumulator = {index: 0, groupIndex: 0};\n\n            element.elements.forEach(group => {\n                addIndexAndKeyToNode(group, layerIndex, accumulator);\n            });\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                key: \"G_\" + layerIndex + \"_\" + accumulator.groupIndex,\n                index: accumulator.groupIndex\n            });\n            accumulator.groupIndex++;\n\n            element.elements.forEach(node => {\n                addIndexAndKeyToNode(node, layerIndex, accumulator);\n            });\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                key: layerIndex + \"_\" + accumulator.index,\n                index: accumulator.index\n            });\n            accumulator.index++;\n            return;\n        }\n    }\n}","export const MARGIN_TOP = 5;\nexport const MARGIN_SIDE = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const SYMBOL_WIDTH = 12;\nexport const SYMBOL_SPACING = 3;\nexport const GROUP_MARGIN_TOP = 30;\nexport const GROUP_MARGIN_BOTTOM = 10;\nexport const GROUP_MARGIN_SIDE = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const TEXT_PADDING = 5;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;","import {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING} from \"./styling\";\nimport {Group, Layer, Node, Stack} from \"./graphModel\";\n\nexport function width(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return Math.max(...element.elements.map(width));\n        case \"layer\":\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"group\": {\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0) + 2 * GROUP_MARGIN_SIDE;\n        }\n        case \"node\":\n            return ELEMENT_WIDTH * (element.size || 1);\n    }\n}","import {width} from \"./width\";\nimport {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING, MARGIN_SIDE} from \"./styling\";\nimport {Graph, Group, GroupPosition, Layer, LayerPosition, Node, Stack, X} from \"./graphModel\";\n\nexport function addXToNodeG<N extends (Node & LayerPosition), E, G extends GroupPosition>(\n    graph: Graph<N, E, G>\n): Graph<N & X, E, G & X> {\n    addXToNode(graph.stack, {x: 0});\n    return graph as unknown as Graph<N & X, E, G & X>;\n}\n\nexport function addXToNode<N extends (Node & LayerPosition), G extends GroupPosition>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { x: number },\n    fullWidth: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let fullWidth = width(element);\n            element.elements.forEach(layer => {\n                addXToNode(layer, accumulator, fullWidth);\n            });\n            return;\n        }\n        case \"layer\": {\n            accumulator.x = MARGIN_SIDE + (fullWidth - width(element)) / 2;\n            element.elements.forEach(group => {\n                addXToNode(group, accumulator, fullWidth);\n            });\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n\n            accumulator.x += GROUP_MARGIN_SIDE;\n            element.elements.forEach(node => {\n                addXToNode(node, accumulator, fullWidth);\n            });\n            accumulator.x += GROUP_MARGIN_SIDE;\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n            accumulator.x += ELEMENT_WIDTH * (element.size || 1) + HORIZONTAL_SPACING;\n            return;\n        }\n    }\n}","export function ascending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o1) - property(o2);\n}\n\nexport function descending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o2) - property(o1);\n}\n\nexport function and<T>(...sortFunctions: ((o1: T, o2: T) => number)[]) {\n    return (o1: T, o2: T) => {\n        let i = 0;\n        while (true) {\n            if (i === sortFunctions.length) return 0;\n            let result = sortFunctions[i](o1, o2);\n            if (result !== 0) return result;\n            i++;\n        }\n    }\n}","export type X = {\n    x: number\n}\nexport type Y = {\n    y: number\n}\nexport type Height = {\n    height: number\n}\nexport type LayerDimensions = {\n    belowLayerY: number\n}\nexport type LayerIndex = {\n    layerIndex: number\n}\nexport type IndexAndKey = {\n    key: string\n    index: number\n}\nexport type LayerPosition = LayerIndex & IndexAndKey\nexport type GroupPosition = LayerIndex & IndexAndKey\ntype Symbols = \"component\"\nexport type Node = {\n    kind: 'node'\n    name: string\n    symbol?: Symbols\n    size?: number\n    isPlaceholder?: boolean\n}\nexport type Edge<T> = {\n    from: T\n    to: T\n}\nexport type EdgeIndex = {\n    edgeIndex: number\n}\nexport type ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\nexport type NumberOfEdges = {\n    upperSideEdges: number\n    lowerSideEdges: number\n}\nexport type Group<N, G> = {\n    kind: 'group'\n    name: string\n    elements: ((Group<N, G> & G) | N)[]\n}\nexport type Layer<N, G> = {\n    kind: 'layer'\n    elements: ((Group<N, G> & G) | N)[]\n}\nexport type Stack<N, G> = {\n    kind: 'stack'\n    elements: Layer<N, G>[]\n}\nexport type Graph<N, E, G> = {\n    stack: Stack<N, G>\n    edges: (Edge<N> & E)[]\n}\n\nfunction fromIsUpper<T extends LayerPosition>(edge: Edge<T>) {\n    if (edge.from.layerIndex === edge.to.layerIndex) {\n        return edge.from.index <= edge.to.index;\n    }\n    return edge.from.layerIndex < edge.to.layerIndex;\n}\n\nexport function getUpperNode<T extends LayerPosition>(edge: Edge<T>): T {\n    return fromIsUpper(edge) ? edge.from : edge.to;\n}\n\nexport function getLowerNode<T extends LayerPosition>(edge: Edge<T>): T {\n    return fromIsUpper(edge) ? edge.to : edge.from;\n}","import {and, ascending, descending} from \"./sorting\";\nimport {Edge, EdgeIndex, getLowerNode, getUpperNode, Graph, LayerPosition, X} from \"./graphModel\";\n\nexport function addLayerPositionToEdgeG<N extends LayerPosition & X, E, G>(graph: Graph<N, E, G>):\n    Graph<N, E & LayerPosition, G> {\n    addLayerPositionToEdge(graph.edges);\n    return graph as unknown as Graph<N, E & LayerPosition, G>;\n}\n\nexport function addLayerPositionToEdge(edges: Edge<LayerPosition & X>[]) {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerPosition & X> & EdgeIndex)[]>();\n\n    edges\n        .map((edge, index) => Object.assign(edge, {edgeIndex: index}))\n        .forEach(edge => {\n            let key = getUpperNode(edge).layerIndex;\n            let edges = groupedByLayerIndex.get(key) || [];\n            edges.push(edge);\n            groupedByLayerIndex.set(key, edges);\n        });\n\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\n}\n\nfunction addLayerPositionToEdgeForLayer(edges: (Edge<LayerPosition & X> & EdgeIndex)[]) {\n    let groupedByUpperNode = new Map<string, (Edge<LayerPosition & X> & EdgeIndex)[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperNode(edge).key;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerNode(edge).layerIndex === getUpperNode(edge).layerIndex);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerNode(edge).index <= getUpperNode(edge).index);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerNode(edge).index > getUpperNode(edge).index);\n        let otherLayer = edges.filter(edge => getLowerNode(edge).layerIndex !== getUpperNode(edge).layerIndex);\n        let otherLayerBefore = otherLayer.filter(edge => getLowerNode(edge).x <= getUpperNode(edge).x);\n        let otherLayerAfter = otherLayer.filter(edge => getLowerNode(edge).x > getUpperNode(edge).x);\n\n        sameLayerBefore.sort(and(ascending(edge => getLowerNode(edge).index), ascending(edge => edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(edge => getLowerNode(edge).index), ascending(edge => edge.edgeIndex)));\n        otherLayerAfter.sort(and(descending(edge => getLowerNode(edge).index), descending(edge => edge.edgeIndex)));\n        sameLayerAfter.sort(and(ascending(edge => getLowerNode(edge).index), ascending(edge => edge.edgeIndex)));\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<LayerPosition>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let layerIndex = getUpperNode(edge).layerIndex;\n            let index = indexOffset + indexInArray;\n            Object.assign(edge, {\n                key: nodeKey + \"_\" + beforeOrAfter + \"_\" + index,\n                index: index,\n                layerIndex: layerIndex\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}","import {EDGE_SPACING} from \"./styling\";\nimport {Edge, getUpperNode, LayerPosition} from \"./graphModel\";\n\nexport function heightOfEdges(edges: (Edge<LayerPosition> & LayerPosition)[], numberOfLayers: number): number[] {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerPosition> & LayerPosition)[]>();\n    edges.forEach(edge => {\n        let layerIndex = getUpperNode(edge).layerIndex;\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\n        grouped.push(edge);\n        groupedByLayerIndex.set(layerIndex, grouped);\n    });\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\n    return layerIndices.map(layerIndex => {\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\n        return Math.max(...edgeIndices) * EDGE_SPACING;\n    })\n}","import {heightOfEdges} from \"./heightOfEdges\";\nimport {ELEMENT_HEIGHT, GROUP_MARGIN_BOTTOM, GROUP_MARGIN_TOP, MARGIN_TOP, VERTICAL_SPACING} from \"./styling\";\nimport {Graph, Group, Height, Layer, LayerDimensions, LayerPosition, Node, Stack, Y} from \"./graphModel\";\n\nexport function heightOfNodes(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(heightOfNodes)\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodes)) + VERTICAL_SPACING;\n        case \"group\": {\n            return GROUP_MARGIN_TOP + Math.max(...element.elements.map(heightOfNodes)) + GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nfunction groupNestingLevel(element: Node | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"layer\":\n            return Math.max(...element.elements.map(groupNestingLevel));\n        case \"group\":\n            return Math.max(...element.elements.map(groupNestingLevel)) + 1;\n        case \"node\":\n            return 0;\n    }\n}\n\nexport function addYToNodeG<N extends (Node & LayerPosition), E extends LayerPosition, G>(\n    graph: Graph<N, E, G>\n): Graph<N & Y & LayerDimensions, E, G & Y & Height> {\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n    addYToNode(graph.stack, {y: 0, nodeY: 0, groupHeight: 0, belowLayerY: 0}, heightOfAllEdges);\n    return graph as unknown as Graph<N & Y & LayerDimensions, E, G & Y & Height>;\n}\n\nexport function addYToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { y: number, nodeY: number, groupHeight: number, belowLayerY: number },\n    heightOfEdges: number[],\n    additionalEdgeHeight: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            accumulator.y += MARGIN_TOP;\n            element.elements.forEach((layer, layerIndex) => {\n                let additionalEdgeHeight = heightOfEdges.slice(0, layerIndex).reduce((sum, add) => sum + add, 0);\n                addYToNode(layer, accumulator, heightOfEdges, additionalEdgeHeight);\n            });\n            return;\n        }\n        case \"layer\": {\n            accumulator.nodeY = accumulator.y + groupNestingLevel(element) * GROUP_MARGIN_TOP;\n            accumulator.groupHeight = groupNestingLevel(element) * (GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM) + ELEMENT_HEIGHT;\n            accumulator.belowLayerY = accumulator.y + heightOfNodes(element) + additionalEdgeHeight;\n            element.elements.forEach(group => {\n                addYToNode(group, accumulator, heightOfEdges, additionalEdgeHeight);\n            });\n            accumulator.y += heightOfNodes(element);\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                y: accumulator.y + additionalEdgeHeight,\n                height: accumulator.groupHeight\n            });\n\n            accumulator.y += GROUP_MARGIN_TOP;\n            accumulator.groupHeight -= GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            element.elements.forEach(node => {\n                addYToNode(node, accumulator, heightOfEdges, additionalEdgeHeight);\n            });\n            accumulator.y -= GROUP_MARGIN_TOP;\n            accumulator.groupHeight += GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                y: accumulator.nodeY + additionalEdgeHeight,\n                belowLayerY: accumulator.belowLayerY\n            });\n            return;\n        }\n    }\n}","import {ascending, descending} from \"./sorting\";\nimport {ConnectionIndex, Edge, Graph, LayerPosition, NumberOfEdges} from \"./graphModel\";\n\nexport function addConnectionIndexAndNumberOfEdgesG<N extends LayerPosition, E, G>(graph: Graph<N, E, G>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex, G> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    return graph as unknown as Graph<N & NumberOfEdges, E & ConnectionIndex, G>;\n}\n\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerPosition>[]) {\n    type NodeSide = {\n        node: LayerPosition\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        reverseNode: LayerPosition\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(firstNode: LayerPosition, secondNode: LayerPosition, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.key + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index <= node.index);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index >= node.index);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\n\n        before.sort(descending(e => e.reverseNode.index));\n        otherLayer.sort(ascending(e => e.reverseNode.index));\n        after.sort(descending(e => e.reverseNode.index));\n\n        let all = before.concat(otherLayer).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allNodes<N extends Node, G, E>(element: Stack<N, G> | Group<N, G> | N): N[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allNodes);\n        case \"group\":\n            return element.elements.flatMap(allNodes);\n        case \"node\":\n            return [element];\n    }\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allGroups<N extends Node, G, E>(element: Stack<N, G> | (Group<N, G> & G) | N): (Group<N, G> & G)[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allGroups);\n        case \"group\":\n            return [element].concat(element.elements.flatMap(allGroups));\n        case \"node\":\n            return [];\n    }\n}","import React from \"react\";\nimport {STROKE_WIDTH} from \"./styling\";\n\nexport type Symbol = {\n    x: number\n    y: number\n    width: number\n    symbolKey: string\n}\nexport const ComponentSymbol: React.FC<Symbol> = symbol => {\n    const symbolHeightRelative = 1.1;\n    const barWidthRelative = 0.4;\n    const barHeightRelative = 0.15;\n    const barWidthAbsolute = symbol.width * barWidthRelative;\n    const barHeightAbsolute = symbol.width * barHeightRelative;\n    return (\n        <g key={symbol.symbolKey}>\n            <rect\n                x={symbol.x + barWidthAbsolute / 2} y={symbol.y}\n                width={symbol.width * (1 - barWidthRelative / 2)} height={symbol.width * symbolHeightRelative}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute * 3}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, STROKE_WIDTH, SYMBOL_SPACING, SYMBOL_WIDTH, TEXT_PADDING} from \"./styling\";\nimport {LayerPosition, Node, X, Y} from \"./graphModel\";\nimport {ComponentSymbol} from \"./Symbols\";\n\nexport const NodeShape: React.FC<Node & LayerPosition & X & Y> = node => {\n    if (node.isPlaceholder) return null;\n\n    let isComponent = node.symbol === \"component\";\n    return (\n        <g key={node.key}>\n            <rect data-testid=\"rect\"\n                  x={node.x} y={node.y}\n                  width={width(node)} height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n\n            <text x={node.x + TEXT_PADDING} y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + node.key}>\n                <rect\n                    x={node.x + TEXT_PADDING} y={node.y}\n                    width={width(node) - 2 * TEXT_PADDING - (isComponent ? (SYMBOL_WIDTH + SYMBOL_SPACING) : 0)}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n\n            {isComponent ?\n                <ComponentSymbol\n                    symbolKey={node.key + \"CS\"}\n                    x={node.x + width(node) - SYMBOL_WIDTH - SYMBOL_SPACING}\n                    y={node.y + SYMBOL_SPACING}\n                    width={SYMBOL_WIDTH}/>\n                : \"\"}\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, GROUP_MARGIN_SIDE, STROKE_WIDTH} from \"./styling\";\nimport {Group, GroupPosition, Height, Node, X, Y} from \"./graphModel\";\n\nexport const GroupShape: React.FC<Group<Node, unknown> & GroupPosition & X & Y & Height> = group => {\n    return (\n        <g key={group.key}>\n            <rect\n                x={group.x} y={group.y}\n                width={width(group)}\n                height={group.height}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text x={group.x + GROUP_MARGIN_SIDE} y={group.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + group.key + \")\"}>{group.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + group.key}>\n                <rect\n                    x={group.x + GROUP_MARGIN_SIDE} y={group.y}\n                    width={width(group) - 2 * GROUP_MARGIN_SIDE}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {EDGE_SPACING, STROKE_WIDTH, VERTICAL_SPACING} from \"./styling\";\nimport {\n    ConnectionIndex,\n    Edge,\n    getUpperNode,\n    LayerDimensions,\n    LayerPosition,\n    Node,\n    NumberOfEdges, X,\n    Y\n} from \"./graphModel\";\nimport {heightOfNodes} from \"./addYToNode\";\n\nfunction edgeEndCoordinates<N extends Node & LayerPosition & X & Y & NumberOfEdges>(\n    node: N, edgeIndex: number, otherNode: N\n) {\n    let onLowerSide = node.layerIndex <= otherNode.layerIndex;\n    let nodeCenteringOffset = (width(node) - ((onLowerSide ? node.lowerSideEdges : node.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    return {\n        x: node.x + nodeCenteringOffset + edgeIndex * EDGE_SPACING,\n        y: node.y + (onLowerSide ? heightOfNodes(node) : 0)\n    };\n}\n\nexport const EdgeShape: React.FC<Edge<Node & LayerPosition & X & Y & LayerDimensions & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\n    let fromNode = edgeEndCoordinates(edge.from, edge.fromIndex, edge.to);\n    let upperNodeEdgesY = getUpperNode(edge).belowLayerY - VERTICAL_SPACING / 2 + edge.index * EDGE_SPACING;\n    let toNode = edgeEndCoordinates(edge.to, edge.toIndex, edge.from);\n    return (\n        <path key={edge.key} d={\n            \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n            \"L \" + fromNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + toNode.y\n        }\n              stroke=\"black\"\n              strokeWidth={STROKE_WIDTH}\n              fill=\"none\"\n        />\n    );\n};","import {Graph, Group, Layer, LayerIndex, Node, Stack} from \"./graphModel\";\n\nexport function addLayerIndexToNodeG<N extends Node, E, G>(graph: Graph<N, E, G>):\n    Graph<N & LayerIndex, E, G & LayerIndex> {\n    addLayerIndexToNode(graph.stack);\n    return graph as unknown as Graph<N & LayerIndex, E, G & LayerIndex>;\n}\n\nexport function addLayerIndexToNode<N extends Node, G>(\n    element: N | Group<N, G> | Layer<N, G> | Stack<N, G>,\n    layerIndex: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach((groups, layerIndex) => {\n                addLayerIndexToNode(groups, layerIndex);\n            });\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => {\n                addLayerIndexToNode(group, layerIndex);\n            });\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n\n            element.elements.forEach(node => {\n                addLayerIndexToNode(node, layerIndex);\n            });\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n            return;\n        }\n    }\n}","import {Graph, Layer, LayerIndex, Node} from \"./graphModel\";\n\nexport function insertPlaceholdersInMultilayerEdges(graph: Graph<Node & LayerIndex, unknown, LayerIndex>): Graph<Node & LayerIndex, unknown, LayerIndex> {\n    return {\n        stack: graph.stack,\n        edges: graph.edges\n            .flatMap(edge => {\n                if (Math.abs(edge.from.layerIndex - edge.to.layerIndex) <= 1) return edge;\n\n                let from = Math.min(edge.from.layerIndex, edge.to.layerIndex);\n                let to = Math.max(edge.from.layerIndex, edge.to.layerIndex);\n                let newEdges = [];\n                let last = edge.from.layerIndex < edge.to.layerIndex ? edge.from : edge.to;\n                let end = edge.from.layerIndex >= edge.to.layerIndex ? edge.from : edge.to;\n                for (let i = from + 1; i < to; i++) {\n                    let placeholder: Node & LayerIndex = {\n                        kind: \"node\",\n                        name: \"\",\n                        size: 0.01,\n                        isPlaceholder: true,\n                        layerIndex: i\n                    };\n                    let layer: Layer<Node & LayerIndex, LayerIndex> = graph.stack.elements[i];\n                    layer.elements.splice(0, 0, placeholder);\n                    newEdges.push({from: last, to: placeholder});\n                    last = placeholder;\n                }\n                newEdges.push({from: last, to: end});\n                return newEdges;\n            })\n    };\n}","import React from \"react\";\nimport {addIndexAndKeyToNodeG} from \"./addIndexAndKeyToNode\";\nimport {addXToNodeG} from \"./addXToNode\";\nimport {addLayerPositionToEdgeG} from \"./addLayerPositionToEdge\";\nimport {addYToNodeG, heightOfNodes} from \"./addYToNode\";\nimport {addConnectionIndexAndNumberOfEdgesG} from \"./addConnectionIndexAndNumberOfEdges\";\nimport {allNodes} from \"./allNodes\";\nimport {allGroups} from \"./allGroups\";\nimport {heightOfEdges} from \"./heightOfEdges\";\nimport {NodeShape} from \"./NodeShape\";\nimport {GroupShape} from \"./GroupShape\";\nimport {EdgeShape} from \"./EdgeShape\";\nimport {width} from \"./width\";\nimport {MARGIN_SIDE, MARGIN_TOP} from \"./styling\";\nimport {Graph, Node} from \"./graphModel\";\nimport {addLayerIndexToNodeG} from \"./addLayerIndexToNode\";\nimport {insertPlaceholdersInMultilayerEdges} from \"./insertPlaceholdersInMultilayerEdges\";\n\nexport const Diagram: React.FC<Graph<Node, unknown, unknown>> = graph => {\n    return [graph]\n        .map(addLayerIndexToNodeG)\n        .map(insertPlaceholdersInMultilayerEdges)\n        .map(addIndexAndKeyToNodeG)\n        .map(addXToNodeG)\n        .map(addLayerPositionToEdgeG)\n        .map(addYToNodeG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(graph => {\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n            let overallWidth = width(graph.stack) + 2 * MARGIN_SIDE;\n            let height = heightOfNodes(graph.stack) + heightOfAllEdges.reduce((sum, add) => sum + add) + 2 * MARGIN_TOP;\n\n            return (\n                <svg viewBox={\"0 0 \" + overallWidth + \" \" + height}>\n                    {allNodes(graph.stack).map(NodeShape)}\n                    {allGroups(graph.stack).map(GroupShape)}\n                    {graph.edges.map(EdgeShape)}\n                </svg>\n            );\n        })[0];\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import {Edge, Stack} from \"./graphModel\";\n\nexport type IndexPair = {\n    from: number[]\n    to: number[]\n}\n\nfunction indexToReference<N, G>(stack: Stack<N, G>, index: number[]): any {\n    // It is necessary to go through the array by index,\n    // because the array operations `every`, `map` and `flat` bypass empty array elements.\n    for (let i = 0; i < index.length; i++) {\n        if (index[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n    }\n\n    let element: any = stack;\n    index.forEach(i => {\n        if (element.elements[i] === undefined)\n            throw new Error(\"Indices must refer to a node that does exist. Index \" + i  + \" Array length \" + element.elements.length);\n        element = element.elements[i];\n    });\n    return element;\n}\n\nfunction indexPairToReference<N, G>(stack: Stack<N, G>, indexPair: IndexPair): Edge<N> {\n    return {\n        from: indexToReference(stack, indexPair.from),\n        to: indexToReference(stack, indexPair.to)\n    };\n}\n\nexport function indicesToReferences<N, G>(stack: Stack<N, G>, indexPairs: IndexPair[]): Edge<N>[] {\n    return indexPairs.map(indexPair => indexPairToReference(stack, indexPair));\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nfunction convertStringsToNodes(element: (string | Node | Group<string | Node, unknown>)): Node | Group<Node, unknown> {\n    if (typeof element === 'string') {\n        return {\n            kind: 'node',\n            name: element\n        }\n    } else if (\"elements\" in element) {\n        // It is necessary to go through the array by index,\n        // because the array operations `every`, `map` and `flat` bypass empty array elements.\n        for (let i = 0; i < element.elements.length; i++) {\n            if (element.elements[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n        }\n        return {\n            kind: 'group',\n            name: element.name,\n            elements: element.elements.map(convertStringsToNodes)\n        }\n    } else {\n        return Object.assign(element, {\n            kind: 'node'\n        });\n    }\n}\n\nexport function stringsToNodes(strings: (string | Node | Group<string | Node, unknown>)[][]): Stack<Node, unknown> {\n    return {\n        kind: 'stack',\n        elements: strings.map(layer => {\n            return {\n                kind: 'layer',\n                elements: layer.map(convertStringsToNodes)\n            }\n        })\n    };\n}"],"sourceRoot":""}