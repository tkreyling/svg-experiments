{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["MARGIN_TOP","MARGIN_SIDE","ELEMENT_WIDTH","ELEMENT_HEIGHT","GROUP_MARGIN_TOP","GROUP_MARGIN_BOTTOM","GROUP_MARGIN_SIDE","HORIZONTAL_SPACING","VERTICAL_SPACING","TEXT_PADDING","EDGE_SPACING","widthOfLayers","layers","Math","max","map","widthOfElements","groups","n","group","nodes","length","reduce","sum","add","heightOfNodes","fromIsUpper","edge","from","layerIndex","to","index","getUpperNode","getLowerNode","heightOfEdges","edges","numberOfLayers","groupedByLayerIndex","Map","forEach","grouped","get","push","set","Array","keys","edgeIndices","addLayerPositionToNodeG","graph","addLayerPositionToNode","fullWidth","addLayerPositionToNodeForLayer","layerOffset","resultGroups","resultGroup","Object","assign","element","resultElement","key","relativePosition","addCoordinatesToNodeG","heightOfAllEdges","layout","elements","additionalEdgeHeight","slice","layoutHorizontally","offsetToCenter","groupIndex","x","y","addLayerPositionToEdgeG","addLayerPositionToEdge","values","addLayerPositionToEdgeForLayer","groupedByUpperNode","nodeKeys","sort","indexOffset","nodeKey","sameLayer","filter","sameLayerBefore","sameLayerAfter","otherLayer","otherLayerBefore","otherLayerAfter","edge1","edge2","before","concat","after","addLayerPosition","indexInArray","beforeOrAfter","addConnectionIndexAndNumberOfEdgesG","addConnectionIndexAndNumberOfEdges","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","node","edgeEnds","reverseNode","fromIndex","toIndex","edgeEnd","edgeEnd1","edgeEnd2","upperSideEdges","lowerSideEdges","addPositionToGroupG","addPositionToGroup","Rect","data-testid","width","height","fill","strokeWidth","stroke","clipPath","name","id","Group","contentWidth","Path","fromNodeOnLowerSide","fromNodeCenteringOffset","fromNodeX","fromNodeY","upperNodeEdgesY","toNodeOnLowerSide","toNodeCenteringOffset","toNodeX","toNodeY","d","stringsToNodes","strings","layer","graphAsString","initialGraph","eval","Diagram","viewBox","flat","flatMap","parseGraph","text","undefined","aNodeIsUndefined","elementIndex","every","e","message","App","useState","setGraph","errorMessage","setErrorMessage","className","cols","rows","onChange","changeEvent","result","target","value","defaultValue","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9d668739.chunk.js","sourcesContent":["import React, {useState} from 'react';\nimport './App.css';\n\nexport type Coordinates = {\n    x: number\n    y: number\n}\n\nexport type LayerPosition = {\n    key: string\n    index: number\n    relativePosition: number\n    layerIndex: number\n}\n\nexport type GroupPosition = {\n    key: string\n    index: number\n    layerIndex: number\n}\n\nexport type Node = {\n    name: string\n}\n\nexport type Edge<T> = {\n    from: T\n    to: T\n}\n\ntype ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\n\ntype NumberOfEdges = {\n    upperSideEdges: number\n    lowerSideEdges: number\n}\n\ntype Group<N> = {\n    name: string\n    nodes: N[]\n}\n\nexport type Layer<N, G> = (Group<N> & G)[]\n\ntype Graph<N, E, G> = {\n    layers: Layer<N, G>[]\n    edges: (Edge<N> & E)[]\n}\n\nexport const MARGIN_TOP = 5;\nexport const MARGIN_SIDE = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const GROUP_MARGIN_TOP = 30;\nexport const GROUP_MARGIN_BOTTOM = 10;\nexport const GROUP_MARGIN_SIDE = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const TEXT_PADDING = 5;\nexport const EDGE_SPACING = 10;\n\nexport function widthOfLayers(layers: Layer<any, any>[]) {\n    return Math.max(...layers.map(widthOfElements));\n}\n\nexport function widthOfElements(groups: Layer<any, any>) {\n    const n = groups\n        .map(group => group.nodes.length)\n        .reduce((sum, add) => sum + add, 0);\n    if (n === 0) return 0;\n    return groups.length * GROUP_MARGIN_SIDE * 2 + n * ELEMENT_WIDTH + (n - 1) * HORIZONTAL_SPACING;\n}\n\nfunction heightOfNodes(layers: Layer<any, any>[]) {\n    let n = layers.length;\n    return n * ELEMENT_HEIGHT + n * VERTICAL_SPACING + n * GROUP_MARGIN_TOP + n * GROUP_MARGIN_BOTTOM;\n}\n\nfunction fromIsUpper<T extends LayerPosition>(edge: Edge<T>) {\n    if (edge.from.layerIndex === edge.to.layerIndex) {\n        return edge.from.index <= edge.to.index;\n    }\n    return edge.from.layerIndex < edge.to.layerIndex;\n}\n\nfunction getUpperNode<T extends LayerPosition>(edge: Edge<T>): T {\n    return fromIsUpper(edge) ? edge.from : edge.to;\n}\n\nfunction getLowerNode<T extends LayerPosition>(edge: Edge<T>): T {\n    return fromIsUpper(edge) ? edge.to : edge.from;\n}\n\nexport function heightOfEdges(edges: (Edge<LayerPosition> & LayerPosition)[], numberOfLayers: number): number[] {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerPosition> & LayerPosition)[]>();\n    edges.forEach(edge => {\n        let layerIndex = getUpperNode(edge).layerIndex;\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\n        grouped.push(edge);\n        groupedByLayerIndex.set(layerIndex, grouped);\n    });\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\n    return layerIndices.map(layerIndex => {\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\n        return Math.max(...edgeIndices) * EDGE_SPACING;\n    })\n}\n\nfunction addLayerPositionToNodeG<N, E, G>(graph: Graph<N, E, G>): Graph<N & LayerPosition, E, G> {\n    return {\n        layers: addLayerPositionToNode(graph.layers),\n        edges: graph.edges as unknown as (Edge<N & LayerPosition> & E)[]\n    }\n}\n\nexport function addLayerPositionToNode<N, G>(layers: Layer<N, G>[]): Layer<N & LayerPosition, G>[] {\n    let fullWidth = Math.max(...layers.map(groups => {\n        return groups\n            .map(group => group.nodes.length)\n            .reduce((sum, add) => sum + add, 0);\n    }));\n\n    return layers.map((groups, layerIndex) =>\n        addLayerPositionToNodeForLayer(groups, fullWidth, layerIndex)\n    );\n}\n\nfunction addLayerPositionToNodeForLayer<N, G>(groups: Layer<N, G>, fullWidth: number, layerIndex: number):\n    Layer<N & LayerPosition, G> {\n    let layerWidth = groups\n        .map(group => group.nodes.length)\n        .reduce((sum, add) => sum + add, 0);\n    let layerOffset = (fullWidth - layerWidth) / 2;\n\n    let resultGroups: Layer<N & LayerPosition, G> = [];\n    let index = 0;\n    groups.forEach(group => {\n        let resultGroup = Object.assign(group, {\n            nodes: group.nodes.map(element => {\n                let resultElement = Object.assign(element, {\n                    key: layerIndex + \"_\" + index,\n                    index: index,\n                    relativePosition: layerOffset + index,\n                    layerIndex: layerIndex\n                });\n                index++;\n                return resultElement;\n            })\n        });\n        resultGroups.push(resultGroup);\n    });\n    return resultGroups;\n}\n\nfunction addCoordinatesToNodeG<N extends LayerPosition, E extends LayerPosition, G>(graph: Graph<N, E, G>):\n    Graph<N & Coordinates, E, G> {\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.layers.length);\n    return {\n        layers: layout(graph.layers, heightOfAllEdges),\n        edges: graph.edges as unknown as (Edge<N & Coordinates> & E)[]\n    }\n}\n\nexport function layout<N, G>(layers: Layer<N & LayerPosition, G>[], heightOfEdges: number[]):\n    Layer<N & LayerPosition & Coordinates, G>[] {\n    let fullWidth = widthOfLayers(layers);\n    return layers.map((elements, layerIndex) => {\n        let additionalEdgeHeight = heightOfEdges.slice(0, layerIndex).reduce((sum, add) => sum + add, 0);\n        return layoutHorizontally(elements, fullWidth, additionalEdgeHeight)\n    });\n}\n\nexport function layoutHorizontally<N, G>(groups: Layer<N & LayerPosition, G>, fullWidth: number, additionalEdgeHeight: number):\n    Layer<N & LayerPosition & Coordinates, G> {\n    let offsetToCenter = (fullWidth - widthOfElements(groups)) / 2;\n    return groups.map((group, groupIndex) => {\n        return Object.assign(group, {\n            nodes: group.nodes.map(element =>\n                Object.assign(element, {\n                    x: MARGIN_SIDE + GROUP_MARGIN_SIDE + groupIndex * 2 * GROUP_MARGIN_SIDE + element.index * (ELEMENT_WIDTH + HORIZONTAL_SPACING) + offsetToCenter,\n                    y: MARGIN_TOP + GROUP_MARGIN_TOP + element.layerIndex * (ELEMENT_HEIGHT + VERTICAL_SPACING + GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM) + additionalEdgeHeight\n                }))\n        });\n    });\n}\n\nfunction addLayerPositionToEdgeG<N extends LayerPosition, E, G>(graph: Graph<N, E, G>):\n    Graph<N, E & LayerPosition, G> {\n    addLayerPositionToEdge(graph.edges);\n    return {\n        layers: graph.layers,\n        edges: graph.edges as unknown as (Edge<N> & E & LayerPosition)[]\n    }\n}\n\nexport function addLayerPositionToEdge(edges: Edge<LayerPosition>[]) {\n    let groupedByLayerIndex = new Map<number, Edge<LayerPosition>[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperNode(edge).layerIndex;\n        let edges = groupedByLayerIndex.get(key) || [];\n        edges.push(edge);\n        groupedByLayerIndex.set(key, edges);\n    });\n\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\n}\n\nfunction addLayerPositionToEdgeForLayer(edges: Edge<LayerPosition>[]) {\n    let groupedByUpperNode = new Map<string, Edge<LayerPosition>[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperNode(edge).key;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerNode(edge).layerIndex === getUpperNode(edge).layerIndex);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerNode(edge).index <= getUpperNode(edge).index);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerNode(edge).index > getUpperNode(edge).index);\n        let otherLayer = edges.filter(edge => getLowerNode(edge).layerIndex !== getUpperNode(edge).layerIndex);\n        let otherLayerBefore = otherLayer.filter(edge => getLowerNode(edge).relativePosition <= getUpperNode(edge).relativePosition);\n        let otherLayerAfter = otherLayer.filter(edge => getLowerNode(edge).relativePosition > getUpperNode(edge).relativePosition);\n\n        sameLayerBefore.sort((edge1, edge2) =>  getLowerNode(edge1).index - getLowerNode(edge2).index);\n        otherLayerBefore.sort((edge1, edge2) =>  getLowerNode(edge1).index - getLowerNode(edge2).index);\n        otherLayerAfter.sort((edge1, edge2) =>  getLowerNode(edge2).index - getLowerNode(edge1).index);\n        sameLayerAfter.sort((edge1, edge2) =>  getLowerNode(edge1).index - getLowerNode(edge2).index);\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<LayerPosition>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let layerIndex = getUpperNode(edge).layerIndex;\n            let index = indexOffset + indexInArray;\n            Object.assign(edge, {\n                key: nodeKey + \"_\" + beforeOrAfter + \"_\" + index,\n                index: index,\n                layerIndex: layerIndex\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}\n\nfunction addConnectionIndexAndNumberOfEdgesG<N extends LayerPosition, E, G>(graph: Graph<N, E, G>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex, G> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    return {\n        layers: graph.layers as unknown as Layer<N & NumberOfEdges, G>[],\n        edges: graph.edges as unknown as (Edge<N & NumberOfEdges> & E & ConnectionIndex)[]\n    }\n}\n\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerPosition>[]) {\n    type NodeSide = {\n        node: LayerPosition\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        reverseNode: LayerPosition\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(firstNode: LayerPosition, secondNode: LayerPosition, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.key + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge.to, edge.from, index=> Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index <= node.index);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.index >= node.index);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\n\n        before.sort((edgeEnd1, edgeEnd2) => edgeEnd2.reverseNode.index - edgeEnd1.reverseNode.index);\n        otherLayer.sort((edgeEnd1, edgeEnd2) => edgeEnd1.reverseNode.index - edgeEnd2.reverseNode.index);\n        after.sort((edgeEnd1, edgeEnd2) => edgeEnd2.reverseNode.index - edgeEnd1.reverseNode.index);\n\n        let all = before.concat(otherLayer).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}\n\nfunction addPositionToGroupG<N, E, G>(graph: Graph<N, E, G>): Graph<N, E, G & GroupPosition> {\n    return {\n        layers: addPositionToGroup(graph.layers),\n        edges: graph.edges\n    }\n}\n\nexport function addPositionToGroup<N, G>(layers: Layer<N, G>[]): Layer<N, G & GroupPosition>[] {\n    return layers.map((groups, layerIndex) =>\n        groups.map((group, groupIndex) =>\n            Object.assign(group, {\n                key: \"G_\" + layerIndex + \"_\" + groupIndex,\n                index: groupIndex,\n                layerIndex: layerIndex\n            }))\n    );\n}\n\nexport const Rect: React.FC<Node & LayerPosition & Coordinates> = node => {\n    return (\n        <g key={node.key}>\n            <rect data-testid=\"rect\"\n                  x={node.x} y={node.y}\n                  width={ELEMENT_WIDTH} height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={1} stroke=\"black\"/>\n\n            <text x={node.x + TEXT_PADDING } y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + node.key}>\n                <rect x={node.x + TEXT_PADDING} y={node.y} width={ELEMENT_WIDTH - 2 * TEXT_PADDING} height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};\n\nconst Group: React.FC<Group<Coordinates> & GroupPosition> = group => {\n    let firstNode = group.nodes[0];\n    let n = group.nodes.length;\n\n    let x = firstNode.x - GROUP_MARGIN_SIDE;\n    let y = firstNode.y - GROUP_MARGIN_TOP;\n    let contentWidth = n * ELEMENT_WIDTH + (n - 1) * HORIZONTAL_SPACING;\n    return (\n        <g key={group.key}>\n            <rect\n                x={x} y={y}\n                width={contentWidth + 2 * GROUP_MARGIN_SIDE}\n                height={ELEMENT_HEIGHT + GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM}\n                fill=\"none\" strokeWidth={1} stroke=\"grey\"/>\n\n            <text x={x + GROUP_MARGIN_SIDE} y={y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + group.key + \")\"}>{group.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + group.key}>\n                <rect\n                    x={x + GROUP_MARGIN_SIDE} y={y}\n                    width={contentWidth}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};\n\nexport const Path: React.FC<Edge<LayerPosition & Coordinates & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\n    let fromNodeOnLowerSide = edge.from.layerIndex <= edge.to.layerIndex;\n    let fromNodeCenteringOffset = (ELEMENT_WIDTH - ((fromNodeOnLowerSide ? edge.from.lowerSideEdges : edge.from.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    let fromNodeX = edge.from.x + fromNodeCenteringOffset + edge.fromIndex * EDGE_SPACING;\n    let fromNodeY = edge.from.y + (fromNodeOnLowerSide ? ELEMENT_HEIGHT : 0);\n    let upperNodeEdgesY = getUpperNode(edge).y + ELEMENT_HEIGHT + VERTICAL_SPACING / 2 + GROUP_MARGIN_BOTTOM + edge.index * EDGE_SPACING;\n    let toNodeOnLowerSide = edge.from.layerIndex >= edge.to.layerIndex;\n    let toNodeCenteringOffset = (ELEMENT_WIDTH - ((toNodeOnLowerSide ? edge.to.lowerSideEdges : edge.to.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    let toNodeX = edge.to.x + toNodeCenteringOffset + edge.toIndex * EDGE_SPACING;\n    let toNodeY = edge.to.y + (toNodeOnLowerSide ? ELEMENT_HEIGHT : 0);\n    return (\n        <path key={edge.key} d={\n            \"M \" + fromNodeX + \" \" + fromNodeY + \" \" +\n            \"L \" + fromNodeX + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNodeX + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNodeX + \" \" + toNodeY\n        }\n              stroke=\"black\"\n              strokeWidth={1}\n              fill=\"none\"\n        />\n    );\n};\n\nexport function stringsToNodes(strings: Group<string>[][]): Layer<Node, unknown>[] {\n    return strings.map(layer => {\n        return layer.map(group => {\n            return {\n                name: group.name,\n                nodes: group.nodes.map(name => {\n                    return {name: name}\n                })\n            }\n        });\n    });\n}\n\nlet graphAsString =\n`var layers = stringsToNodes([\n    [\n        {name: \"group 1\", nodes: [\"element 11\", \"element 2\", \"an element with long text\"]},\n        {name: \"group 2\", nodes: [\"element 4\"]}\n    ],\n    [\n        {name: \"group 3\", nodes: [\"element 1\", \"element 2\"]},\n        {name: \"group 4\", nodes: [\"element 3\"]}\n    ],\n    [\n        {name: \"group 5\", nodes: [\"element 1\", \"element 2\", \"element 3\", \"element with changed name\", \"element 5\"]}\n    ]\n]);\n\nvar edges = [\n    {from: layers[0][0].nodes[1], to: layers[1][0].nodes[0]},\n    {from: layers[0][0].nodes[2], to: layers[1][1].nodes[0]},\n    {from: layers[0][1].nodes[0], to: layers[1][0].nodes[1]},\n    {from: layers[1][1].nodes[0], to: layers[2][0].nodes[2]},\n    {from: layers[1][0].nodes[1], to: layers[2][0].nodes[4]},\n    {from: layers[1][0].nodes[1], to: layers[2][0].nodes[3]},\n    {from: layers[1][0].nodes[1], to: layers[2][0].nodes[2]},\n    {from: layers[1][0].nodes[1], to: layers[2][0].nodes[1]},\n    {from: layers[1][0].nodes[1], to: layers[2][0].nodes[0]},\n    {from: layers[2][0].nodes[0], to: layers[1][0].nodes[0]},\n    {from: layers[2][0].nodes[1], to: layers[1][0].nodes[0]},\n    {from: layers[2][0].nodes[0], to: layers[2][0].nodes[3]},\n    {from: layers[2][0].nodes[1], to: layers[2][0].nodes[3]},\n    {from: layers[2][0].nodes[4], to: layers[2][0].nodes[3]},\n    {from: layers[0][0].nodes[0], to: layers[0][0].nodes[2]},\n    {from: layers[0][0].nodes[0], to: layers[0][0].nodes[1]},\n    {from: layers[0][0].nodes[0], to: layers[1][0].nodes[0]},\n    {from: layers[0][0].nodes[0], to: layers[1][0].nodes[0]},\n    {from: layers[1][0].nodes[1], to: layers[1][0].nodes[0]},\n    {from: layers[1][0].nodes[1], to: layers[1][1].nodes[0]}\n];\n\nvar graph = {\n    layers: layers,\n    edges: edges\n};\n\ngraph\n`;\n\n// eslint-disable-next-line\nconst initialGraph: Graph<Node, unknown, unknown> = eval(graphAsString);\n\nexport const Diagram: React.FC<Graph<Node, unknown, unknown>> = graph => {\n    return [graph]\n        .map(addLayerPositionToNodeG)\n        .map(addLayerPositionToEdgeG)\n        .map(addCoordinatesToNodeG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(addPositionToGroupG)\n        .map(graph => {\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.layers.length);\n            let width = widthOfLayers(graph.layers) + 2 * MARGIN_SIDE;\n            let height = heightOfNodes(graph.layers) + heightOfAllEdges.reduce((sum, add) => sum + add) + 2 * MARGIN_TOP;\n\n            return (\n                <svg viewBox={\"0 0 \" + width + \" \" + height}>\n                    {graph.layers.flat().flatMap(group => group.nodes).map(Rect)}\n                    {graph.layers.flat().map(Group)}\n                    {graph.edges.map(Path)}\n                </svg>\n            );\n        })[0];\n};\n\nexport function parseGraph(text: string): Graph<Node, unknown, unknown> | string {\n    try {\n// eslint-disable-next-line\n        let graph = eval(text);\n\n        if (graph === undefined) return \"Script is not returning a graph object!\";\n\n        if (graph.layers === undefined) return \"Property layers is missing in graph object!\";\n        if (graph.edges === undefined) return \"Property edges is missing in graph object!\";\n\n        let layers: Node[][][] = graph.layers;\n        let aNodeIsUndefined = false;\n        // It is necessary to go through the nested arrays by index,\n        // because the array operations `every`, `map` and `flat` bypass empty array elements.\n        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n            let groups = layers[layerIndex];\n            for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n                let elements = groups[groupIndex];\n                for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\n                    if (elements[elementIndex] === undefined) aNodeIsUndefined = true;\n                }\n            }\n        }\n        if (aNodeIsUndefined) return \"Every node must be defined!\";\n\n        if (!graph.edges.every((edge: Edge<Node>) => edge.from !== undefined))\n            return \"Property from must be defined on every edge!\";\n        if (!graph.edges.every((edge: Edge<Node>) => edge.to !== undefined))\n            return \"Property to must be defined on every edge!\";\n\n        return graph;\n    } catch (e) {\n        return e.message;\n    }\n}\n\nconst App: React.FC = () => {\n    const [graph, setGraph] = useState(initialGraph);\n    const [errorMessage, setErrorMessage] = useState(\"\");\n\n    function handleChange(changeEvent: React.ChangeEvent<HTMLTextAreaElement>) {\n        let result = parseGraph(changeEvent.target.value);\n        if (typeof result === 'string') {\n            setErrorMessage(result);\n        } else {\n            setGraph(result);\n            setErrorMessage(\"\");\n        }\n    }\n\n    return (\n        <div id=\"parent\" className=\"App\">\n            <div id=\"graph\">\n                <Diagram layers={graph.layers} edges={graph.edges}/>\n            </div>\n            <div>\n                <textarea cols={100} rows={45} onChange={handleChange} defaultValue={graphAsString}/>\n                <p className=\"error-message\">{errorMessage}</p>\n            </div>\n        </div>\n    );\n};\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}