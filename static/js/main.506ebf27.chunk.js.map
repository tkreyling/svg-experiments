{"version":3,"sources":["v1/sorting.tsx","v1/Editor.tsx","v1/parseGraph.tsx","v1/Architecture.tsx","v2/NodeShape.tsx","v2/styling.tsx","v2/assertNever.tsx","v2/elementsLayout/OffsetElementsY.tsx","v2/elementsLayout/OffsetElementsX.tsx","v2/elementsLayout/EmbeddedElementsX.tsx","v2/ContainerShape.tsx","v2/elementsLayout/BorderIndexMaxX.tsx","v2/elementsLayout/BorderIndexLeft.tsx","v2/elementsLayout/BorderIndexRight.tsx","v2/elementsLayout/BorderIndexTop.tsx","v2/elementsLayout/BorderIndexBottom.tsx","v2/sumOfPreviousRows.tsx","v2/getMostBottomOffsetElementsY.tsx","v2/elementsLayout/BorderIndexMaxBottom.tsx","v2/elementsLayout/BorderIndexMaxTop.tsx","v2/elementsLayout/EmbeddedElementsY.tsx","v2/Diagram.tsx","v2/Sample.tsx","App.tsx","serviceWorker.ts","index.tsx","v1/indicesToReferences.tsx","v1/stringsToNodes.tsx","v1/styling.tsx","v1/width.tsx","v1/addXToNode.tsx","v1/graphModel.tsx","v1/addLayerPositionToEdge.tsx","v1/heightOfEdges.tsx","v1/addYToNode.tsx","v1/addConnectionIndexAndNumberOfEdges.tsx","v1/allNodes.tsx","v1/allGroups.tsx","v1/Symbols.tsx","v1/NodeShape.tsx","v1/GroupShape.tsx","v1/EdgeShape.tsx","v1/addLayerIndexToNode.tsx","v1/insertPlaceholdersInMultilayerEdges.tsx","v1/addKeyToNode.tsx","v1/Diagram.tsx"],"names":["ascending","property","o1","o2","descending","and","sortFunctions","i","length","result","graphAsString","indicesToReferences","indicesToReferencesImport","stringsToNodes","stringsToNodesImport","initialGraph","eval","Editor","useState","graph","setGraph","errorMessage","setErrorMessage","id","className","stack","edges","cols","rows","onChange","changeEvent","parseGraph","target","value","defaultValue","text","undefined","every","edge","from","to","e","message","component","name","kind","symbol","size","Architecture","productAPI","stockAPI","productServiceDB","productImporter","stockImporter","categoryImporter","campaignImporter","elements","NodeShape","node","key","offsetElementsY","offsetElementsX","x","borderIndexMaxX","y","borderIndexMaxPreviousTop","borderIndexMaxTop","borderIndexTop","borderIndexMaxPreviousBottom","width","height","fill","strokeWidth","stroke","assertNever","Error","addOffsetElementsYG","element","addOffsetElementsY","accumulator","Object","assign","maxOffsetYElements","oldOffsetYElements","forEach","nestedElement","Math","max","addOffsetElementsXG","addOffsetElementsX","maxOffsetXElements","oldOffsetXElements","addEmbeddedElementsXG","addEmbeddedElementsX","embeddedElementsX","embeddedXElements","map","reduce","sum","add","ContainerShape","container","borderIndexLeft","borderIndexRight","embeddedElementsY","embeddedBorderIndexMaxTop","embeddedBorderIndexMaxBottom","borderIndexBottom","borderIndexMaxBottom","addBorderIndexMaxXG","addBorderIndexMaxX","determineBorderIndexMaxX","addBorderIndexLeftG","addBorderIndexLeft","leftBorderIndex","border","addBorderIndexRightG","addBorderIndexRight","borderIndices","borderIndex","addBorderIndexTopG","addBorderIndexTop","addBorderIndexBottomG","addBorderIndexBottom","sumOfPreviousRows","Map","sumOfPrevious","Array","entries","sort","entry","set","getMostBottomOffsetElementsY","addBorderIndexMaxBottomG","determineBorderIndexMaxBottom","addBorderIndexMaxBottom","current","sums","get","calculateEmbeddedBorders","addition","embeddedBorders","addBorderIndexMaxTopG","determineBorderIndexMaxTop","addBorderIndexMaxTop","addEmbeddedElementsYG","addEmbeddedElementsY","allNodes","flatMap","allContainers","concat","Diagram","props","viewBox","filter","c","Sample","App","exact","path","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","indexToReference","index","indexPairs","indexPair","indexPairToReference","convertStringsToNodes","strings","layer","MARGIN_TOP","MARGIN_SIDE","ELEMENT_WIDTH","ELEMENT_HEIGHT","GROUP_MARGIN_TOP","GROUP_MARGIN_BOTTOM","GROUP_MARGIN_SIDE","HORIZONTAL_SPACING","VERTICAL_SPACING","EDGE_SPACING","addXToNodeG","addXToNode","fullWidth","oldX","group","fromIsUpperLeft","layerIndex","getUpperLeftNode","getLowerRightNode","addLayerPositionToEdgeG","groupedByLayerIndex","edgeIndex","push","values","addLayerPositionToEdgeForLayer","addLayerPositionToEdge","groupedByUpperNode","nodeKeys","keys","indexOffset","nodeKey","sameLayer","sameLayerBefore","sameLayerAfter","otherLayer","otherLayerBefore","otherLayerAfter","before","after","addLayerPosition","indexInArray","beforeOrAfter","heightOfEdges","numberOfLayers","grouped","edgeIndices","heightOfNodes","isPlaceholder","heightOfNodesOnlyFirstLayerOfNestedStacks","groupNestingLevel","addYToNodeG","heightOfAllEdges","addYToNode","old","nodeY","belowLayerY","groupHeight","additionalEdgeHeight","slice","addConnectionIndexAndNumberOfEdgesG","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","edgeEnds","reverseNode","fromIndex","toIndex","edgeEnd","upperSideEdges","lowerSideEdges","addConnectionIndexAndNumberOfEdges","allGroups","ComponentSymbol","barWidthAbsolute","barHeightAbsolute","symbolKey","isComponent","data-testid","clipPath","SYMBOL_WIDTH","GroupShape","edgeEndCoordinates","otherNode","onLowerSide","nodeCenteringOffset","EdgeShape","fromNode","upperNodeEdgesY","toNode","d","addLayerIndexToNodeG","addLayerIndexToNode","insertPlaceholdersInMultilayerEdges","abs","min","newEdges","last","end","placeholder","splice","addKeyToNodeG","addKeyToNode","globalCounter","groups","overallWidth"],"mappings":"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","file":"static/js/main.506ebf27.chunk.js","sourcesContent":["export function ascending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o1) - property(o2);\n}\n\nexport function descending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o2) - property(o1);\n}\n\nexport function and<T>(...sortFunctions: ((o1: T, o2: T) => number)[]) {\n    return (o1: T, o2: T) => {\n        let i = 0;\n        while (true) {\n            if (i === sortFunctions.length) return 0;\n            let result = sortFunctions[i](o1, o2);\n            if (result !== 0) return result;\n            i++;\n        }\n    }\n}","import {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\nimport React, {useState} from \"react\";\nimport {parseGraph} from \"./parseGraph\";\nimport {Diagram} from \"./Diagram\";\nimport {Graph, Node} from \"./graphModel\";\nimport './Editor.css';\n\nlet graphAsString =\n    `var stack = stringsToNodes([\n    [\n        {name: \"group 1\", elements: [\n            \"element 11\", \n            {name: \"element 2\", size: 1.5, symbol: \"component\"}, \n            {name: \"an element with long text\", symbol: \"component\"}            \n        ]},\n        {name: \"group 2\", elements: [\"element 4\"]}\n    ],\n    [\n        {name: \"group 3\", elements: [\"element 1\", \"element 2\"]},\n        {name: \"group 4\", elements: [\n            {name: \"group 6\", elements: [\"element 4\"]}, \n            {name: \"placeholder\", size: 0.3, isPlaceholder: true}, \n            \"element 3\"\n        ]},\n        \"node on top level\", \n        {name: \"an element with long text\", symbol: \"component\"}     \n    ],\n    [\n        {name: \"group 5\", elements: [\n            \"element 1\", \"element 2\", \"element 3\", \n            {name: \"element with changed name\", size: 1.5}, \n            {name: \"element 5\", size: 0.7}]}\n    ]\n]);\n\nvar edgeIndices = [\n    {from: [0, 0, 0],    to: [1, 3]},\n    {from: [0, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 2],    to: [1, 1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 0, 1]},\n    {from: [1, 1, 0, 0], to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 4]},\n    {from: [1, 0, 1],    to: [2, 0, 3]},\n    {from: [1, 0, 1],    to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [2, 0, 0]},\n    {from: [2, 0, 0],    to: [1, 0, 0]},\n    {from: [2, 0, 1],    to: [1, 0, 0]},\n    {from: [2, 0, 0],    to: [2, 0, 3]},\n    {from: [2, 0, 1],    to: [2, 0, 3]},\n    {from: [2, 0, 4],    to: [2, 0, 3]},\n    {from: [0, 0, 0],    to: [0, 0, 2]},\n    {from: [0, 0, 0],    to: [0, 0, 1]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 1, 1]},\n    {from: [1, 1, 1],    to: [2, 0, 2]},\n    {from: [0, 1, 0],    to: [1, 1, 2]},\n    {from: [1, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [1, 1, 0, 0]}\n];\nvar edges = indicesToReferences(stack, edgeIndices);\n\nvar graph = {\n    stack: stack,\n    edges: edges\n};\n\ngraph\n`;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\n// eslint-disable-next-line no-eval\nconst initialGraph: Graph<Node, unknown, unknown> = eval(graphAsString);\n\nexport const Editor: React.FC = () => {\n    const [graph, setGraph] = useState(initialGraph);\n    const [errorMessage, setErrorMessage] = useState(\"\");\n\n    function handleChange(changeEvent: React.ChangeEvent<HTMLTextAreaElement>) {\n        let result = parseGraph(changeEvent.target.value);\n        if (typeof result === 'string') {\n            setErrorMessage(result);\n        } else {\n            setGraph(result);\n            setErrorMessage(\"\");\n        }\n    }\n\n    return (\n        <div id=\"parent\" className=\"App\">\n            <div id=\"graph\">\n                <Diagram stack={graph.stack} edges={graph.edges}/>\n            </div>\n            <div>\n                <textarea cols={100} rows={45} onChange={handleChange} defaultValue={graphAsString}/>\n                <p className=\"error-message\">{errorMessage}</p>\n            </div>\n        </div>\n    );\n};","import {Edge, Graph, Node} from \"./graphModel\";\nimport {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\nexport function parseGraph(text: string): Graph<Node, unknown, unknown> | string {\n    try {\n// eslint-disable-next-line\n        let graph: Graph<Node, unknown, unknown> = eval(text);\n\n        if (graph === undefined) return \"Script is not returning a graph object!\";\n\n        if (graph.stack === undefined) return \"Property layers is missing in graph object!\";\n        if (graph.edges === undefined) return \"Property edges is missing in graph object!\";\n\n        if (!graph.edges.every((edge: Edge<Node>) => edge.from !== undefined))\n            return \"Property from must be defined on every edge!\";\n        if (!graph.edges.every((edge: Edge<Node>) => edge.to !== undefined))\n            return \"Property to must be defined on every edge!\";\n\n        return graph;\n    } catch (e) {\n        return e.message;\n    }\n}","import React from \"react\";\nimport {Diagram} from \"./Diagram\";\nimport {Edge, Node, Stack} from \"./graphModel\";\n\nfunction component(name: string): Node {\n    return {\n        kind: \"node\", name: name, symbol: \"component\", size: 1.2\n    }\n}\n\nexport const Architecture: React.FC = () => {\n    let productAPI = component(\"Product API\");\n    let stockAPI = component(\"Stock API\");\n    let productServiceDB = component(\"Product Service DB\");\n    let productImporter = component(\"Product Importer\");\n    let stockImporter = component(\"Stock Importer\");\n    let categoryImporter = component(\"Category Importer\");\n    let campaignImporter = component(\"Campaign Importer\");\n\n    let stack: Stack<Node, unknown> = {\n        kind: \"stack\",\n        elements: [\n            {\n                kind: \"layer\",\n                elements: [productAPI, stockAPI]\n            },\n            {\n                kind: \"layer\",\n                elements: [productServiceDB]\n            },\n            {\n                kind: \"layer\",\n                elements: [productImporter, stockImporter, categoryImporter, campaignImporter]\n            }\n        ]\n    };\n\n    let edges: Edge<Node>[] = [\n        {from: productAPI, to: productServiceDB},\n        {from: stockAPI, to: productServiceDB},\n        {from: productServiceDB, to: productImporter},\n        {from: productServiceDB, to: stockImporter},\n        {from: productServiceDB, to: categoryImporter},\n        {from: productServiceDB, to: campaignImporter}\n    ];\n\n    return (\n        <Diagram stack={stack} edges={edges}/>\n    );\n};","import React from \"react\";\nimport {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    BORDER_SPACING_X,\n    HORIZONTAL_SPACING,\n    STROKE_WIDTH,\n    VERTICAL_SPACING, BORDER_SPACING_TOP, BORDER_SPACING_BOTTOM\n} from \"./styling\";\nimport {BorderIndexMaxX} from \"./elementsLayout/BorderIndexMaxX\";\nimport {BorderIndexMaxPreviousTop, BorderIndexMaxTop} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexTop} from \"./elementsLayout/BorderIndexTop\";\nimport {BorderIndexMaxPreviousBottom} from \"./elementsLayout/BorderIndexMaxBottom\";\n\ntype Props = OffsetElementsX & BorderIndexMaxX &\n    OffsetElementsY &\n    BorderIndexMaxPreviousTop & BorderIndexMaxTop & BorderIndexTop &\n    BorderIndexMaxPreviousBottom;\n\nexport const NodeShape: React.FC<Props> = node => {\n    return (\n        <g key={node.offsetElementsY + \"_\" + node.offsetElementsX}>\n            <rect x={node.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING) +\n            node.borderIndexMaxX * (node.offsetElementsX * 2 + 1) * BORDER_SPACING_X}\n                  y={node.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                  + (node.borderIndexMaxPreviousTop + node.borderIndexMaxTop - node.borderIndexTop) * BORDER_SPACING_TOP\n                  + node.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM}\n                  width={ELEMENT_WIDTH}\n                  height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n        </g>\n    );\n};","export const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const BORDER_SPACING_X = 10;\nexport const BORDER_SPACING_TOP = 30;\nexport const BORDER_SPACING_BOTTOM = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const STROKE_WIDTH = 0.5;","export function assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type OffsetElementsY = { offsetElementsY: number };\n\nexport function addOffsetElementsYG<N>(element: Element<N>): Element<N & OffsetElementsY> {\n    addOffsetElementsY(element);\n    return element as Element<N & OffsetElementsY>;\n}\n\nexport function addOffsetElementsY(element: Element<unknown>, accumulator = {offsetElementsY: 0}) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            accumulator.offsetElementsY++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            let maxOffsetYElements = 0;\n            let oldOffsetYElements = accumulator.offsetElementsY;\n            element.elements.forEach(nestedElement => {\n                addOffsetElementsY(nestedElement, accumulator);\n                maxOffsetYElements = Math.max(maxOffsetYElements, accumulator.offsetElementsY);\n                accumulator.offsetElementsY = oldOffsetYElements;\n            });\n            accumulator.offsetElementsY = maxOffsetYElements;\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            element.elements.forEach(nestedElement => addOffsetElementsY(nestedElement, accumulator));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type OffsetElementsX = { offsetElementsX: number };\n\nexport function addOffsetElementsXG<N>(element: Element<N>): Element<N & OffsetElementsX> {\n    addOffsetElementsX(element);\n    return element as Element<N & OffsetElementsX>;\n}\n\nexport function addOffsetElementsX(element: Element<unknown>, accumulator = {offsetElementsX: 0}) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            accumulator.offsetElementsX++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            element.elements.forEach(nestedElement => addOffsetElementsX(nestedElement, accumulator));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            let maxOffsetXElements = 0;\n            let oldOffsetXElements = accumulator.offsetElementsX;\n            element.elements.forEach(nestedElement => {\n                addOffsetElementsX(nestedElement, accumulator);\n                maxOffsetXElements = Math.max(maxOffsetXElements, accumulator.offsetElementsX);\n                accumulator.offsetElementsX = oldOffsetXElements;\n            });\n            accumulator.offsetElementsX = maxOffsetXElements;\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type EmbeddedElementsX = { embeddedElementsX: number };\n\nexport function addEmbeddedElementsXG<N>(element: Element<N>): Element<N & EmbeddedElementsX> {\n    addEmbeddedElementsX(element);\n    return element as Element<N & EmbeddedElementsX>;\n}\n\nexport function addEmbeddedElementsX(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, EmbeddedElementsX>(element, {\n                embeddedElementsX: 1\n            });\n            return 1;\n        }\n        case \"row\": {\n            let embeddedXElements =\n                element.elements.map(addEmbeddedElementsX).reduce((sum, add) => sum + add, 0);\n\n            Object.assign<Row<unknown>, EmbeddedElementsX>(element, {\n                embeddedElementsX: embeddedXElements\n            });\n            return embeddedXElements;\n        }\n        case \"column\": {\n            let embeddedXElements =\n                Math.max(...element.elements.map(addEmbeddedElementsX), 0);\n\n            Object.assign<Column<unknown>, EmbeddedElementsX>(element, {\n                embeddedElementsX: embeddedXElements\n            });\n            return embeddedXElements;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import React from \"react\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    BORDER_SPACING_X,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    HORIZONTAL_SPACING,\n    STROKE_WIDTH,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {Container} from \"./newGraphModel\";\nimport {EmbeddedElementsX} from \"./elementsLayout/EmbeddedElementsX\";\nimport {BorderIndexMaxX} from \"./elementsLayout/BorderIndexMaxX\";\nimport {BorderIndexLeft} from \"./elementsLayout/BorderIndexLeft\";\nimport {BorderIndexTop} from \"./elementsLayout/BorderIndexTop\";\nimport {BorderIndexMaxBottom, BorderIndexMaxPreviousBottom, EmbeddedBorderIndexMaxBottom} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {BorderIndexMaxPreviousTop, BorderIndexMaxTop, EmbeddedBorderIndexMaxTop} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexBottom} from \"./elementsLayout/BorderIndexBottom\";\nimport {BorderIndexRight} from \"./elementsLayout/BorderIndexRight\";\nimport {EmbeddedElementsY} from \"./elementsLayout/EmbeddedElementsY\";\n\ntype Props = Container<\n    OffsetElementsX & EmbeddedElementsX &\n    OffsetElementsY & EmbeddedElementsY &\n    BorderIndexLeft & BorderIndexRight & BorderIndexMaxX &\n    BorderIndexTop & BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop &\n    BorderIndexBottom & BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>;\n\nexport const ContainerShape: React.FC<Props> = container => {\n    return (\n        <g key={\"G_\" + container.offsetElementsY + \"_\" + container.offsetElementsX}>\n            <rect\n                x={container.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING) +\n                (container.borderIndexMaxX * (container.offsetElementsX * 2 + 1)  - container.borderIndexLeft) * BORDER_SPACING_X}\n                y={container.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                + (container.borderIndexMaxPreviousTop + container.borderIndexMaxTop - container.borderIndexTop) * BORDER_SPACING_TOP\n                + container.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM}\n                width={container.embeddedElementsX * ELEMENT_WIDTH + (container.embeddedElementsX - 1) * HORIZONTAL_SPACING +\n                ((container.embeddedElementsX - 1) * container.borderIndexMaxX * 2 + container.borderIndexLeft + container.borderIndexRight) * BORDER_SPACING_X}\n                height={container.embeddedElementsY * ELEMENT_HEIGHT +\n                (container.embeddedElementsY - 1) * VERTICAL_SPACING +\n                container.borderIndexTop * BORDER_SPACING_TOP +\n                container.embeddedBorderIndexMaxTop * BORDER_SPACING_TOP +\n                container.embeddedBorderIndexMaxBottom * BORDER_SPACING_BOTTOM +\n                container.borderIndexBottom * BORDER_SPACING_BOTTOM}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text\n                x={container.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING) +\n                (container.borderIndexMaxX * (container.offsetElementsX * 2 + 1) - container.borderIndexLeft) * BORDER_SPACING_X}\n                y={container.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                + (container.borderIndexMaxPreviousTop + container.borderIndexMaxTop - container.borderIndexTop) * BORDER_SPACING_TOP\n                + container.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n                + 15}\n                fill=\"black\">{\n                container.embeddedElementsY + \"__\" +\n                container.borderIndexMaxPreviousTop + \"/\" + container.borderIndexTop + \"/\" + container.borderIndexMaxTop + \"__\" +\n                container.borderIndexMaxPreviousBottom + \"/\" + container.borderIndexBottom + \"/\" + container.borderIndexMaxBottom}\n            </text>\n        </g>\n    );\n};","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexLeft} from \"./BorderIndexLeft\";\nimport {BorderIndexRight} from \"./BorderIndexRight\";\n\nexport type BorderIndexMaxX = { borderIndexMaxX: number };\n\nexport function addBorderIndexMaxXG<N extends BorderIndexLeft & BorderIndexRight>(\n    element: Element<N>\n): Element<N & BorderIndexMaxX> {\n    let maxEmbeddedXBorders = determineBorderIndexMaxX(element);\n    addBorderIndexMaxX(element, maxEmbeddedXBorders);\n    return element as Element<N & BorderIndexMaxX>;\n}\n\nfunction determineBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>): number {\n    switch (element.kind) {\n        case \"node\": return 0;\n        case \"row\": return Math.max(\n            ...element.elements.map(determineBorderIndexMaxX),\n            element.borderIndexLeft,\n            element.borderIndexRight\n        );\n        case \"column\": return Math.max(\n            ...element.elements.map(determineBorderIndexMaxX),\n            element.borderIndexLeft,\n            element.borderIndexRight\n        );\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nexport function addBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>, borderIndexMaxX: number) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxX(nestedElement, borderIndexMaxX));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxX(nestedElement, borderIndexMaxX));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexLeft = { borderIndexLeft: number };\n\nexport function addBorderIndexLeftG<N>(element: Element<N>): Element<N & BorderIndexLeft> {\n    addBorderIndexLeft(element);\n    return element as Element<N & BorderIndexLeft>;\n}\n\nexport function addBorderIndexLeft(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexLeft>(element, {\n                borderIndexLeft: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let leftBorderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexLeft) :  [0];\n            let leftBorderIndex = leftBorderIndices[0] + (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexLeft>(element, {\n                borderIndexLeft: leftBorderIndex\n            });\n            return leftBorderIndex;\n        }\n        case \"column\": {\n            let leftBorderIndex =\n                Math.max(...element.elements.map(addBorderIndexLeft), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexLeft>(element, {\n                borderIndexLeft: leftBorderIndex\n            });\n            return leftBorderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexRight = { borderIndexRight: number };\n\nexport function addBorderIndexRightG<N>(element: Element<N>): Element<N & BorderIndexRight> {\n    addBorderIndexRight(element);\n    return element as Element<N & BorderIndexRight>;\n}\n\nexport function addBorderIndexRight(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexRight>(element, {\n                borderIndexRight: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexRight) :  [0];\n            let borderIndex = borderIndices[borderIndices.length - 1] + (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexRight>(element, {\n                borderIndexRight: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexRight), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexRight>(element, {\n                borderIndexRight: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexTop = { borderIndexTop: number };\n\nexport function addBorderIndexTopG<N>(element: Element<N>): Element<N & BorderIndexTop> {\n    addBorderIndexTop(element);\n    return element as Element<N & BorderIndexTop>;\n}\n\nexport function addBorderIndexTop(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexTop>(element, {\n                borderIndexTop: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexTop), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexTop>(element, {\n                borderIndexTop: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexTop) :  [0];\n            let borderIndex = borderIndices[0] + (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexTop>(element, {\n                borderIndexTop: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexBottom = { borderIndexBottom: number };\n\nexport function addBorderIndexBottomG<N>(element: Element<N>): Element<N & BorderIndexBottom> {\n    addBorderIndexBottom(element);\n    return element as Element<N & BorderIndexBottom>;\n}\n\nexport function addBorderIndexBottom(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexBottom>(element, {\n                borderIndexBottom: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexBottom), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexBottom>(element, {\n                borderIndexBottom: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexBottom) :  [0];\n            let borderIndex = borderIndices[borderIndices.length - 1] + (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexBottom>(element, {\n                borderIndexBottom: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {ascending} from \"../v1/sorting\";\n\nexport function sumOfPreviousRows(max: Map<number, number>): Map<number, number> {\n    let result = new Map<number, number>();\n\n    let sumOfPrevious = 0;\n    Array.from(max.entries()).sort(ascending(entry => entry[0])).forEach(entry => {\n        result.set(entry[0], sumOfPrevious);\n        sumOfPrevious += entry[1];\n    });\n\n    return result;\n}","import {Element} from \"./newGraphModel\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\n\nexport function getMostBottomOffsetElementsY(element: Element<OffsetElementsY>): number {\n    switch (element.kind) {\n        case \"node\":\n            return element.offsetElementsY;\n        case \"row\":\n        case \"column\":\n            return Math.max(...element.elements.map(getMostBottomOffsetElementsY), element.offsetElementsY);\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexBottom} from \"./BorderIndexBottom\";\nimport {OffsetElementsY} from \"./OffsetElementsY\";\nimport {sumOfPreviousRows} from \"../sumOfPreviousRows\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type BorderIndexMaxBottom = { borderIndexMaxBottom: number };\nexport type BorderIndexMaxPreviousBottom = { borderIndexMaxPreviousBottom: number };\nexport type EmbeddedBorderIndexMaxBottom = { embeddedBorderIndexMaxBottom: number };\n\nexport function addBorderIndexMaxBottomG<N extends OffsetElementsY & BorderIndexBottom>(\n    element: Element<N>\n): Element<N & BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom> {\n    let max = determineBorderIndexMaxBottom(element);\n    let sums = sumOfPreviousRows(max);\n    addBorderIndexMaxBottom(element, max, sums);\n    return element as Element<N & BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>;\n}\n\nfunction determineBorderIndexMaxBottom(element: Element<OffsetElementsY & BorderIndexBottom>): Map<number, number> {\n    switch (element.kind) {\n        case \"node\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexBottom);\n            return map;\n        }\n        case \"row\":\n        case \"column\": {\n            let map = new Map<number, number>();\n            map.set(getMostBottomOffsetElementsY(element), element.borderIndexBottom);\n            return element.elements.map(determineBorderIndexMaxBottom).reduce((accumulator, addition) => {\n                Array.from(addition.entries()).forEach((entry) => {\n                    let max = Math.max(accumulator.get(entry[0]) || 0, entry[1]);\n                    accumulator.set(entry[0], max);\n                });\n                return accumulator;\n            }, map);\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction calculateEmbeddedBorders(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY;\n    let to = getMostBottomOffsetElementsY(element) - 1;\n    let embeddedBorders = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedBorders += current.get(i) || 0;\n    }\n    return embeddedBorders;\n}\n\nfunction addBorderIndexMaxBottom(\n    element: Element<OffsetElementsY & BorderIndexBottom>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(getMostBottomOffsetElementsY(element))!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxBottom(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(getMostBottomOffsetElementsY(element))!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxBottom(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexTop} from \"./BorderIndexTop\";\nimport {OffsetElementsY} from \"./OffsetElementsY\";\nimport {sumOfPreviousRows} from \"../sumOfPreviousRows\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type BorderIndexMaxTop = { borderIndexMaxTop: number };\nexport type BorderIndexMaxPreviousTop = { borderIndexMaxPreviousTop: number };\nexport type EmbeddedBorderIndexMaxTop = { embeddedBorderIndexMaxTop: number };\n\nexport function addBorderIndexMaxTopG<N extends OffsetElementsY & BorderIndexTop>(\n    element: Element<N>\n): Element<N & BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop> {\n    let max = determineBorderIndexMaxTop(element);\n    let sums = sumOfPreviousRows(max);\n    addBorderIndexMaxTop(element, max, sums);\n    return element as Element<N & BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>;\n}\n\nfunction determineBorderIndexMaxTop(element: Element<OffsetElementsY & BorderIndexTop>): Map<number, number> {\n    switch (element.kind) {\n        case \"node\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexTop);\n            return map;\n        }\n        case \"row\":\n        case \"column\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexTop);\n            return element.elements.map(determineBorderIndexMaxTop).reduce((accumulator, addition) => {\n                Array.from(addition.entries()).forEach((entry) => {\n                    let max = Math.max(accumulator.get(entry[0]) || 0, entry[1]);\n                    accumulator.set(entry[0], max);\n                });\n                return accumulator;\n            }, map);\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction calculateEmbeddedBorders(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY + 1;\n    let to = getMostBottomOffsetElementsY(element);\n    let embeddedBorders = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedBorders += current.get(i) || 0;\n    }\n    return embeddedBorders;\n}\n\nfunction addBorderIndexMaxTop(\n    element: Element<OffsetElementsY & BorderIndexTop>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxTop(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxTop(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Node, Row} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type EmbeddedElementsY = { embeddedElementsY: number };\n\nexport function addEmbeddedElementsYG<N>(element: Element<N>): Element<N & EmbeddedElementsY> {\n    addEmbeddedElementsY(element);\n    return element as Element<N & EmbeddedElementsY>;\n}\n\nexport function addEmbeddedElementsY(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, EmbeddedElementsY>(element, {\n                embeddedElementsY: 1\n            });\n            return 1;\n        }\n        case \"row\": {\n            let embeddedElementsY =\n                Math.max(...element.elements.map(addEmbeddedElementsY), 0);\n\n            Object.assign<Row<unknown>, EmbeddedElementsY>(element, {\n                embeddedElementsY: embeddedElementsY\n            });\n            return embeddedElementsY;\n        }\n        case \"column\": {\n            let embeddedElementsY =\n                element.elements.map(addEmbeddedElementsY).reduce((sum, add) => sum + add, 0);\n\n            Object.assign<Column<unknown>, EmbeddedElementsY>(element, {\n                embeddedElementsY: embeddedElementsY\n            });\n            return embeddedElementsY;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import React from \"react\";\nimport {Container, Element, Node} from \"./newGraphModel\";\nimport {NodeShape} from \"./NodeShape\";\nimport {assertNever} from \"./assertNever\";\nimport {addOffsetElementsYG} from \"./elementsLayout/OffsetElementsY\";\nimport {addOffsetElementsXG} from \"./elementsLayout/OffsetElementsX\";\nimport {addEmbeddedElementsXG} from \"./elementsLayout/EmbeddedElementsX\";\nimport {ContainerShape} from \"./ContainerShape\";\nimport {addBorderIndexMaxXG} from \"./elementsLayout/BorderIndexMaxX\";\nimport {addBorderIndexLeftG} from \"./elementsLayout/BorderIndexLeft\";\nimport {addBorderIndexRightG} from \"./elementsLayout/BorderIndexRight\";\nimport {addBorderIndexTopG} from \"./elementsLayout/BorderIndexTop\";\nimport {addBorderIndexBottomG} from \"./elementsLayout/BorderIndexBottom\";\nimport {addBorderIndexMaxBottomG} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {addBorderIndexMaxTopG} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {addEmbeddedElementsYG} from \"./elementsLayout/EmbeddedElementsY\";\n\nfunction allNodes<N>(element: Element<N>): (Node & N)[] {\n    switch (element.kind) {\n        case \"node\": return [element];\n        case \"row\": return element.elements.flatMap(allNodes);\n        case \"column\": return element.elements.flatMap(allNodes);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction allContainers<N>(element: Element<N>): Container<N>[] {\n    switch (element.kind) {\n        case \"node\": return [];\n        case \"row\": return element.elements.flatMap(allContainers).concat(element);\n        case \"column\": return element.elements.flatMap(allContainers).concat(element);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nexport const Diagram: React.FC<{element: Element<unknown>}> = props => {\n    return [props.element]\n        .map(addOffsetElementsXG)\n        .map(addOffsetElementsYG)\n        .map(addBorderIndexLeftG)\n        .map(addBorderIndexRightG)\n        .map(addBorderIndexTopG)\n        .map(addBorderIndexBottomG)\n        .map(addBorderIndexMaxXG)\n        .map(addBorderIndexMaxTopG)\n        .map(addBorderIndexMaxBottomG)\n        .map(addEmbeddedElementsXG)\n        .map(addEmbeddedElementsYG)\n        .map(element => (\n            <svg viewBox={\"0 0 1200 600\"}>\n                {allNodes(element).map(NodeShape)}\n                {allContainers(element).filter(c => c.border).map(ContainerShape)}\n            </svg>\n        ))[0];\n};","import React from \"react\";\nimport {Element} from \"./newGraphModel\";\nimport {Diagram} from \"./Diagram\";\n\nexport const Sample: React.FC = () => {\n    let element: Element<unknown> = {\n        kind: \"column\", elements: [{\n            kind: \"row\", elements: [{\n                kind: \"column\", border: \"solid\", elements: [{\n                    kind: \"node\"\n                }, {\n                    kind: \"node\"\n                }]\n            }, {\n                kind: \"column\", border: \"solid\", elements: [{\n                    kind: \"row\", border: \"solid\", elements: [{\n                        kind: \"node\"\n                    }, {\n                        kind: \"node\"\n                    }]\n                }, {\n                    kind: \"node\"\n                }, {\n                    kind: \"node\"\n                }]\n            }]\n        }, {\n            kind: \"row\", elements: [{\n                kind: \"node\"\n            }, {\n                kind: \"node\"\n            }]\n        }, {\n            kind: \"row\", border: \"solid\", elements: [{\n                kind: \"row\", border: \"solid\", elements: [{\n                    kind: \"node\"\n                }, {\n                    kind: \"node\"\n                }]\n            }, {\n                kind: \"row\", border: \"solid\", elements: [{\n                    kind: \"node\"\n                }, {\n                    kind: \"node\"\n                }]\n            }]\n        }]\n    };\n    return (\n        <Diagram element={element}/>\n    );\n};","import React from 'react';\nimport {HashRouter as Router, Link, Route, Switch} from \"react-router-dom\";\nimport {Editor} from \"./v1/Editor\";\nimport {Architecture} from \"./v1/Architecture\";\nimport {Sample} from \"./v2/Sample\";\n\nconst App: React.FC = () => {\n    return (\n        <Router>\n            <div>\n                <ul>\n                    <li>\n                        <Link to=\"/\">Editor</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/architecture\">Sample Architecture</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/new-layouting\">New Layouting</Link>\n                    </li>\n                </ul>\n\n                <hr/>\n\n                <Switch>\n                    <Route exact path=\"/\">\n                        <Editor/>\n                    </Route>\n                    <Route path=\"/architecture\">\n                        <Architecture/>\n                    </Route>\n                    <Route path=\"/new-layouting\">\n                        <Sample/>\n                    </Route>\n                </Switch>\n            </div>\n        </Router>\n    );\n};\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import {Edge, Stack} from \"./graphModel\";\n\nexport type IndexPair = {\n    from: number[]\n    to: number[]\n}\n\nfunction indexToReference<N, G>(stack: Stack<N, G>, index: number[]): any {\n    // It is necessary to go through the array by index,\n    // because the array operations `every`, `map` and `flat` bypass empty array elements.\n    for (let i = 0; i < index.length; i++) {\n        if (index[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n    }\n\n    let element: any = stack;\n    index.forEach(i => {\n        if (element.elements[i] === undefined)\n            throw new Error(\"Indices must refer to a node that does exist. Index \" + i  + \" Array length \" + element.elements.length);\n        element = element.elements[i];\n    });\n    return element;\n}\n\nfunction indexPairToReference<N, G>(stack: Stack<N, G>, indexPair: IndexPair): Edge<N> {\n    return {\n        from: indexToReference(stack, indexPair.from),\n        to: indexToReference(stack, indexPair.to)\n    };\n}\n\nexport function indicesToReferences<N, G>(stack: Stack<N, G>, indexPairs: IndexPair[]): Edge<N>[] {\n    return indexPairs.map(indexPair => indexPairToReference(stack, indexPair));\n}","import {Group, Layer, Node, Stack} from \"./graphModel\";\n\nfunction convertStringsToNodes(\n    element: string | Node | Group<string | Node, unknown> | Layer<Node, unknown> | Stack<Node, unknown>\n): Node | Group<Node, unknown> | Layer<Node, unknown> | Stack<Node, unknown> {\n    if (typeof element === 'string') {\n        return {\n            kind: 'node',\n            name: element\n        }\n    } else if (\"elements\" in element) {\n        // It is necessary to go through the array by index,\n        // because the array operations `every`, `map` and `flat` bypass empty array elements.\n        for (let i = 0; i < element.elements.length; i++) {\n            if (element.elements[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n        }\n        if (\"name\" in element) {\n            return {\n                kind: \"group\",\n                name: element.name,\n                elements: element.elements.map(convertStringsToNodes) as (Group<Node, unknown> | Node)[]\n            }\n        }\n        switch (element.kind) {\n            default:\n            case \"stack\":  {\n                return {\n                    kind: element.kind,\n                    elements: element.elements.map(convertStringsToNodes) as Layer<Node, unknown>[]\n                }\n            }\n            case \"layer\": {\n                return {\n                    kind: element.kind,\n                    elements: element.elements.map(convertStringsToNodes) as (Node | Group<Node, unknown> | Stack<Node, unknown>)[]\n                }\n            }\n        }\n    } else {\n        return Object.assign(element, {\n            kind: 'node'\n        });\n    }\n}\n\nexport function stringsToNodes(\n    strings: (string | Node | Group<string | Node, unknown> | Stack<Node, unknown>)[][]\n): Stack<Node, unknown> {\n    return {\n        kind: 'stack',\n        elements: strings.map(layer => {\n            return {\n                kind: 'layer',\n                elements: layer.map(convertStringsToNodes) as (Node | Group<Node, unknown> | Stack<Node, unknown>)[]\n            }\n        })\n    };\n}","export const MARGIN_TOP = 5;\nexport const MARGIN_SIDE = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const SYMBOL_WIDTH = 12;\nexport const SYMBOL_SPACING = 3;\nexport const GROUP_MARGIN_TOP = 30;\nexport const GROUP_MARGIN_BOTTOM = 10;\nexport const GROUP_MARGIN_SIDE = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const TEXT_PADDING = 5;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;","import {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING} from \"./styling\";\nimport {Group, Layer, Node, Stack} from \"./graphModel\";\n\nexport function width(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return Math.max(...element.elements.map(width));\n        case \"layer\":\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"group\": {\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0) + 2 * GROUP_MARGIN_SIDE;\n        }\n        case \"node\":\n            return ELEMENT_WIDTH * (element.size || 1);\n    }\n}","import {width} from \"./width\";\nimport {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING, MARGIN_SIDE} from \"./styling\";\nimport {Graph, Group, Layer, Node, Stack, X} from \"./graphModel\";\n\nexport function addXToNodeG<N extends Node, E, G>(\n    graph: Graph<N, E, G>\n): Graph<N & X, E, G & X> {\n    addXToNode(graph.stack, {x: MARGIN_SIDE});\n    return graph as unknown as Graph<N & X, E, G & X>;\n}\n\nexport function addXToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { x: number },\n    fullWidth: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let fullWidth = width(element);\n            element.elements.forEach(layer => {\n                addXToNode(layer, accumulator, fullWidth);\n            });\n            accumulator.x += fullWidth + HORIZONTAL_SPACING;\n            return;\n        }\n        case \"layer\": {\n            let oldX = accumulator.x;\n            accumulator.x = oldX + (fullWidth - width(element)) / 2;\n            element.elements.forEach(group => {\n                addXToNode(group, accumulator, fullWidth);\n            });\n            accumulator.x = oldX;\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n\n            accumulator.x += GROUP_MARGIN_SIDE;\n            element.elements.forEach(node => {\n                addXToNode(node, accumulator, fullWidth);\n            });\n            accumulator.x += GROUP_MARGIN_SIDE;\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n            accumulator.x += ELEMENT_WIDTH * (element.size || 1) + HORIZONTAL_SPACING;\n            return;\n        }\n    }\n}","export type X = {\n    x: number\n}\nexport type Y = {\n    y: number\n}\nexport type Height = {\n    height: number\n}\nexport type LayerDimensions = {\n    belowLayerY: number\n}\nexport type LayerIndex = {\n    layerIndex: number\n}\nexport type Index = {\n    index: number\n}\nexport type Key = {\n    key: string\n}\nexport type LayerPosition = LayerIndex & Index & Key\ntype Symbols = \"component\"\nexport type Node = {\n    kind: 'node'\n    name: string\n    symbol?: Symbols\n    size?: number\n    isPlaceholder?: boolean\n}\nexport type Edge<T> = {\n    from: T\n    to: T\n}\nexport type EdgeIndex = {\n    edgeIndex: number\n}\nexport type ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\nexport type NumberOfEdges = {\n    upperSideEdges: number\n    lowerSideEdges: number\n}\nexport type Group<N, G> = {\n    kind: 'group'\n    name: string\n    elements: ((Group<N, G> & G) | N)[]\n}\nexport type Layer<N, G> = {\n    kind: 'layer'\n    elements: ((Group<N, G> & G) | Stack<N, G> | N)[]\n}\nexport type Stack<N, G> = {\n    kind: 'stack'\n    elements: Layer<N, G>[]\n}\nexport type Graph<N, E, G> = {\n    stack: Stack<N, G>\n    edges: (Edge<N> & E)[]\n}\n\nfunction fromIsUpperLeft<T extends LayerIndex & X>(edge: Edge<T>) {\n    if (edge.from.layerIndex === edge.to.layerIndex) {\n        return edge.from.x <= edge.to.x;\n    }\n    return edge.from.layerIndex < edge.to.layerIndex;\n}\n\nexport function getUpperLeftNode<T extends LayerIndex & X>(edge: Edge<T>): T {\n    return fromIsUpperLeft(edge) ? edge.from : edge.to;\n}\n\nexport function getLowerRightNode<T extends LayerIndex & X>(edge: Edge<T>): T {\n    return fromIsUpperLeft(edge) ? edge.to : edge.from;\n}","import {and, ascending, descending} from \"./sorting\";\nimport {Edge, EdgeIndex, getLowerRightNode, getUpperLeftNode, Graph, Key, LayerIndex, LayerPosition, X} from \"./graphModel\";\n\nexport function addLayerPositionToEdgeG<N extends LayerIndex & X & Key, E, G>(graph: Graph<N, E, G>):\n    Graph<N, E & LayerPosition, G> {\n    addLayerPositionToEdge(graph.edges);\n    return graph as unknown as Graph<N, E & LayerPosition, G>;\n}\n\nexport function addLayerPositionToEdge(edges: Edge<LayerIndex & X & Key>[]) {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerIndex & X & Key> & EdgeIndex)[]>();\n\n    edges\n        .map((edge, index) => Object.assign(edge, {edgeIndex: index}))\n        .forEach(edge => {\n            let key = getUpperLeftNode(edge).layerIndex;\n            let edges = groupedByLayerIndex.get(key) || [];\n            edges.push(edge);\n            groupedByLayerIndex.set(key, edges);\n        });\n\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\n}\n\nfunction addLayerPositionToEdgeForLayer(edges: (Edge<LayerIndex & X & Key> & EdgeIndex)[]) {\n    let groupedByUpperNode = new Map<string, (Edge<LayerIndex & X & Key> & EdgeIndex)[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperLeftNode(edge).key;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerRightNode(edge).layerIndex === getUpperLeftNode(edge).layerIndex);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerRightNode(edge).x <= getUpperLeftNode(edge).x);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerRightNode(edge).x > getUpperLeftNode(edge).x);\n        let otherLayer = edges.filter(edge => getLowerRightNode(edge).layerIndex !== getUpperLeftNode(edge).layerIndex);\n        let otherLayerBefore = otherLayer.filter(edge => getLowerRightNode(edge).x <= getUpperLeftNode(edge).x);\n        let otherLayerAfter = otherLayer.filter(edge => getLowerRightNode(edge).x > getUpperLeftNode(edge).x);\n\n        sameLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n        otherLayerAfter.sort(and(descending(edge => getLowerRightNode(edge).x), descending(edge => edge.edgeIndex)));\n        sameLayerAfter.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<LayerIndex & X>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let layerIndex = getUpperLeftNode(edge).layerIndex;\n            let index = indexOffset + indexInArray;\n            Object.assign(edge, {\n                key: nodeKey + \"_\" + beforeOrAfter + \"_\" + index,\n                index: index,\n                layerIndex: layerIndex\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}","import {EDGE_SPACING} from \"./styling\";\nimport {Edge, getUpperLeftNode, LayerIndex, LayerPosition, X} from \"./graphModel\";\n\nexport function heightOfEdges(edges: (Edge<LayerIndex & X> & LayerPosition)[], numberOfLayers: number): number[] {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerIndex & X> & LayerPosition)[]>();\n    edges.forEach(edge => {\n        let layerIndex = getUpperLeftNode(edge).layerIndex;\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\n        grouped.push(edge);\n        groupedByLayerIndex.set(layerIndex, grouped);\n    });\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\n    return layerIndices.map(layerIndex => {\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\n        return Math.max(...edgeIndices) * EDGE_SPACING;\n    })\n}","import {heightOfEdges} from \"./heightOfEdges\";\nimport {\n    ELEMENT_HEIGHT,\n    GROUP_MARGIN_BOTTOM,\n    GROUP_MARGIN_TOP,\n    MARGIN_TOP,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {Graph, Group, Height, Layer, LayerDimensions, LayerIndex, LayerPosition, Node, Stack, X, Y} from \"./graphModel\";\n\nexport function heightOfNodes(\n    element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>\n): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(heightOfNodes)\n                .map((height, index) => height + (index > 0 ? VERTICAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodes));\n        case \"group\": {\n            return GROUP_MARGIN_TOP + Math.max(...element.elements.map(heightOfNodes)) + GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nexport function heightOfNodesOnlyFirstLayerOfNestedStacks(\n    element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>\n): number {\n    switch (element.kind) {\n        case \"stack\":\n            if (element.elements.length === 0) return 0;\n            return heightOfNodesOnlyFirstLayerOfNestedStacks(element.elements[0]);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodesOnlyFirstLayerOfNestedStacks));\n        case \"group\": {\n            return GROUP_MARGIN_TOP +\n                Math.max(...element.elements.map(heightOfNodesOnlyFirstLayerOfNestedStacks)) +\n                GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nfunction groupNestingLevel(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\": {\n            if (element.elements.length === 0) return 0;\n            // Ignore the nesting of the elements below the first one\n            return groupNestingLevel(element.elements[0]);\n        }\n        case \"layer\":\n            return Math.max(...element.elements.map(groupNestingLevel));\n        case \"group\":\n            return Math.max(...element.elements.map(groupNestingLevel)) + 1;\n        case \"node\":\n            return 0;\n    }\n}\n\nexport function addYToNodeG<N extends (Node & LayerIndex & X), E extends LayerPosition, G extends LayerIndex>(\n    graph: Graph<N, E, G>\n): Graph<N & Y & LayerDimensions, E, G & Y & Height> {\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n    addYToNode(graph.stack, {y: MARGIN_TOP, nodeY: 0, groupHeight: 0, belowLayerY: 0}, heightOfAllEdges);\n    return graph as unknown as Graph<N & Y & LayerDimensions, E, G & Y & Height>;\n}\n\nexport function addYToNode<N extends Node & LayerIndex, G extends LayerIndex>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { y: number, nodeY: number, groupHeight: number, belowLayerY: number },\n    heightOfEdges: number[]\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let old = {\n                y: accumulator.y,\n                nodeY: accumulator.nodeY,\n                belowLayerY: accumulator.belowLayerY\n            };\n            element.elements.forEach((layer, layerIndex) => {\n                addYToNode(layer, accumulator, heightOfEdges);\n            });\n            accumulator.y = old.y;\n            accumulator.nodeY = old.nodeY;\n            accumulator.belowLayerY = old.belowLayerY;\n            return;\n        }\n        case \"layer\": {\n            accumulator.nodeY = accumulator.y + groupNestingLevel(element) * GROUP_MARGIN_TOP;\n            accumulator.groupHeight = groupNestingLevel(element) * (GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM) + ELEMENT_HEIGHT;\n            accumulator.belowLayerY = accumulator.y + heightOfNodesOnlyFirstLayerOfNestedStacks(element) + VERTICAL_SPACING;\n            element.elements.forEach(nestedElement => {\n                addYToNode(nestedElement, accumulator, heightOfEdges);\n            });\n            accumulator.y += heightOfNodes(element) + VERTICAL_SPACING;\n            return;\n        }\n        case \"group\": {\n            let additionalEdgeHeight = heightOfEdges.slice(0, element.layerIndex).reduce((sum, add) => sum + add, 0);\n            Object.assign(element, {\n                y: accumulator.y + additionalEdgeHeight,\n                height: accumulator.groupHeight\n            });\n\n            accumulator.y += GROUP_MARGIN_TOP;\n            accumulator.groupHeight -= GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            element.elements.forEach(node => {\n                addYToNode(node, accumulator, heightOfEdges);\n            });\n            accumulator.y -= GROUP_MARGIN_TOP;\n            accumulator.groupHeight += GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            return;\n        }\n        case \"node\": {\n            let additionalEdgeHeight = heightOfEdges.slice(0, element.layerIndex).reduce((sum, add) => sum + add, 0);\n            Object.assign(element, {\n                y: accumulator.nodeY + additionalEdgeHeight,\n                belowLayerY: accumulator.belowLayerY + additionalEdgeHeight\n            });\n            return;\n        }\n    }\n}","import {ascending, descending} from \"./sorting\";\nimport {ConnectionIndex, Edge, Graph, Key, LayerIndex, NumberOfEdges, X} from \"./graphModel\";\n\nexport function addConnectionIndexAndNumberOfEdgesG<N extends LayerIndex & X & Key, E, G>(graph: Graph<N, E, G>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex, G> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    return graph as unknown as Graph<N & NumberOfEdges, E & ConnectionIndex, G>;\n}\n\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerIndex & X & Key>[]) {\n    type NodeSide = {\n        node: LayerIndex & X\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        reverseNode: LayerIndex & X\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(firstNode: LayerIndex & X & Key, secondNode: LayerIndex & X, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.key + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.x <= node.x);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.x >= node.x);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\n\n        before.sort(descending(e => e.reverseNode.x));\n        otherLayer.sort(ascending(e => e.reverseNode.x));\n        after.sort(descending(e => e.reverseNode.x));\n\n        let all = before.concat(otherLayer).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allNodes<N extends Node, G, E>(element: Stack<N, G> | Group<N, G> | N): N[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allNodes);\n        case \"group\":\n            return element.elements.flatMap(allNodes);\n        case \"node\":\n            return [element];\n    }\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allGroups<N extends Node, G, E>(element: Stack<N, G> | (Group<N, G> & G) | N): (Group<N, G> & G)[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allGroups);\n        case \"group\":\n            return [element].concat(element.elements.flatMap(allGroups));\n        case \"node\":\n            return [];\n    }\n}","import React from \"react\";\nimport {STROKE_WIDTH} from \"./styling\";\n\nexport type Symbol = {\n    x: number\n    y: number\n    width: number\n    symbolKey: string\n}\nexport const ComponentSymbol: React.FC<Symbol> = symbol => {\n    const symbolHeightRelative = 1.1;\n    const barWidthRelative = 0.4;\n    const barHeightRelative = 0.15;\n    const barWidthAbsolute = symbol.width * barWidthRelative;\n    const barHeightAbsolute = symbol.width * barHeightRelative;\n    return (\n        <g key={symbol.symbolKey}>\n            <rect\n                x={symbol.x + barWidthAbsolute / 2} y={symbol.y}\n                width={symbol.width * (1 - barWidthRelative / 2)} height={symbol.width * symbolHeightRelative}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute * 3}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, STROKE_WIDTH, SYMBOL_SPACING, SYMBOL_WIDTH, TEXT_PADDING} from \"./styling\";\nimport {Key, Node, X, Y} from \"./graphModel\";\nimport {ComponentSymbol} from \"./Symbols\";\n\nexport const NodeShape: React.FC<Node & X & Y & Key> = node => {\n    if (node.isPlaceholder) return null;\n\n    let isComponent = node.symbol === \"component\";\n    return (\n        <g key={node.key}>\n            <rect data-testid=\"rect\"\n                  x={node.x} y={node.y}\n                  width={width(node)} height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n\n            <text x={node.x + TEXT_PADDING} y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + node.key}>\n                <rect\n                    x={node.x + TEXT_PADDING} y={node.y}\n                    width={width(node) - 2 * TEXT_PADDING - (isComponent ? (SYMBOL_WIDTH + SYMBOL_SPACING) : 0)}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n\n            {isComponent ?\n                <ComponentSymbol\n                    symbolKey={node.key + \"CS\"}\n                    x={node.x + width(node) - SYMBOL_WIDTH - SYMBOL_SPACING}\n                    y={node.y + SYMBOL_SPACING}\n                    width={SYMBOL_WIDTH}/>\n                : \"\"}\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, GROUP_MARGIN_SIDE, STROKE_WIDTH} from \"./styling\";\nimport {Group, Height, Key, Node, X, Y} from \"./graphModel\";\n\nexport const GroupShape: React.FC<Group<Node, unknown> & X & Y & Key & Height> = group => {\n    return (\n        <g key={group.key}>\n            <rect\n                x={group.x} y={group.y}\n                width={width(group)}\n                height={group.height}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text x={group.x + GROUP_MARGIN_SIDE} y={group.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + group.key + \")\"}>{group.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + group.key}>\n                <rect\n                    x={group.x + GROUP_MARGIN_SIDE} y={group.y}\n                    width={width(group) - 2 * GROUP_MARGIN_SIDE}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {EDGE_SPACING, STROKE_WIDTH, VERTICAL_SPACING} from \"./styling\";\nimport {\n    ConnectionIndex,\n    Edge,\n    getUpperLeftNode,\n    LayerDimensions, LayerIndex,\n    LayerPosition,\n    Node,\n    NumberOfEdges, X,\n    Y\n} from \"./graphModel\";\nimport {heightOfNodes} from \"./addYToNode\";\n\nfunction edgeEndCoordinates<N extends Node & LayerIndex & X & Y & NumberOfEdges>(\n    node: N, edgeIndex: number, otherNode: N\n) {\n    let onLowerSide = node.layerIndex <= otherNode.layerIndex;\n    let nodeCenteringOffset = (width(node) - ((onLowerSide ? node.lowerSideEdges : node.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    return {\n        x: node.x + nodeCenteringOffset + edgeIndex * EDGE_SPACING,\n        y: node.y + (onLowerSide ? heightOfNodes(node) : 0)\n    };\n}\n\nexport const EdgeShape: React.FC<Edge<Node & LayerIndex & X & Y & LayerDimensions & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\n    let fromNode = edgeEndCoordinates(edge.from, edge.fromIndex, edge.to);\n    let upperNodeEdgesY = getUpperLeftNode(edge).belowLayerY - VERTICAL_SPACING / 2 + edge.index * EDGE_SPACING;\n    let toNode = edgeEndCoordinates(edge.to, edge.toIndex, edge.from);\n    return (\n        <path key={edge.key} d={\n            \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n            \"L \" + fromNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + toNode.y\n        }\n              stroke=\"black\"\n              strokeWidth={STROKE_WIDTH}\n              fill=\"none\"\n        />\n    );\n};","import {Graph, Group, Layer, LayerIndex, Node, Stack} from \"./graphModel\";\n\nfunction numberOfLayers(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(numberOfLayers)\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(numberOfLayers));\n        case \"group\": {\n            return Math.max(...element.elements.map(numberOfLayers));\n        }\n        case \"node\":\n            return 1;\n    }\n}\n\nexport function addLayerIndexToNodeG<N extends Node, E, G>(graph: Graph<N, E, G>):\n    Graph<N & LayerIndex, E, G & LayerIndex> {\n    addLayerIndexToNode(graph.stack);\n    return graph as unknown as Graph<N & LayerIndex, E, G & LayerIndex>;\n}\n\nexport function addLayerIndexToNode<N extends Node, G>(\n    element: N | Group<N, G> | Layer<N, G> | Stack<N, G>,\n    layerIndex: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach(nestedElement => {\n                addLayerIndexToNode(nestedElement, layerIndex);\n                layerIndex += numberOfLayers(nestedElement);\n            });\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => {\n                addLayerIndexToNode(group, layerIndex);\n            });\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n\n            element.elements.forEach(node => {\n                addLayerIndexToNode(node, layerIndex);\n            });\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n            return;\n        }\n    }\n}","import {Graph, Layer, LayerIndex, Node} from \"./graphModel\";\n\nexport function insertPlaceholdersInMultilayerEdges(graph: Graph<Node & LayerIndex, unknown, LayerIndex>): Graph<Node & LayerIndex, unknown, LayerIndex> {\n    return {\n        stack: graph.stack,\n        edges: graph.edges\n            .flatMap(edge => {\n                if (Math.abs(edge.from.layerIndex - edge.to.layerIndex) <= 1) return edge;\n\n                let from = Math.min(edge.from.layerIndex, edge.to.layerIndex);\n                let to = Math.max(edge.from.layerIndex, edge.to.layerIndex);\n                let newEdges = [];\n                let last = edge.from.layerIndex < edge.to.layerIndex ? edge.from : edge.to;\n                let end = edge.from.layerIndex >= edge.to.layerIndex ? edge.from : edge.to;\n                for (let i = from + 1; i < to; i++) {\n                    let placeholder: Node & LayerIndex = {\n                        kind: \"node\",\n                        name: \"\",\n                        size: 0.01,\n                        isPlaceholder: true,\n                        layerIndex: i\n                    };\n                    let layer: Layer<Node & LayerIndex, LayerIndex> = graph.stack.elements[i];\n                    layer.elements.splice(0, 0, placeholder);\n                    newEdges.push({from: last, to: placeholder});\n                    last = placeholder;\n                }\n                newEdges.push({from: last, to: end});\n                return newEdges;\n            })\n    };\n}","import {Graph, Group, Key, Layer, Node, Stack} from \"./graphModel\";\n\nexport function addKeyToNodeG<N extends Node, E, G>(\n    graph: Graph<N, E, G>\n): Graph<N & Key, E, G & Key> {\n    addKeyToNode(graph.stack);\n    return graph as unknown as Graph<N & Key, E, G & Key>;\n}\n\nexport function addKeyToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { globalCounter: number } = {globalCounter: 0}\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach(groups => addKeyToNode(groups, accumulator));\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => addKeyToNode(group, accumulator));\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                key: \"\" + accumulator.globalCounter\n            });\n            accumulator.globalCounter++;\n\n            element.elements.forEach(node => addKeyToNode(node, accumulator));\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                key: \"\" + accumulator.globalCounter\n            });\n            accumulator.globalCounter++;\n            return;\n        }\n    }\n}","import React from \"react\";\nimport {addXToNodeG} from \"./addXToNode\";\nimport {addLayerPositionToEdgeG} from \"./addLayerPositionToEdge\";\nimport {addYToNodeG, heightOfNodes} from \"./addYToNode\";\nimport {addConnectionIndexAndNumberOfEdgesG} from \"./addConnectionIndexAndNumberOfEdges\";\nimport {allNodes} from \"./allNodes\";\nimport {allGroups} from \"./allGroups\";\nimport {heightOfEdges} from \"./heightOfEdges\";\nimport {NodeShape} from \"./NodeShape\";\nimport {GroupShape} from \"./GroupShape\";\nimport {EdgeShape} from \"./EdgeShape\";\nimport {width} from \"./width\";\nimport {MARGIN_SIDE, MARGIN_TOP, VERTICAL_SPACING} from \"./styling\";\nimport {Graph, Node} from \"./graphModel\";\nimport {addLayerIndexToNodeG} from \"./addLayerIndexToNode\";\nimport {insertPlaceholdersInMultilayerEdges} from \"./insertPlaceholdersInMultilayerEdges\";\nimport {addKeyToNodeG} from \"./addKeyToNode\";\n\nexport const Diagram: React.FC<Graph<Node, unknown, unknown>> = graph => {\n    return [graph]\n        .map(addLayerIndexToNodeG)\n        .map(insertPlaceholdersInMultilayerEdges)\n        .map(addKeyToNodeG)\n        .map(addXToNodeG)\n        .map(addLayerPositionToEdgeG)\n        .map(addYToNodeG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(graph => {\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n            let overallWidth = width(graph.stack) + 2 * MARGIN_SIDE;\n            let height = heightOfNodes(graph.stack) + VERTICAL_SPACING +\n                heightOfAllEdges.reduce((sum, add) => sum + add) +\n                2 * MARGIN_TOP;\n\n            return (\n                <svg viewBox={\"0 0 \" + overallWidth + \" \" + height}>\n                    {allNodes(graph.stack).map(NodeShape)}\n                    {allGroups(graph.stack).map(GroupShape)}\n                    {graph.edges.map(EdgeShape)}\n                </svg>\n            );\n        })[0];\n};"],"sourceRoot":""}