{"version":3,"sources":["v1/Editor.tsx","v1/parseGraph.tsx","v1/sorting.tsx","v1/Architecture.tsx","v2/newGraphModel.tsx","v2/styling.tsx","v2/NodeShape.tsx","v2/assertNever.tsx","v2/elementsLayout/OffsetElementsY.tsx","v2/elementsLayout/OffsetElementsX.tsx","v2/elementsLayout/EmbeddedElementsX.tsx","v2/ContainerShape.tsx","v2/elementsLayout/BorderIndexMaxX.tsx","v2/elementsLayout/BorderIndexLeft.tsx","v2/elementsLayout/BorderIndexRight.tsx","v2/elementsLayout/BorderIndexTop.tsx","v2/elementsLayout/BorderIndexBottom.tsx","v2/sumOfPreviousRows.tsx","v2/getMostBottomOffsetElementsY.tsx","v2/elementsLayout/BorderIndexMaxBottom.tsx","v2/elementsLayout/BorderIndexMaxTop.tsx","v2/elementsLayout/EmbeddedElementsY.tsx","v2/EdgeHelper.tsx","v2/EdgeShape.tsx","v2/edgesLayout/ConnectionIndexAndNumberOfEdges.tsx","v2/edgesLayout/SyntheticNodesAndEdges.tsx","v2/edgesLayout/MidPathSegmentOffsetY.tsx","v2/elementsLayout/ElementKey.tsx","v2/edgesLayout/MidPathSegmentOffsetYAggregates.tsx","v2/edgesLayout/EdgeIndex.tsx","v2/edgesLayout/CrossLayerPathSegmentOffsetX.tsx","v2/edgesLayout/CrossLayerPathSegmentOffsetMaxX.tsx","v2/Diagram.tsx","v2/Sample.tsx","App.tsx","serviceWorker.ts","index.tsx","v1/indicesToReferences.tsx","v1/stringsToNodes.tsx","v1/styling.tsx","v1/width.tsx","v1/addXToNode.tsx","v1/graphModel.tsx","v1/addLayerPositionToEdge.tsx","v1/heightOfEdges.tsx","v1/addYToNode.tsx","v1/addConnectionIndexAndNumberOfEdges.tsx","v1/allNodes.tsx","v1/allGroups.tsx","v1/Symbols.tsx","v1/NodeShape.tsx","v1/GroupShape.tsx","v1/EdgeShape.tsx","v1/addLayerIndexToNode.tsx","v1/insertPlaceholdersInMultilayerEdges.tsx","v1/addKeyToNode.tsx","v1/Diagram.tsx"],"names":["graphAsString","indicesToReferences","indicesToReferencesImport","stringsToNodes","stringsToNodesImport","initialGraph","eval","Editor","useState","graph","setGraph","errorMessage","setErrorMessage","id","className","stack","edges","cols","rows","onChange","changeEvent","result","parseGraph","target","value","defaultValue","text","undefined","every","edge","from","to","e","message","ascending","property","o1","o2","descending","and","sortFunctions","i","length","component","name","kind","symbol","size","Architecture","productAPI","stockAPI","productServiceDB","productImporter","stockImporter","categoryImporter","campaignImporter","elements","element","syntheticNodes","syntheticEdges","transformElements","f","transformElementsUsingGraph","ELEMENT_WIDTH","ELEMENT_HEIGHT","BORDER_SPACING_X","BORDER_SPACING_TOP","BORDER_SPACING_BOTTOM","HORIZONTAL_SPACING","VERTICAL_SPACING","EDGE_SPACING","NodeShape","node","key","elementKey","x","offsetElementsX","borderIndexMaxX","crossLayerPathSegmentOffsetMaxX","y","offsetElementsY","borderIndexMaxPreviousTop","borderIndexMaxTop","borderIndexMaxPreviousBottom","midPathSegmentOffsetMaxPreviousY","width","height","fill","strokeWidth","stroke","assertNever","Error","addOffsetElementsYG","addOffsetElementsY","accumulator","Object","assign","maxOffsetYElements","oldOffsetYElements","forEach","nestedElement","Math","max","addOffsetElementsXG","addOffsetElementsX","maxOffsetXElements","oldOffsetXElements","addEmbeddedElementsXG","addEmbeddedElementsX","embeddedElementsX","embeddedXElements","map","reduce","sum","add","ContainerShape","container","borderIndexLeft","borderIndexTop","borderIndexRight","embeddedElementsY","embeddedBorderIndexMaxTop","embeddedBorderIndexMaxBottom","embeddedMidPathSegmentY","borderIndexBottom","borderIndexMaxBottom","addBorderIndexMaxXG","determineAndAddBorderIndexMaxX","addBorderIndexMaxX","determineBorderIndexMaxX","addBorderIndexLeftG","addBorderIndexLeft","leftBorderIndex","border","addBorderIndexRightG","addBorderIndexRight","borderIndices","borderIndex","addBorderIndexTopG","addBorderIndexTop","addBorderIndexBottomG","addBorderIndexBottom","sumOfPreviousRows","Map","sumOfPrevious","Array","entries","sort","entry","set","getMostBottomOffsetElementsY","addBorderIndexMaxBottomG","determineAndAddBorderIndexBottomAggregates","determineBorderIndexMaxBottom","sums","addBorderIndexMaxBottom","addition","get","calculateEmbeddedBorders","current","embeddedBorders","addBorderIndexMaxTopG","determineAndAddBorderIndexTopAggregates","determineBorderIndexMaxTop","addBorderIndexMaxTop","addEmbeddedElementsYG","addEmbeddedElementsY","fromIsUpperLeft","getUpperLeftNode","getLowerRightNode","getLeftUpperNode","fromIsLeftUpper","getY","getX","edgeEndCoordinates","edgeIndex","otherNode","onLowerSide","nodeCenteringOffset","lowerSideEdges","upperSideEdges","EdgeShape","fromNode","fromIndex","upperNodeEdgesY","midPathSegmentOffsetY","toNode","toIndex","lowerLayerEdge","lowerNodeEdgesY","besideTopNodeX","crossLayerPathSegmentOffsetX","d","addConnectionIndexAndNumberOfEdgesG","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","edgeEnds","push","reverseNode","index","values","sameLayer","filter","edgeEnd","before","after","otherLayer","otherLayerBefore","otherLayerAfter","concat","addConnectionIndexAndNumberOfEdges","edgesWithConnectionIndex","getLowerRightNodeIndex","getUpperLeftNodeIndex","isMultiLayerEdge","abs","addSyntheticNodesAndEdgesG","allElements","lowerRightNode","upperLeftNode","min","lowerLayerEdgeProperty","isLowerLayerEdge","originalEdge","flatMap","addMidPathSegmentOffsetYG","groupedByOffsetElementsY","addMidPathSegmentOffsetYForLayer","addMidPathSegmentOffsetY","groupedByUpperNode","nodeKeys","keys","indexOffset","nodeKey","sameLayerBefore","sameLayerAfter","addLayerPosition","indexInArray","beforeOrAfter","addElementKeyG","addElementKey","addMidPathSegmentOffsetYAggregatesG","addMidPathSegmentOffsetYAggregates","maxOffsetY","determineMaxOffsetY","maxs","determineMidPathSegmentMaxOffsetY","layer","sumOfPreviousRowsFillLayers","applyMidPathSegmentOffsetYAggregates","calculateEmbeddedPaths","embeddedPaths","addEdgeIndexG","addCrossLayerPathSegmentOffsetXG","groupedByOffsetElementsX","addCrossLayerPathSegmentOffsetXForSlice","addCrossLayerPathSegmentOffsetX","addOffset","addCrossLayerPathSegmentOffsetMaxXG","determineAndAddCrossLayerPathSegmentOffsetMaxX","addCrossLayerPathSegmentOffsetMaxX","allNodes","allContainers","Diagram","props","console","log","viewBox","c","Sample","node_1_1","node_1_2","node_2_1","node_2_2","node_3_2","node_4_1","node_4_2","node_4_3","node_4_4","node_4_5","node_5_1","node_5_2","node_6_1","node_6_2","node_6_3","node_6_4","App","exact","path","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","indexToReference","indexPairs","indexPair","indexPairToReference","convertStringsToNodes","strings","MARGIN_TOP","MARGIN_SIDE","GROUP_MARGIN_TOP","GROUP_MARGIN_BOTTOM","GROUP_MARGIN_SIDE","addXToNodeG","addXToNode","fullWidth","oldX","group","layerIndex","addLayerPositionToEdgeG","groupedByLayerIndex","addLayerPositionToEdgeForLayer","addLayerPositionToEdge","heightOfEdges","numberOfLayers","grouped","edgeIndices","heightOfNodes","isPlaceholder","heightOfNodesOnlyFirstLayerOfNestedStacks","groupNestingLevel","addYToNodeG","heightOfAllEdges","addYToNode","old","nodeY","belowLayerY","groupHeight","additionalEdgeHeight","slice","allGroups","ComponentSymbol","barWidthAbsolute","barHeightAbsolute","symbolKey","isComponent","data-testid","clipPath","SYMBOL_WIDTH","GroupShape","addLayerIndexToNodeG","addLayerIndexToNode","insertPlaceholdersInMultilayerEdges","newEdges","last","end","placeholder","splice","addKeyToNodeG","addKeyToNode","globalCounter","groups","overallWidth"],"mappings":"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","file":"static/js/main.8aeea6d0.chunk.js","sourcesContent":["import {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\nimport React, {useState} from \"react\";\nimport {parseGraph} from \"./parseGraph\";\nimport {Diagram} from \"./Diagram\";\nimport {Graph, Node} from \"./graphModel\";\nimport './Editor.css';\n\nlet graphAsString =\n    `var stack = stringsToNodes([\n    [\n        {name: \"group 1\", elements: [\n            \"element 11\", \n            {name: \"element 2\", size: 1.5, symbol: \"component\"}, \n            {name: \"an element with long text\", symbol: \"component\"}            \n        ]},\n        {name: \"group 2\", elements: [\"element 4\"]}\n    ],\n    [\n        {name: \"group 3\", elements: [\"element 1\", \"element 2\"]},\n        {name: \"group 4\", elements: [\n            {name: \"group 6\", elements: [\"element 4\"]}, \n            {name: \"placeholder\", size: 0.3, isPlaceholder: true}, \n            \"element 3\"\n        ]},\n        \"node on top level\", \n        {name: \"an element with long text\", symbol: \"component\"}     \n    ],\n    [\n        {name: \"group 5\", elements: [\n            \"element 1\", \"element 2\", \"element 3\", \n            {name: \"element with changed name\", size: 1.5}, \n            {name: \"element 5\", size: 0.7}]}\n    ]\n]);\n\nvar edgeIndices = [\n    {from: [0, 0, 0],    to: [1, 3]},\n    {from: [0, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 2],    to: [1, 1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 0, 1]},\n    {from: [1, 1, 0, 0], to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 4]},\n    {from: [1, 0, 1],    to: [2, 0, 3]},\n    {from: [1, 0, 1],    to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [2, 0, 0]},\n    {from: [2, 0, 0],    to: [1, 0, 0]},\n    {from: [2, 0, 1],    to: [1, 0, 0]},\n    {from: [2, 0, 0],    to: [2, 0, 3]},\n    {from: [2, 0, 1],    to: [2, 0, 3]},\n    {from: [2, 0, 4],    to: [2, 0, 3]},\n    {from: [0, 0, 0],    to: [0, 0, 2]},\n    {from: [0, 0, 0],    to: [0, 0, 1]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 1, 1]},\n    {from: [1, 1, 1],    to: [2, 0, 2]},\n    {from: [0, 1, 0],    to: [1, 1, 2]},\n    {from: [1, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [1, 1, 0, 0]}\n];\nvar edges = indicesToReferences(stack, edgeIndices);\n\nvar graph = {\n    stack: stack,\n    edges: edges\n};\n\ngraph\n`;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\n// eslint-disable-next-line no-eval\nconst initialGraph: Graph<Node, unknown, unknown> = eval(graphAsString);\n\nexport const Editor: React.FC = () => {\n    const [graph, setGraph] = useState(initialGraph);\n    const [errorMessage, setErrorMessage] = useState(\"\");\n\n    function handleChange(changeEvent: React.ChangeEvent<HTMLTextAreaElement>) {\n        let result = parseGraph(changeEvent.target.value);\n        if (typeof result === 'string') {\n            setErrorMessage(result);\n        } else {\n            setGraph(result);\n            setErrorMessage(\"\");\n        }\n    }\n\n    return (\n        <div id=\"parent\" className=\"App\">\n            <div id=\"graph\">\n                <Diagram stack={graph.stack} edges={graph.edges}/>\n            </div>\n            <div>\n                <textarea cols={100} rows={45} onChange={handleChange} defaultValue={graphAsString}/>\n                <p className=\"error-message\">{errorMessage}</p>\n            </div>\n        </div>\n    );\n};","import {Edge, Graph, Node} from \"./graphModel\";\nimport {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\nexport function parseGraph(text: string): Graph<Node, unknown, unknown> | string {\n    try {\n// eslint-disable-next-line\n        let graph: Graph<Node, unknown, unknown> = eval(text);\n\n        if (graph === undefined) return \"Script is not returning a graph object!\";\n\n        if (graph.stack === undefined) return \"Property layers is missing in graph object!\";\n        if (graph.edges === undefined) return \"Property edges is missing in graph object!\";\n\n        if (!graph.edges.every((edge: Edge<Node>) => edge.from !== undefined))\n            return \"Property from must be defined on every edge!\";\n        if (!graph.edges.every((edge: Edge<Node>) => edge.to !== undefined))\n            return \"Property to must be defined on every edge!\";\n\n        return graph;\n    } catch (e) {\n        return e.message;\n    }\n}","export function ascending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o1) - property(o2);\n}\n\nexport function descending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o2) - property(o1);\n}\n\nexport function and<T>(...sortFunctions: ((o1: T, o2: T) => number)[]) {\n    return (o1: T, o2: T) => {\n        let i = 0;\n        while (true) {\n            if (i === sortFunctions.length) return 0;\n            let result = sortFunctions[i](o1, o2);\n            if (result !== 0) return result;\n            i++;\n        }\n    }\n}","import React from \"react\";\nimport {Diagram} from \"./Diagram\";\nimport {Edge, Node, Stack} from \"./graphModel\";\n\nfunction component(name: string): Node {\n    return {\n        kind: \"node\", name: name, symbol: \"component\", size: 1.2\n    }\n}\n\nexport const Architecture: React.FC = () => {\n    let productAPI = component(\"Product API\");\n    let stockAPI = component(\"Stock API\");\n    let productServiceDB = component(\"Product Service DB\");\n    let productImporter = component(\"Product Importer\");\n    let stockImporter = component(\"Stock Importer\");\n    let categoryImporter = component(\"Category Importer\");\n    let campaignImporter = component(\"Campaign Importer\");\n\n    let stack: Stack<Node, unknown> = {\n        kind: \"stack\",\n        elements: [\n            {\n                kind: \"layer\",\n                elements: [productAPI, stockAPI]\n            },\n            {\n                kind: \"layer\",\n                elements: [productServiceDB]\n            },\n            {\n                kind: \"layer\",\n                elements: [productImporter, stockImporter, categoryImporter, campaignImporter]\n            }\n        ]\n    };\n\n    let edges: Edge<Node>[] = [\n        {from: productAPI, to: productServiceDB},\n        {from: stockAPI, to: productServiceDB},\n        {from: productServiceDB, to: productImporter},\n        {from: productServiceDB, to: stockImporter},\n        {from: productServiceDB, to: categoryImporter},\n        {from: productServiceDB, to: campaignImporter}\n    ];\n\n    return (\n        <Diagram stack={stack} edges={edges}/>\n    );\n};","export type Node = {\n    kind: \"node\"\n};\n\nexport type Row<N> = {\n    kind: \"row\",\n    border?: \"solid\",\n    elements: Element<N>[]\n};\n\nexport type Column<N> = {\n    kind: \"column\",\n    border?: \"solid\",\n    elements: Element<N>[]\n};\n\nexport type Container<N> = (Row<N> & N) | (Column<N> & N);\n\nexport type Element<N> = (Node & N) | (Row<N> & N) | (Column<N> & N);\n\nexport type Edge<N, E> = {\n    from: N,\n    to: N\n} & E\n\nexport type Graph<N, E> = {\n    element: Element<N>\n    edges: Edge<N, E>[]\n    syntheticNodes: (Node & N)[]\n    syntheticEdges: Edge<N, E>[]\n}\n\nexport function graph<N, E>(\n    element: Element<N>,\n    edges: Edge<N, E>[] = [],\n    syntheticNodes: (Node & N)[] = [],\n    syntheticEdges: Edge<N, E>[] = []\n): Graph<N, E> {\n    return {element, edges, syntheticNodes, syntheticEdges};\n}\n\nexport function transformElements<N, A, E>(graph: Graph<N, E>, f: (element: Element<N>) => void): Graph<N & A, E> {\n    f(graph.element);\n    return graph as Graph<N & A, E>;\n}\n\nexport function transformElementsUsingGraph<N, A, E>(graph: Graph<N, E>, f: (graph: Graph<N, E>) => void): Graph<N & A, E> {\n    f(graph);\n    return graph as Graph<N & A, E>;\n}\n\nexport function node(): Node {\n    return {\n        kind: \"node\"\n    };\n}\n\nexport function edge<N>(from: N, to: N): Edge<N, unknown> {\n    return {\n        from: from,\n        to: to\n    }\n}","export const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const BORDER_SPACING_X = 10;\nexport const BORDER_SPACING_TOP = 30;\nexport const BORDER_SPACING_BOTTOM = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;","import React from \"react\";\nimport {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    BORDER_SPACING_X,\n    EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    HORIZONTAL_SPACING,\n    STROKE_WIDTH,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {BorderIndexMaxX} from \"./elementsLayout/BorderIndexMaxX\";\nimport {BorderIndexMaxPreviousTop, BorderIndexMaxTop} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexMaxPreviousBottom} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {ElementKey} from \"./elementsLayout/ElementKey\";\nimport {MidPathSegmentOffsetMaxPreviousY} from \"./edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {CrossLayerPathSegmentOffsetMaxX} from \"./edgesLayout/CrossLayerPathSegmentOffsetMaxX\";\n\ntype Props = ElementKey &\n    OffsetElementsX & BorderIndexMaxX & CrossLayerPathSegmentOffsetMaxX &\n    OffsetElementsY &\n    BorderIndexMaxPreviousTop & BorderIndexMaxTop &\n    BorderIndexMaxPreviousBottom &\n    MidPathSegmentOffsetMaxPreviousY;\n\nexport const NodeShape: React.FC<Props> = node => {\n    return (\n        <g key={node.elementKey}>\n            <rect\n                x={node.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING)\n                + node.borderIndexMaxX * (node.offsetElementsX * 2 + 1) * BORDER_SPACING_X\n                + node.crossLayerPathSegmentOffsetMaxX * node.offsetElementsX * EDGE_SPACING\n                }\n                y={node.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                + (node.borderIndexMaxPreviousTop + node.borderIndexMaxTop) * BORDER_SPACING_TOP\n                + node.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n                + node.midPathSegmentOffsetMaxPreviousY * EDGE_SPACING\n                }\n                width={ELEMENT_WIDTH}\n                height={ELEMENT_HEIGHT}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n\n            <text\n                x={node.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING)\n                + node.borderIndexMaxX * (node.offsetElementsX * 2 + 1) * BORDER_SPACING_X\n                + node.crossLayerPathSegmentOffsetMaxX * node.offsetElementsX * EDGE_SPACING\n                }\n                y={node.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                + (node.borderIndexMaxPreviousTop + node.borderIndexMaxTop) * BORDER_SPACING_TOP\n                + node.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n                + node.midPathSegmentOffsetMaxPreviousY * EDGE_SPACING\n                + 15\n                }\n                fill=\"black\">{\n                node.midPathSegmentOffsetMaxPreviousY\n            }\n            </text>\n        </g>\n    );\n};","export function assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type OffsetElementsY = { offsetElementsY: number };\n\nexport function addOffsetElementsYG<N, E>(graph: Graph<N, E>): Graph<N & OffsetElementsY, E> {\n    return transformElements<N, OffsetElementsY, E>(graph, addOffsetElementsY);\n}\n\nexport function addOffsetElementsY(element: Element<unknown>, accumulator = {offsetElementsY: 0}) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            accumulator.offsetElementsY++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            let maxOffsetYElements = 0;\n            let oldOffsetYElements = accumulator.offsetElementsY;\n            element.elements.forEach(nestedElement => {\n                addOffsetElementsY(nestedElement, accumulator);\n                maxOffsetYElements = Math.max(maxOffsetYElements, accumulator.offsetElementsY);\n                accumulator.offsetElementsY = oldOffsetYElements;\n            });\n            accumulator.offsetElementsY = maxOffsetYElements;\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            element.elements.forEach(nestedElement => addOffsetElementsY(nestedElement, accumulator));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type OffsetElementsX = { offsetElementsX: number };\n\nexport function addOffsetElementsXG<N, E>(graph: Graph<N, E>): Graph<N & OffsetElementsX, E> {\n    return transformElements<N, OffsetElementsX, E>(graph, addOffsetElementsX);\n}\n\nexport function addOffsetElementsX(element: Element<unknown>, accumulator = {offsetElementsX: 0}) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            accumulator.offsetElementsX++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            element.elements.forEach(nestedElement => addOffsetElementsX(nestedElement, accumulator));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            let maxOffsetXElements = 0;\n            let oldOffsetXElements = accumulator.offsetElementsX;\n            element.elements.forEach(nestedElement => {\n                addOffsetElementsX(nestedElement, accumulator);\n                maxOffsetXElements = Math.max(maxOffsetXElements, accumulator.offsetElementsX);\n                accumulator.offsetElementsX = oldOffsetXElements;\n            });\n            accumulator.offsetElementsX = maxOffsetXElements;\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type EmbeddedElementsX = { embeddedElementsX: number };\n\nexport function addEmbeddedElementsXG<N, E>(graph: Graph<N, E>): Graph<N & EmbeddedElementsX, E> {\n    return transformElements<N, EmbeddedElementsX, E>(graph, addEmbeddedElementsX);\n}\n\nexport function addEmbeddedElementsX(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, EmbeddedElementsX>(element, {\n                embeddedElementsX: 1\n            });\n            return 1;\n        }\n        case \"row\": {\n            let embeddedXElements =\n                element.elements.map(addEmbeddedElementsX).reduce((sum, add) => sum + add, 0);\n\n            Object.assign<Row<unknown>, EmbeddedElementsX>(element, {\n                embeddedElementsX: embeddedXElements\n            });\n            return embeddedXElements;\n        }\n        case \"column\": {\n            let embeddedXElements =\n                Math.max(...element.elements.map(addEmbeddedElementsX), 0);\n\n            Object.assign<Column<unknown>, EmbeddedElementsX>(element, {\n                embeddedElementsX: embeddedXElements\n            });\n            return embeddedXElements;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import React from \"react\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    BORDER_SPACING_X, EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    HORIZONTAL_SPACING,\n    STROKE_WIDTH,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {Container} from \"./newGraphModel\";\nimport {EmbeddedElementsX} from \"./elementsLayout/EmbeddedElementsX\";\nimport {BorderIndexMaxX} from \"./elementsLayout/BorderIndexMaxX\";\nimport {BorderIndexLeft} from \"./elementsLayout/BorderIndexLeft\";\nimport {BorderIndexTop} from \"./elementsLayout/BorderIndexTop\";\nimport {BorderIndexMaxBottom, BorderIndexMaxPreviousBottom, EmbeddedBorderIndexMaxBottom} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {BorderIndexMaxPreviousTop, BorderIndexMaxTop, EmbeddedBorderIndexMaxTop} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexBottom} from \"./elementsLayout/BorderIndexBottom\";\nimport {BorderIndexRight} from \"./elementsLayout/BorderIndexRight\";\nimport {EmbeddedElementsY} from \"./elementsLayout/EmbeddedElementsY\";\nimport {ElementKey} from \"./elementsLayout/ElementKey\";\nimport {EmbeddedMidPathSegmentY, MidPathSegmentOffsetMaxPreviousY} from \"./edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {CrossLayerPathSegmentOffsetMaxX} from \"./edgesLayout/CrossLayerPathSegmentOffsetMaxX\";\n\ntype Props = Container<\n    ElementKey &\n    OffsetElementsX & EmbeddedElementsX &\n    OffsetElementsY & EmbeddedElementsY &\n    CrossLayerPathSegmentOffsetMaxX &\n    BorderIndexLeft & BorderIndexRight & BorderIndexMaxX &\n    BorderIndexTop & BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop &\n    BorderIndexBottom & BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom &\n    MidPathSegmentOffsetMaxPreviousY & EmbeddedMidPathSegmentY>;\n\nexport const ContainerShape: React.FC<Props> = container => {\n    return (\n        <g key={container.elementKey}>\n            <rect\n                x={container.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING)\n                + (container.borderIndexMaxX * (container.offsetElementsX * 2 + 1)  - container.borderIndexLeft) * BORDER_SPACING_X\n                + container.crossLayerPathSegmentOffsetMaxX * container.offsetElementsX * EDGE_SPACING\n                }\n                y={container.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                + (container.borderIndexMaxPreviousTop + container.borderIndexMaxTop - container.borderIndexTop) * BORDER_SPACING_TOP\n                + container.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n                + container.midPathSegmentOffsetMaxPreviousY * EDGE_SPACING\n                }\n                width={container.embeddedElementsX * ELEMENT_WIDTH + (container.embeddedElementsX - 1) * HORIZONTAL_SPACING\n                + ((container.embeddedElementsX - 1) * container.borderIndexMaxX * 2 + container.borderIndexLeft + container.borderIndexRight) * BORDER_SPACING_X\n                + (container.embeddedElementsX - 1) * container.crossLayerPathSegmentOffsetMaxX * EDGE_SPACING\n                }\n                height={container.embeddedElementsY * ELEMENT_HEIGHT +\n                (container.embeddedElementsY - 1) * VERTICAL_SPACING +\n                container.borderIndexTop * BORDER_SPACING_TOP +\n                container.embeddedBorderIndexMaxTop * BORDER_SPACING_TOP +\n                container.embeddedBorderIndexMaxBottom * BORDER_SPACING_BOTTOM +\n                container.embeddedMidPathSegmentY * EDGE_SPACING +\n                container.borderIndexBottom * BORDER_SPACING_BOTTOM\n                }\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text\n                x={container.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING)\n                + (container.borderIndexMaxX * (container.offsetElementsX * 2 + 1) - container.borderIndexLeft) * BORDER_SPACING_X\n                + container.crossLayerPathSegmentOffsetMaxX * container.offsetElementsX * EDGE_SPACING\n                }\n                y={container.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n                + (container.borderIndexMaxPreviousTop + container.borderIndexMaxTop - container.borderIndexTop) * BORDER_SPACING_TOP\n                + container.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n                + container.midPathSegmentOffsetMaxPreviousY * EDGE_SPACING\n                + 15\n                }\n                fill=\"black\">{\n                container.embeddedElementsY + \"__\" +\n                container.borderIndexMaxPreviousTop + \"/\" + container.borderIndexTop + \"/\" + container.borderIndexMaxTop + \"__\" +\n                container.borderIndexMaxPreviousBottom + \"/\" + container.borderIndexBottom + \"/\" + container.borderIndexMaxBottom}\n            </text>\n        </g>\n    );\n};","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexLeft} from \"./BorderIndexLeft\";\nimport {BorderIndexRight} from \"./BorderIndexRight\";\n\nexport type BorderIndexMaxX = { borderIndexMaxX: number };\n\nexport function addBorderIndexMaxXG<N extends BorderIndexLeft & BorderIndexRight, E>(\n    graph: Graph<N, E>\n): Graph<N & BorderIndexMaxX, E> {\n    return transformElements<N, BorderIndexMaxX, E>(graph, determineAndAddBorderIndexMaxX);\n}\n\nfunction determineAndAddBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>) {\n    let maxEmbeddedXBorders = determineBorderIndexMaxX(element);\n    addBorderIndexMaxX(element, maxEmbeddedXBorders);\n}\n\nfunction determineBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>): number {\n    switch (element.kind) {\n        case \"node\": return 0;\n        case \"row\": return Math.max(\n            ...element.elements.map(determineBorderIndexMaxX),\n            element.borderIndexLeft,\n            element.borderIndexRight\n        );\n        case \"column\": return Math.max(\n            ...element.elements.map(determineBorderIndexMaxX),\n            element.borderIndexLeft,\n            element.borderIndexRight\n        );\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nexport function addBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>, borderIndexMaxX: number) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxX(nestedElement, borderIndexMaxX));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxX(nestedElement, borderIndexMaxX));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexLeft = { borderIndexLeft: number };\n\nexport function addBorderIndexLeftG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexLeft, E> {\n    return transformElements<N, BorderIndexLeft, E>(graph, addBorderIndexLeft);\n}\n\nexport function addBorderIndexLeft(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexLeft>(element, {\n                borderIndexLeft: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let leftBorderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexLeft) :  [0];\n            let leftBorderIndex = leftBorderIndices[0] + (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexLeft>(element, {\n                borderIndexLeft: leftBorderIndex\n            });\n            return leftBorderIndex;\n        }\n        case \"column\": {\n            let leftBorderIndex =\n                Math.max(...element.elements.map(addBorderIndexLeft), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexLeft>(element, {\n                borderIndexLeft: leftBorderIndex\n            });\n            return leftBorderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexRight = { borderIndexRight: number };\n\nexport function addBorderIndexRightG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexRight, E> {\n    return transformElements<N, BorderIndexRight, E>(graph, addBorderIndexRight);\n}\n\nexport function addBorderIndexRight(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexRight>(element, {\n                borderIndexRight: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexRight) :  [0];\n            let borderIndex = borderIndices[borderIndices.length - 1] + (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexRight>(element, {\n                borderIndexRight: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexRight), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexRight>(element, {\n                borderIndexRight: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexTop = { borderIndexTop: number };\n\nexport function addBorderIndexTopG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexTop, E> {\n    return transformElements<N, BorderIndexTop, E>(graph, addBorderIndexTop);\n}\n\nexport function addBorderIndexTop(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexTop>(element, {\n                borderIndexTop: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexTop), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexTop>(element, {\n                borderIndexTop: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexTop) :  [0];\n            let borderIndex = borderIndices[0] + (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexTop>(element, {\n                borderIndexTop: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexBottom = { borderIndexBottom: number };\n\nexport function addBorderIndexBottomG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexBottom, E> {\n    return transformElements<N, BorderIndexBottom, E>(graph, addBorderIndexBottom);\n}\n\nexport function addBorderIndexBottom(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexBottom>(element, {\n                borderIndexBottom: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexBottom), 0) +\n                (element.border ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexBottom>(element, {\n                borderIndexBottom: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexBottom) :  [0];\n            let borderIndex = borderIndices[borderIndices.length - 1] + (element.border ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexBottom>(element, {\n                borderIndexBottom: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {ascending} from \"../v1/sorting\";\n\nexport function sumOfPreviousRows(max: Map<number, number>): Map<number, number> {\n    let result = new Map<number, number>();\n\n    let sumOfPrevious = 0;\n    Array.from(max.entries()).sort(ascending(entry => entry[0])).forEach(entry => {\n        result.set(entry[0], sumOfPrevious);\n        sumOfPrevious += entry[1];\n    });\n\n    return result;\n}\n\nexport function sumOfPreviousRowsFillLayers(max: Map<number, number>, maxOffsetY: number): Map<number, number> {\n    let result = new Map<number, number>();\n\n    let sumOfPrevious = 0;\n    Array.from(Array(maxOffsetY + 1).keys()).forEach(layer => {\n        result.set(layer, sumOfPrevious);\n        sumOfPrevious += max.get(layer) || 0;\n    });\n\n    return result;\n}","import {Element} from \"./newGraphModel\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\n\nexport function getMostBottomOffsetElementsY(element: Element<OffsetElementsY>): number {\n    switch (element.kind) {\n        case \"node\":\n            return element.offsetElementsY;\n        case \"row\":\n        case \"column\":\n            return Math.max(...element.elements.map(getMostBottomOffsetElementsY), element.offsetElementsY);\n    }\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexBottom} from \"./BorderIndexBottom\";\nimport {OffsetElementsY} from \"./OffsetElementsY\";\nimport {sumOfPreviousRows} from \"../sumOfPreviousRows\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type BorderIndexMaxBottom = { borderIndexMaxBottom: number };\nexport type BorderIndexMaxPreviousBottom = { borderIndexMaxPreviousBottom: number };\nexport type EmbeddedBorderIndexMaxBottom = { embeddedBorderIndexMaxBottom: number };\n\nexport function addBorderIndexMaxBottomG<N extends OffsetElementsY & BorderIndexBottom, E>(\n    graph: Graph<N, E>\n): Graph<N & BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom, E> {\n    return transformElementsUsingGraph<N, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom, E>(\n        graph, determineAndAddBorderIndexBottomAggregates);\n}\n\nfunction determineAndAddBorderIndexBottomAggregates(graph: Graph<OffsetElementsY & BorderIndexBottom, unknown>) {\n    let max = determineBorderIndexMaxBottom(graph.element);\n    let sums = sumOfPreviousRows(max);\n    addBorderIndexMaxBottom(graph.element, max, sums);\n    graph.syntheticNodes.forEach(node => addBorderIndexMaxBottom(node, max, sums));\n}\n\nfunction determineBorderIndexMaxBottom(element: Element<OffsetElementsY & BorderIndexBottom>): Map<number, number> {\n    switch (element.kind) {\n        case \"node\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexBottom);\n            return map;\n        }\n        case \"row\":\n        case \"column\": {\n            let map = new Map<number, number>();\n            map.set(getMostBottomOffsetElementsY(element), element.borderIndexBottom);\n            return element.elements.map(determineBorderIndexMaxBottom).reduce((accumulator, addition) => {\n                Array.from(addition.entries()).forEach((entry) => {\n                    let max = Math.max(accumulator.get(entry[0]) || 0, entry[1]);\n                    accumulator.set(entry[0], max);\n                });\n                return accumulator;\n            }, map);\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction calculateEmbeddedBorders(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY;\n    let to = getMostBottomOffsetElementsY(element) - 1;\n    let embeddedBorders = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedBorders += current.get(i) || 0;\n    }\n    return embeddedBorders;\n}\n\nfunction addBorderIndexMaxBottom(\n    element: Element<OffsetElementsY & BorderIndexBottom>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(getMostBottomOffsetElementsY(element))!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxBottom(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(getMostBottomOffsetElementsY(element))!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxBottom(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexTop} from \"./BorderIndexTop\";\nimport {OffsetElementsY} from \"./OffsetElementsY\";\nimport {sumOfPreviousRows} from \"../sumOfPreviousRows\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type BorderIndexMaxTop = { borderIndexMaxTop: number };\nexport type BorderIndexMaxPreviousTop = { borderIndexMaxPreviousTop: number };\nexport type EmbeddedBorderIndexMaxTop = { embeddedBorderIndexMaxTop: number };\n\nexport function addBorderIndexMaxTopG<N extends OffsetElementsY & BorderIndexTop, E>(\n    graph: Graph<N, E>\n): Graph<N & BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop, E> {\n    return transformElementsUsingGraph<N, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop, E>(\n        graph, determineAndAddBorderIndexTopAggregates\n    );\n}\n\nfunction determineAndAddBorderIndexTopAggregates(graph: Graph<OffsetElementsY & BorderIndexTop, unknown>) {\n    let max = determineBorderIndexMaxTop(graph.element);\n    let sums = sumOfPreviousRows(max);\n    addBorderIndexMaxTop(graph.element, max, sums);\n    graph.syntheticNodes.forEach(node => addBorderIndexMaxTop(node, max, sums));\n}\n\nfunction determineBorderIndexMaxTop(element: Element<OffsetElementsY & BorderIndexTop>): Map<number, number> {\n    switch (element.kind) {\n        case \"node\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexTop);\n            return map;\n        }\n        case \"row\":\n        case \"column\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexTop);\n            return element.elements.map(determineBorderIndexMaxTop).reduce((accumulator, addition) => {\n                Array.from(addition.entries()).forEach(([offsetElementsY, borderIndexTop]) => {\n                    let max = Math.max(accumulator.get(offsetElementsY) || 0, borderIndexTop);\n                    accumulator.set(offsetElementsY, max);\n                });\n                return accumulator;\n            }, map);\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction calculateEmbeddedBorders(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY + 1;\n    let to = getMostBottomOffsetElementsY(element);\n    let embeddedBorders = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedBorders += current.get(i) || 0;\n    }\n    return embeddedBorders;\n}\n\nfunction addBorderIndexMaxTop(\n    element: Element<OffsetElementsY & BorderIndexTop>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxTop(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxTop(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type EmbeddedElementsY = { embeddedElementsY: number };\n\nexport function addEmbeddedElementsYG<N, E>(graph: Graph<N, E>): Graph<N & EmbeddedElementsY, E> {\n    return transformElements<N, EmbeddedElementsY, E>(graph, addEmbeddedElementsY);\n}\n\nexport function addEmbeddedElementsY(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, EmbeddedElementsY>(element, {\n                embeddedElementsY: 1\n            });\n            return 1;\n        }\n        case \"row\": {\n            let embeddedElementsY =\n                Math.max(...element.elements.map(addEmbeddedElementsY), 0);\n\n            Object.assign<Row<unknown>, EmbeddedElementsY>(element, {\n                embeddedElementsY: embeddedElementsY\n            });\n            return embeddedElementsY;\n        }\n        case \"column\": {\n            let embeddedElementsY =\n                element.elements.map(addEmbeddedElementsY).reduce((sum, add) => sum + add, 0);\n\n            Object.assign<Column<unknown>, EmbeddedElementsY>(element, {\n                embeddedElementsY: embeddedElementsY\n            });\n            return embeddedElementsY;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {Edge} from \"./newGraphModel\";\n\nexport function fromIsUpperLeft<N extends OffsetElementsX & OffsetElementsY, E>(edge: Edge<N, E>) {\n    if (edge.from.offsetElementsY === edge.to.offsetElementsY) {\n        return edge.from.offsetElementsX <= edge.to.offsetElementsX;\n    }\n    return edge.from.offsetElementsY < edge.to.offsetElementsY;\n}\n\nexport function getUpperLeftNode<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, unknown>): N {\n    return fromIsUpperLeft(edge) ? edge.from : edge.to;\n}\n\nexport function getLowerRightNode<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, unknown>): N {\n    return fromIsUpperLeft(edge) ? edge.to : edge.from;\n}\n\nexport function fromIsLeftUpper<N extends OffsetElementsX & OffsetElementsY, E>(edge: Edge<N, E>) {\n    if (edge.from.offsetElementsX === edge.to.offsetElementsX) {\n        return edge.from.offsetElementsY <= edge.to.offsetElementsY;\n    }\n    return edge.from.offsetElementsX < edge.to.offsetElementsX;\n}\n\nexport function getLeftUpperNode<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, unknown>): N {\n    return fromIsLeftUpper(edge) ? edge.from : edge.to;\n}","import React from \"react\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    BORDER_SPACING_X,\n    EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    HORIZONTAL_SPACING,\n    STROKE_WIDTH,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {BorderIndexMaxX} from \"./elementsLayout/BorderIndexMaxX\";\nimport {BorderIndexMaxPreviousTop, BorderIndexMaxTop} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexMaxBottom, BorderIndexMaxPreviousBottom} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {Edge} from \"./newGraphModel\";\nimport {getLeftUpperNode, getUpperLeftNode} from \"./EdgeHelper\";\nimport {MidPathSegmentOffsetY} from \"./edgesLayout/MidPathSegmentOffsetY\";\nimport {MidPathSegmentOffsetMaxPreviousY} from \"./edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {ConnectionIndex, NumberOfEdges} from \"./edgesLayout/ConnectionIndexAndNumberOfEdges\";\nimport {EdgeIndex} from \"./edgesLayout/EdgeIndex\";\nimport {IsLowerLayerEdge, LowerLayerEdge, OriginalEdge} from \"./edgesLayout/SyntheticNodesAndEdges\";\nimport {CrossLayerPathSegmentOffsetX} from \"./edgesLayout/CrossLayerPathSegmentOffsetX\";\nimport {CrossLayerPathSegmentOffsetMaxX} from \"./edgesLayout/CrossLayerPathSegmentOffsetMaxX\";\n\nfunction getY<N extends OffsetElementsY &\n    BorderIndexMaxTop & BorderIndexMaxPreviousTop & BorderIndexMaxPreviousBottom &\n    MidPathSegmentOffsetMaxPreviousY>(node: N) {\n    return node.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n        + (node.borderIndexMaxPreviousTop + node.borderIndexMaxTop) * BORDER_SPACING_TOP\n        + node.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n        + node.midPathSegmentOffsetMaxPreviousY * EDGE_SPACING;\n}\n\nfunction getX<N extends OffsetElementsX & BorderIndexMaxX & CrossLayerPathSegmentOffsetMaxX>(node: N) {\n    return node.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING)\n        + node.borderIndexMaxX * (node.offsetElementsX * 2 + 1) * BORDER_SPACING_X\n        + node.crossLayerPathSegmentOffsetMaxX * node.offsetElementsX * EDGE_SPACING;\n}\n\nfunction edgeEndCoordinates<N extends OffsetElementsX & OffsetElementsY &\n    CrossLayerPathSegmentOffsetMaxX &\n    BorderIndexMaxX & BorderIndexMaxTop & BorderIndexMaxPreviousTop & BorderIndexMaxPreviousBottom &\n    MidPathSegmentOffsetMaxPreviousY & NumberOfEdges>(\n    node: N, edgeIndex: number, otherNode: N\n) {\n    let onLowerSide = node.offsetElementsY <= otherNode.offsetElementsY;\n    let nodeCenteringOffset = (ELEMENT_WIDTH - (((onLowerSide ? node.lowerSideEdges : node.upperSideEdges) || 0) - 1) * EDGE_SPACING) / 2;\n    return {\n        x: getX(node) + nodeCenteringOffset + edgeIndex * EDGE_SPACING,\n        y: getY(node) + (onLowerSide ? ELEMENT_HEIGHT : 0)\n    };\n}\n\nexport const EdgeShape: React.FC<Edge<OffsetElementsX & OffsetElementsY &\n    CrossLayerPathSegmentOffsetMaxX &\n    BorderIndexMaxX & BorderIndexMaxTop & BorderIndexMaxPreviousTop & BorderIndexMaxPreviousBottom & BorderIndexMaxBottom &\n    MidPathSegmentOffsetMaxPreviousY & NumberOfEdges,\n    LowerLayerEdge<any, unknown> & EdgeIndex & MidPathSegmentOffsetY & ConnectionIndex & CrossLayerPathSegmentOffsetX>> = edge => {\n    let fromNode = edgeEndCoordinates(edge.from, edge.fromIndex, edge.to);\n    let upperNodeEdgesY = getY(getUpperLeftNode(edge))\n        + ELEMENT_HEIGHT\n        + getUpperLeftNode(edge).borderIndexMaxBottom * BORDER_SPACING_BOTTOM\n        + VERTICAL_SPACING / 2\n        + edge.midPathSegmentOffsetY * EDGE_SPACING;\n    let toNode = edgeEndCoordinates(edge.to, edge.toIndex, edge.from);\n    if (!edge.lowerLayerEdge) {\n        return (\n            <path key={edge.edgeIndex} d={\n                \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n                \"L \" + fromNode.x + \" \" + upperNodeEdgesY + \" \" +\n                \"L \" + toNode.x + \" \" + upperNodeEdgesY + \" \" +\n                \"L \" + toNode.x + \" \" + toNode.y\n            }\n                  stroke=\"black\"\n                  strokeWidth={STROKE_WIDTH}\n                  fill=\"none\"\n            />\n        );\n    } else {\n        let lowerLayerEdge = edge.lowerLayerEdge as Edge<unknown, MidPathSegmentOffsetY> & IsLowerLayerEdge & OriginalEdge<unknown, unknown>;\n        let lowerNodeEdgesY = getY(getUpperLeftNode(edge.lowerLayerEdge))\n            + ELEMENT_HEIGHT\n            + getUpperLeftNode(edge.lowerLayerEdge).borderIndexMaxBottom * BORDER_SPACING_BOTTOM\n            + VERTICAL_SPACING / 2\n            + lowerLayerEdge.midPathSegmentOffsetY * EDGE_SPACING;\n        let besideTopNodeX = getX(getLeftUpperNode(edge))\n            + ELEMENT_WIDTH + getUpperLeftNode(edge).borderIndexMaxX * BORDER_SPACING_X\n            + (edge.crossLayerPathSegmentOffsetX! + 1) * EDGE_SPACING;\n        return (\n            <path key={edge.edgeIndex} d={\n                \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n                \"L \" + fromNode.x + \" \" + upperNodeEdgesY + \" \" +\n                \"L \" + besideTopNodeX + \" \" + upperNodeEdgesY + \" \" +\n                \"L \" + besideTopNodeX + \" \" + lowerNodeEdgesY + \" \" +\n                \"L \" + toNode.x + \" \" + lowerNodeEdgesY + \" \" +\n                \"L \" + toNode.x + \" \" + toNode.y\n            }\n                  stroke=\"black\"\n                  strokeWidth={STROKE_WIDTH}\n                  fill=\"none\"\n            />\n        );\n    }\n};","import {ElementKey} from \"../elementsLayout/ElementKey\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {Edge, Graph} from \"../newGraphModel\";\nimport {and, ascending, descending} from \"../../v1/sorting\";\nimport {EdgeIndex} from \"./EdgeIndex\";\nimport {LowerLayerEdge} from \"./SyntheticNodesAndEdges\";\nimport {fromIsUpperLeft} from \"../EdgeHelper\";\n\nexport type ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\n\nexport type NumberOfEdges = {\n    upperSideEdges?: number\n    lowerSideEdges?: number\n}\n\nexport function addConnectionIndexAndNumberOfEdgesG<\n    N extends OffsetElementsY & OffsetElementsX & ElementKey,\n    E extends EdgeIndex & LowerLayerEdge<unknown, unknown>, G>(\n        graph: Graph<N, E>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    let edgesWithConnectionIndex = graph.edges as unknown as Edge<OffsetElementsX & OffsetElementsY, ConnectionIndex & LowerLayerEdge<unknown, unknown>>[];\n    copyConnectionIndexToLowerLayerEdge(edgesWithConnectionIndex);\n    return graph as Graph<N & NumberOfEdges, E & ConnectionIndex>;\n}\n\ntype EdgeType = Edge<OffsetElementsY & OffsetElementsX & ElementKey, EdgeIndex>\n\nexport function addConnectionIndexAndNumberOfEdges(edges: EdgeType[]) {\n    type NodeSide = {\n        node: OffsetElementsY & OffsetElementsX\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        edge: EdgeType\n        reverseNode: OffsetElementsY & OffsetElementsX\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(edge: EdgeType, firstNode: OffsetElementsY & OffsetElementsX & ElementKey, secondNode: OffsetElementsY & OffsetElementsX, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.offsetElementsY <= secondNode.offsetElementsY ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.elementKey + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            edge: edge,\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge, edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge, edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsY === node.offsetElementsY);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX <= node.offsetElementsX);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX > node.offsetElementsX);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsY !== node.offsetElementsY);\n        let otherLayerBefore = otherLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX <= node.offsetElementsX);\n        let otherLayerAfter = otherLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX > node.offsetElementsX);\n\n        before.sort(and(descending(e => e.reverseNode.offsetElementsX), descending(e => e.edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(e => e.reverseNode.offsetElementsX), descending(e => e.reverseNode.offsetElementsY)));\n        otherLayerAfter.sort(and(ascending(e => e.reverseNode.offsetElementsX), ascending(e => e.reverseNode.offsetElementsY)));\n        after.sort(and(descending(e => e.reverseNode.offsetElementsX), ascending(e => e.edge.edgeIndex)));\n\n        let all = before.concat(otherLayerBefore).concat(otherLayerAfter).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}\n\nfunction copyConnectionIndexToLowerLayerEdge(edges: Edge<OffsetElementsX & OffsetElementsY, ConnectionIndex & LowerLayerEdge<unknown, unknown>>[]) {\n    edges.forEach(edge => {\n        if (edge.lowerLayerEdge) {\n            Object.assign<Edge<unknown, unknown>, ConnectionIndex>(edge.lowerLayerEdge, {\n                fromIndex: 0,\n                toIndex: getLowerRightNodeIndex(edge)\n            });\n        }\n    });\n}\n\nexport function getUpperLeftNodeIndex<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, ConnectionIndex>): number {\n    return fromIsUpperLeft(edge) ? edge.fromIndex : edge.toIndex;\n}\n\nexport function getLowerRightNodeIndex<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, ConnectionIndex>): number {\n    return fromIsUpperLeft(edge) ? edge.toIndex : edge.fromIndex;\n}","import {Edge, Element, Graph, Node, node} from \"../newGraphModel\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {getLowerRightNode, getUpperLeftNode} from \"../EdgeHelper\";\nimport {ElementKey} from \"../elementsLayout/ElementKey\";\nimport {assertNever} from \"../assertNever\";\n\nexport type NodeData = OffsetElementsX & OffsetElementsY & ElementKey\n\nexport type IsLowerLayerEdge = {\n    isLowerLayerEdge: true\n};\n\nexport type OriginalEdge<N, E> = {\n    originalEdge: Edge<N, E>\n};\n\nexport type LowerLayerEdge<N, E> = {\n    lowerLayerEdge?: Edge<N, E> & IsLowerLayerEdge & OriginalEdge<N, E>\n}\n\nexport function isMultiLayerEdge(edge: Edge<OffsetElementsY, unknown>) {\n    return Math.abs(edge.from.offsetElementsY - edge.to.offsetElementsY) >= 2;\n}\n\nexport function addSyntheticNodesAndEdgesG(graph: Graph<NodeData, unknown>): Graph<NodeData, LowerLayerEdge<NodeData, unknown>> {\n    let elementKey = Math.max(...allElements(graph.element).map(element => element.elementKey));\n\n    let syntheticNodes: NodeData[] = [];\n    let syntheticEdges = graph.edges\n        .filter(isMultiLayerEdge)\n        .map(edge => {\n            let lowerRightNode = getLowerRightNode(edge);\n            let upperLeftNode = getUpperLeftNode(edge);\n            elementKey++;\n            let from: NodeData = Object.assign<Node, NodeData>(node(), {\n                elementKey: elementKey,\n                offsetElementsY: lowerRightNode.offsetElementsY - 1,\n                offsetElementsX: Math.min(upperLeftNode.offsetElementsX, lowerRightNode.offsetElementsX)\n            });\n            syntheticNodes.push(from);\n            let lowerLayerEdgeProperty: LowerLayerEdge<NodeData, unknown> = {\n                lowerLayerEdge: {\n                    from: from,\n                    to: lowerRightNode,\n                    isLowerLayerEdge: true,\n                    originalEdge: edge\n                }};\n            Object.assign<Edge<NodeData, unknown>, LowerLayerEdge<NodeData, unknown>>(\n                edge, lowerLayerEdgeProperty);\n            return lowerLayerEdgeProperty.lowerLayerEdge;\n        });\n\n    return Object.assign(graph, {syntheticNodes, syntheticEdges});\n}\n\nfunction allElements<N>(element: Element<N>): Element<N>[] {\n    switch (element.kind) {\n        case \"node\": return [element];\n        case \"row\": return element.elements.flatMap(allElements).concat(element);\n        case \"column\": return element.elements.flatMap(allElements).concat(element);\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {and, ascending, descending} from \"../../v1/sorting\";\nimport {Edge, Graph} from \"../newGraphModel\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {getLowerRightNode, getUpperLeftNode} from \"../EdgeHelper\";\nimport {\n    ConnectionIndex,\n    getLowerRightNodeIndex,\n    getUpperLeftNodeIndex,\n    NumberOfEdges\n} from \"./ConnectionIndexAndNumberOfEdges\";\nimport {EdgeIndex} from \"./EdgeIndex\";\nimport {IsLowerLayerEdge, isMultiLayerEdge, OriginalEdge} from \"./SyntheticNodesAndEdges\";\n\nexport type MidPathSegmentOffsetY = {\n    midPathSegmentOffsetY: number\n}\n\nexport function addMidPathSegmentOffsetYG<N extends OffsetElementsY & OffsetElementsX & NumberOfEdges, E extends ConnectionIndex & EdgeIndex>(graph: Graph<N, E>):\n    Graph<N, E & MidPathSegmentOffsetY> {\n    addMidPathSegmentOffsetY(graph.edges.concat(graph.syntheticEdges));\n    return graph as unknown as Graph<N, E & MidPathSegmentOffsetY>;\n}\n\nexport function addMidPathSegmentOffsetY(edges: Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, ConnectionIndex & EdgeIndex>[]) {\n    let groupedByOffsetElementsY = new Map<number, (Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, ConnectionIndex & EdgeIndex>)[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperLeftNode(edge).offsetElementsY;\n        let edges = groupedByOffsetElementsY.get(key) || [];\n        edges.push(edge);\n        groupedByOffsetElementsY.set(key, edges);\n    });\n\n    Array.from(groupedByOffsetElementsY.values()).forEach(addMidPathSegmentOffsetYForLayer);\n}\n\nfunction addMidPathSegmentOffsetYForLayer(edges: Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, EdgeIndex & ConnectionIndex>[]) {\n    let groupedByUpperNode = new Map<string, Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, EdgeIndex & ConnectionIndex>[]>();\n\n    edges.forEach(edge => {\n        let upperLeftNode = getUpperLeftNode(edge);\n        let key = upperLeftNode.offsetElementsY + \"_\" + upperLeftNode.offsetElementsX;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerRightNode(edge).offsetElementsY === getUpperLeftNode(edge).offsetElementsY);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerRightNode(edge).offsetElementsX <= getUpperLeftNode(edge).offsetElementsX);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerRightNode(edge).offsetElementsX > getUpperLeftNode(edge).offsetElementsX);\n        let otherLayer = edges.filter(edge => getLowerRightNode(edge).offsetElementsY !== getUpperLeftNode(edge).offsetElementsY);\n        let otherLayerBefore = otherLayer.filter(edge => {\n            if (getLowerRightNode(edge).offsetElementsX === getUpperLeftNode(edge).offsetElementsX) {\n                if (isMultiLayerEdge(edge)) return false;\n                if ((edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return false;\n\n                return getLowerRightNodeIndex(edge) - ((getLowerRightNode(edge).upperSideEdges || 1) - 1) / 2 <\n                    getUpperLeftNodeIndex(edge) - ((getUpperLeftNode(edge).lowerSideEdges || 1) - 1) / 2;\n            }\n            return getLowerRightNode(edge).offsetElementsX <= getUpperLeftNode(edge).offsetElementsX\n        });\n        let otherLayerAfter = otherLayer.filter(edge => {\n            if (getLowerRightNode(edge).offsetElementsX === getUpperLeftNode(edge).offsetElementsX) {\n                if (isMultiLayerEdge(edge)) return true;\n                if ((edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return true;\n\n                return getLowerRightNodeIndex(edge) - ((getLowerRightNode(edge).upperSideEdges || 1) - 1) / 2 >=\n                    getUpperLeftNodeIndex(edge) - ((getUpperLeftNode(edge).lowerSideEdges || 1) - 1) / 2;\n            }\n            return getLowerRightNode(edge).offsetElementsX > getUpperLeftNode(edge).offsetElementsX\n        });\n\n        sameLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), descending(edge => edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), ascending(edge => edge.edgeIndex)));\n        otherLayerAfter.sort(and(\n            descending(edge => getLowerRightNode(edge).offsetElementsX),\n            ascending(edge => {\n                if (!(edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return 0;\n                let edgeWithOriginalEdge = edge as unknown as OriginalEdge<OffsetElementsX & OffsetElementsY, EdgeIndex>;\n                return getUpperLeftNode(edgeWithOriginalEdge.originalEdge).offsetElementsX;\n            }),\n            ascending(edge => {\n                if (!(edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return 0;\n                let edgeWithOriginalEdge = edge as unknown as OriginalEdge<OffsetElementsX & OffsetElementsY, EdgeIndex>;\n                return edgeWithOriginalEdge.originalEdge.edgeIndex;\n            }),\n            descending(edge => edge.edgeIndex)\n        ));\n        sameLayerAfter.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), descending(edge => edge.edgeIndex)));\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<OffsetElementsY & OffsetElementsX, unknown>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let index = indexOffset + indexInArray;\n            Object.assign<Edge<OffsetElementsY & OffsetElementsX, unknown>, MidPathSegmentOffsetY>(edge, {\n                midPathSegmentOffsetY: index\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type ElementKey = { elementKey: number };\n\nexport function addElementKeyG<N, E>(graph: Graph<N, E>): Graph<N & ElementKey, E> {\n    return transformElements<N, ElementKey, E>(graph, addElementKey);\n}\n\nexport function addElementKey(\n    element: Element<unknown>,\n    accumulator: { elementKey: number } = { elementKey: 0 }) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, ElementKey>(element, {\n                elementKey: accumulator.elementKey\n            });\n            accumulator.elementKey++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, ElementKey>(element, {\n                elementKey: accumulator.elementKey\n            });\n            accumulator.elementKey++;\n            element.elements.forEach(nestedElement => addElementKey(nestedElement, accumulator));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, ElementKey>(element, {\n                elementKey: accumulator.elementKey\n            });\n            accumulator.elementKey++;\n            element.elements.forEach(nestedElement => addElementKey(nestedElement, accumulator));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Edge, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {getUpperLeftNode} from \"../EdgeHelper\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {MidPathSegmentOffsetY} from \"./MidPathSegmentOffsetY\";\nimport {sumOfPreviousRowsFillLayers} from \"../sumOfPreviousRows\";\nimport {assertNever} from \"../assertNever\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type NodeData = OffsetElementsX & OffsetElementsY\nexport type EdgeData = MidPathSegmentOffsetY\ntype EdgeType = Edge<NodeData, EdgeData>\nexport type AddedNodeData = MidPathSegmentOffsetMaxPreviousY & EmbeddedMidPathSegmentY\n\nexport type MidPathSegmentOffsetMaxPreviousY = {\n    midPathSegmentOffsetMaxPreviousY: number\n}\n\nexport type EmbeddedMidPathSegmentY = { embeddedMidPathSegmentY: number };\n\nexport function addMidPathSegmentOffsetYAggregatesG<N extends NodeData, E extends EdgeData>(\n    graph: Graph<N, E>\n): Graph<N & AddedNodeData, E> {\n    return transformElementsUsingGraph<N, AddedNodeData, E>(graph, addMidPathSegmentOffsetYAggregates);\n}\n\nexport function addMidPathSegmentOffsetYAggregates<N extends NodeData, E extends EdgeData>(graph: Graph<N, E>) {\n    let maxOffsetY = determineMaxOffsetY(graph.element);\n    let maxs = determineMidPathSegmentMaxOffsetY(graph.edges.concat(graph.syntheticEdges));\n    let sums = sumOfPreviousRowsFillLayers(maxs, maxOffsetY);\n    applyMidPathSegmentOffsetYAggregates(graph.element, maxs, sums);\n    graph.syntheticNodes.forEach(node => applyMidPathSegmentOffsetYAggregates(node, maxs, sums));\n}\n\nfunction determineMaxOffsetY(element: Element<OffsetElementsY>): number {\n    switch (element.kind) {\n        case \"node\": return element.offsetElementsY;\n        case \"column\":\n        case \"row\":\n            return Math.max(...element.elements.map(determineMaxOffsetY));\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction determineMidPathSegmentMaxOffsetY(edges: EdgeType[]): Map<number, number> {\n    let result = new Map<number, number>();\n    edges.forEach(edge => {\n        let offsetElementsY = getUpperLeftNode(edge).offsetElementsY;\n        let midPathSegmentOffsetY = result.get(offsetElementsY) || 0;\n        result.set(offsetElementsY, Math.max(midPathSegmentOffsetY, edge.midPathSegmentOffsetY));\n    });\n    return result;\n}\n\nfunction calculateEmbeddedPaths(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY;\n    let to = getMostBottomOffsetElementsY(element) - 1;\n    let embeddedPaths = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedPaths += current.get(i) || 0;\n    }\n    return embeddedPaths;\n}\n\nfunction applyMidPathSegmentOffsetYAggregates<N extends NodeData, E extends EdgeData>(\n    element: Element<N>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, AddedNodeData>(element, {\n                midPathSegmentOffsetMaxPreviousY: sums.get(element.offsetElementsY) || 0,\n                embeddedMidPathSegmentY: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, AddedNodeData>(element, {\n                midPathSegmentOffsetMaxPreviousY: sums.get(element.offsetElementsY) || 0,\n                embeddedMidPathSegmentY: calculateEmbeddedPaths(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                applyMidPathSegmentOffsetYAggregates(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, AddedNodeData>(element, {\n                midPathSegmentOffsetMaxPreviousY: sums.get(element.offsetElementsY) || 0,\n                embeddedMidPathSegmentY: calculateEmbeddedPaths(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                applyMidPathSegmentOffsetYAggregates(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Edge, Graph} from \"../newGraphModel\";\n\nexport type EdgeIndex = {\n    edgeIndex: number\n}\n\nexport function addEdgeIndexG<N, E>(graph: Graph<N, E>):\n    Graph<N, E & EdgeIndex> {\n    addEdgeIndex(graph.edges.concat(graph.syntheticEdges));\n    return graph as unknown as Graph<N, E & EdgeIndex>;\n}\n\nexport function addEdgeIndex(edges: Edge<unknown, unknown>[]) {\n    edges.forEach((edge, index) => {\n        Object.assign<Edge<unknown, unknown>, EdgeIndex>(\n            edge, {edgeIndex: index});\n    });\n}","import {Edge, Graph} from \"../newGraphModel\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {LowerLayerEdge} from \"./SyntheticNodesAndEdges\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {EdgeIndex} from \"./EdgeIndex\";\nimport {getLeftUpperNode, getLowerRightNode} from \"../EdgeHelper\";\nimport {and, ascending} from \"../../v1/sorting\";\n\nexport type CrossLayerPathSegmentOffsetX = {\n    crossLayerPathSegmentOffsetX?: number\n}\n\nexport type RequiredNodeDataTypes = OffsetElementsX & OffsetElementsY\nexport type RequiredEdgeDataTypes = EdgeIndex & LowerLayerEdge<unknown, unknown>\nexport type RequiredEdgeType = Edge<RequiredNodeDataTypes, RequiredEdgeDataTypes>\n\nexport function addCrossLayerPathSegmentOffsetXG<N extends RequiredNodeDataTypes, E extends RequiredEdgeDataTypes>(graph: Graph<N, E>):\n    Graph<N, E & CrossLayerPathSegmentOffsetX> {\n    addCrossLayerPathSegmentOffsetX(graph.edges);\n    return graph as unknown as Graph<N, E & CrossLayerPathSegmentOffsetX>;\n}\n\nexport function addCrossLayerPathSegmentOffsetX(edges: RequiredEdgeType[]) {\n    let groupedByOffsetElementsX = new Map<number, RequiredEdgeType[]>();\n\n    edges.filter(edge => edge.lowerLayerEdge).forEach(edge => {\n        let key = getLeftUpperNode(edge).offsetElementsX;\n        let edges = groupedByOffsetElementsX.get(key) || [];\n        edges.push(edge);\n        groupedByOffsetElementsX.set(key, edges);\n    });\n\n    Array.from(groupedByOffsetElementsX.values()).forEach(addCrossLayerPathSegmentOffsetXForSlice);\n}\n\nfunction addCrossLayerPathSegmentOffsetXForSlice(edges: RequiredEdgeType[]) {\n    let groupedByUpperNode = new Map<string, RequiredEdgeType[]>();\n\n    edges.forEach(edge => {\n        let upperLeftNode = getLeftUpperNode(edge);\n        let key = upperLeftNode.offsetElementsY + \"_\" + upperLeftNode.offsetElementsX;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        edges.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), ascending(edge => edge.edgeIndex)));\n\n        function addOffset(edge: RequiredEdgeType, indexInArray: number) {\n            let index = indexOffset + indexInArray;\n            Object.assign<RequiredEdgeType, CrossLayerPathSegmentOffsetX>(edge, {\n                crossLayerPathSegmentOffsetX: index\n            });\n        }\n\n        edges.forEach((edge, index) => addOffset(edge, index));\n\n        indexOffset += edges.length;\n    });\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {CrossLayerPathSegmentOffsetX} from \"./CrossLayerPathSegmentOffsetX\";\n\nexport type CrossLayerPathSegmentOffsetMaxX = { crossLayerPathSegmentOffsetMaxX: number };\n\ntype RequiredEdgeDataTypes = CrossLayerPathSegmentOffsetX;\n\nexport function addCrossLayerPathSegmentOffsetMaxXG<N, E extends RequiredEdgeDataTypes>(\n    graph: Graph<N, E>\n): Graph<N & CrossLayerPathSegmentOffsetMaxX, E> {\n    return transformElementsUsingGraph<N, CrossLayerPathSegmentOffsetMaxX, E>(graph, determineAndAddCrossLayerPathSegmentOffsetMaxX);\n}\n\nfunction determineAndAddCrossLayerPathSegmentOffsetMaxX(graph: Graph<unknown, RequiredEdgeDataTypes>) {\n    let crossLayerPathSegmentOffsetMaxX = determineCrossLayerPathSegmentOffsetMaxX(graph.edges);\n    addCrossLayerPathSegmentOffsetMaxX(graph.element, crossLayerPathSegmentOffsetMaxX);\n}\n\nfunction determineCrossLayerPathSegmentOffsetMaxX(edges: RequiredEdgeDataTypes[]): number {\n    return Math.max(...edges.map(edge => (edge.crossLayerPathSegmentOffsetX || 0) + 1), 0);\n}\n\nexport function addCrossLayerPathSegmentOffsetMaxX(element: Element<unknown>, crossLayerPathSegmentOffsetMaxX: number) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, CrossLayerPathSegmentOffsetMaxX>(element, {\n                crossLayerPathSegmentOffsetMaxX: crossLayerPathSegmentOffsetMaxX\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, CrossLayerPathSegmentOffsetMaxX>(element, {\n                crossLayerPathSegmentOffsetMaxX: crossLayerPathSegmentOffsetMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addCrossLayerPathSegmentOffsetMaxX(nestedElement, crossLayerPathSegmentOffsetMaxX));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, CrossLayerPathSegmentOffsetMaxX>(element, {\n                crossLayerPathSegmentOffsetMaxX: crossLayerPathSegmentOffsetMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addCrossLayerPathSegmentOffsetMaxX(nestedElement, crossLayerPathSegmentOffsetMaxX));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import React from \"react\";\nimport {Container, Element, Graph, Node} from \"./newGraphModel\";\nimport {NodeShape} from \"./NodeShape\";\nimport {assertNever} from \"./assertNever\";\nimport {addOffsetElementsYG} from \"./elementsLayout/OffsetElementsY\";\nimport {addOffsetElementsXG} from \"./elementsLayout/OffsetElementsX\";\nimport {addEmbeddedElementsXG} from \"./elementsLayout/EmbeddedElementsX\";\nimport {ContainerShape} from \"./ContainerShape\";\nimport {addBorderIndexMaxXG} from \"./elementsLayout/BorderIndexMaxX\";\nimport {addBorderIndexLeftG} from \"./elementsLayout/BorderIndexLeft\";\nimport {addBorderIndexRightG} from \"./elementsLayout/BorderIndexRight\";\nimport {addBorderIndexTopG} from \"./elementsLayout/BorderIndexTop\";\nimport {addBorderIndexBottomG} from \"./elementsLayout/BorderIndexBottom\";\nimport {addBorderIndexMaxBottomG} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {addBorderIndexMaxTopG} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {addEmbeddedElementsYG} from \"./elementsLayout/EmbeddedElementsY\";\nimport {EdgeShape} from \"./EdgeShape\";\nimport {addMidPathSegmentOffsetYG} from \"./edgesLayout/MidPathSegmentOffsetY\";\nimport {addElementKeyG} from \"./elementsLayout/ElementKey\";\nimport {addMidPathSegmentOffsetYAggregatesG} from \"./edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {addConnectionIndexAndNumberOfEdgesG} from \"./edgesLayout/ConnectionIndexAndNumberOfEdges\";\nimport {addEdgeIndexG} from \"./edgesLayout/EdgeIndex\";\nimport {addSyntheticNodesAndEdgesG} from \"./edgesLayout/SyntheticNodesAndEdges\";\nimport {addCrossLayerPathSegmentOffsetXG} from \"./edgesLayout/CrossLayerPathSegmentOffsetX\";\nimport {addCrossLayerPathSegmentOffsetMaxXG} from \"./edgesLayout/CrossLayerPathSegmentOffsetMaxX\";\n\nfunction allNodes<N>(element: Element<N>): (Node & N)[] {\n    switch (element.kind) {\n        case \"node\": return [element];\n        case \"row\": return element.elements.flatMap(allNodes);\n        case \"column\": return element.elements.flatMap(allNodes);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction allContainers<N>(element: Element<N>): Container<N>[] {\n    switch (element.kind) {\n        case \"node\": return [];\n        case \"row\": return element.elements.flatMap(allContainers).concat(element);\n        case \"column\": return element.elements.flatMap(allContainers).concat(element);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\ntype DiagramProps = { graph: Graph<unknown, unknown> }\n\nexport const Diagram: React.FC<DiagramProps> = props => {\n    return [props.graph]\n        .map(addElementKeyG)\n        .map(addOffsetElementsXG)\n        .map(addOffsetElementsYG)\n        .map(addSyntheticNodesAndEdgesG)\n        .map(addBorderIndexLeftG)\n        .map(addBorderIndexRightG)\n        .map(addBorderIndexTopG)\n        .map(addBorderIndexBottomG)\n        .map(addBorderIndexMaxXG)\n        .map(addBorderIndexMaxTopG)\n        .map(addBorderIndexMaxBottomG)\n        .map(addEmbeddedElementsXG)\n        .map(addEmbeddedElementsYG)\n        .map(addEdgeIndexG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(addMidPathSegmentOffsetYG)\n        .map(addMidPathSegmentOffsetYAggregatesG)\n        .map(addCrossLayerPathSegmentOffsetXG)\n        .map(addCrossLayerPathSegmentOffsetMaxXG)\n        .map(graph => {\n            console.log(graph.edges);\n            console.log(graph.syntheticEdges);\n            return (\n                <svg viewBox={\"0 0 1600 850\"}>\n                    {allNodes(graph.element).map(NodeShape)}\n                    {allContainers(graph.element).filter(c => c.border).map(ContainerShape)}\n                    {graph.edges.map(EdgeShape)}\n                </svg>\n            );\n        })[0];\n};","import React from \"react\";\nimport {edge, Element, graph, node} from \"./newGraphModel\";\nimport {Diagram} from \"./Diagram\";\n\nexport const Sample: React.FC = () => {\n    let node_1_1 = node();\n    let node_1_2 = node();\n    let node_2_1 = node();\n    let node_2_2 = node();\n    let node_3_1 = node();\n    let node_3_2 = node();\n    let node_4_1 = node();\n    let node_4_2 = node();\n    let node_4_3 = node();\n    let node_4_4 = node();\n    let node_4_5 = node();\n    let node_5_1 = node();\n    let node_5_2 = node();\n    let node_6_1 = node();\n    let node_6_2 = node();\n    let node_6_3 = node();\n    let node_6_4 = node();\n    let element: Element<unknown> = {\n        kind: \"column\", elements: [{\n            kind: \"row\", border: \"solid\", elements: [{\n                kind: \"column\", border: \"solid\", elements: [node_1_1, node_1_2]\n            }, {\n                kind: \"column\", border: \"solid\", elements: [{\n                    kind: \"row\", border: \"solid\", elements: [node_2_1, node_2_2]\n                }, node_3_1, node_3_2]\n            }]\n        }, {\n            kind: \"row\", elements: [node_4_1, node_4_2, node_4_3, node_4_4, node_4_5]\n        }, {\n            kind: \"row\", border: \"solid\", elements: [{\n                kind: \"row\", border: \"solid\", elements: [node_5_1, node_5_2]\n            }, {\n                kind: \"row\", border: \"solid\", elements: [node_6_1, node_6_2, node_6_3, node_6_4]\n            }]\n        }]\n    };\n    let edges = [\n        edge(node_1_1, node_4_1),\n        edge(node_1_1, node_1_2),\n        edge(node_2_1, node_1_1),\n        edge(node_2_1, node_1_1),\n        edge(node_2_1, node_2_2),\n        edge(node_2_1, node_2_2),\n        edge(node_2_1, node_4_1),\n        edge(node_2_1, node_4_1),\n        edge(node_2_1, node_4_3),\n        edge(node_2_1, node_4_3),\n        edge(node_2_1, node_4_4),\n        edge(node_2_2, node_4_4),\n        edge(node_2_2, node_4_2),\n        edge(node_3_2, node_4_1),\n        edge(node_3_2, node_4_1),\n        edge(node_3_2, node_4_3),\n        edge(node_3_2, node_4_4),\n        edge(node_3_2, node_4_5),\n        edge(node_3_2, node_4_5),\n        edge(node_4_1, node_4_2),\n        edge(node_5_1, node_4_2),\n        edge(node_5_2, node_4_2),\n        edge(node_6_1, node_4_2),\n        edge(node_6_2, node_4_2),\n        edge(node_6_3, node_4_2),\n        edge(node_6_3, node_4_2),\n        edge(node_6_4, node_4_2),\n        edge(node_5_1, node_4_5),\n        edge(node_5_2, node_4_5),\n        edge(node_6_1, node_4_5),\n        edge(node_6_2, node_4_5),\n        edge(node_6_3, node_4_5),\n        edge(node_6_4, node_4_5),\n        edge(node_6_4, node_6_3)\n    ];\n    return (\n        <Diagram graph={graph(element, edges)}/>\n    );\n};","import React from 'react';\nimport {HashRouter as Router, Link, Route, Switch} from \"react-router-dom\";\nimport {Editor} from \"./v1/Editor\";\nimport {Architecture} from \"./v1/Architecture\";\nimport {Sample} from \"./v2/Sample\";\n\nconst App: React.FC = () => {\n    return (\n        <Router>\n            <div>\n                <ul>\n                    <li>\n                        <Link to=\"/\">Editor</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/architecture\">Sample Architecture</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/new-layouting\">New Layouting</Link>\n                    </li>\n                </ul>\n\n                <hr/>\n\n                <Switch>\n                    <Route exact path=\"/\">\n                        <Editor/>\n                    </Route>\n                    <Route path=\"/architecture\">\n                        <Architecture/>\n                    </Route>\n                    <Route path=\"/new-layouting\">\n                        <Sample/>\n                    </Route>\n                </Switch>\n            </div>\n        </Router>\n    );\n};\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import {Edge, Stack} from \"./graphModel\";\n\nexport type IndexPair = {\n    from: number[]\n    to: number[]\n}\n\nfunction indexToReference<N, G>(stack: Stack<N, G>, index: number[]): any {\n    // It is necessary to go through the array by index,\n    // because the array operations `every`, `map` and `flat` bypass empty array elements.\n    for (let i = 0; i < index.length; i++) {\n        if (index[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n    }\n\n    let element: any = stack;\n    index.forEach(i => {\n        if (element.elements[i] === undefined)\n            throw new Error(\"Indices must refer to a node that does exist. Index \" + i  + \" Array length \" + element.elements.length);\n        element = element.elements[i];\n    });\n    return element;\n}\n\nfunction indexPairToReference<N, G>(stack: Stack<N, G>, indexPair: IndexPair): Edge<N> {\n    return {\n        from: indexToReference(stack, indexPair.from),\n        to: indexToReference(stack, indexPair.to)\n    };\n}\n\nexport function indicesToReferences<N, G>(stack: Stack<N, G>, indexPairs: IndexPair[]): Edge<N>[] {\n    return indexPairs.map(indexPair => indexPairToReference(stack, indexPair));\n}","import {Group, Layer, Node, Stack} from \"./graphModel\";\n\nfunction convertStringsToNodes(\n    element: string | Node | Group<string | Node, unknown> | Layer<Node, unknown> | Stack<Node, unknown>\n): Node | Group<Node, unknown> | Layer<Node, unknown> | Stack<Node, unknown> {\n    if (typeof element === 'string') {\n        return {\n            kind: 'node',\n            name: element\n        }\n    } else if (\"elements\" in element) {\n        // It is necessary to go through the array by index,\n        // because the array operations `every`, `map` and `flat` bypass empty array elements.\n        for (let i = 0; i < element.elements.length; i++) {\n            if (element.elements[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n        }\n        if (\"name\" in element) {\n            return {\n                kind: \"group\",\n                name: element.name,\n                elements: element.elements.map(convertStringsToNodes) as (Group<Node, unknown> | Node)[]\n            }\n        }\n        switch (element.kind) {\n            default:\n            case \"stack\":  {\n                return {\n                    kind: element.kind,\n                    elements: element.elements.map(convertStringsToNodes) as Layer<Node, unknown>[]\n                }\n            }\n            case \"layer\": {\n                return {\n                    kind: element.kind,\n                    elements: element.elements.map(convertStringsToNodes) as (Node | Group<Node, unknown> | Stack<Node, unknown>)[]\n                }\n            }\n        }\n    } else {\n        return Object.assign(element, {\n            kind: 'node'\n        });\n    }\n}\n\nexport function stringsToNodes(\n    strings: (string | Node | Group<string | Node, unknown> | Stack<Node, unknown>)[][]\n): Stack<Node, unknown> {\n    return {\n        kind: 'stack',\n        elements: strings.map(layer => {\n            return {\n                kind: 'layer',\n                elements: layer.map(convertStringsToNodes) as (Node | Group<Node, unknown> | Stack<Node, unknown>)[]\n            }\n        })\n    };\n}","export const MARGIN_TOP = 5;\nexport const MARGIN_SIDE = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const SYMBOL_WIDTH = 12;\nexport const SYMBOL_SPACING = 3;\nexport const GROUP_MARGIN_TOP = 30;\nexport const GROUP_MARGIN_BOTTOM = 10;\nexport const GROUP_MARGIN_SIDE = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const TEXT_PADDING = 5;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;","import {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING} from \"./styling\";\nimport {Group, Layer, Node, Stack} from \"./graphModel\";\n\nexport function width(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return Math.max(...element.elements.map(width));\n        case \"layer\":\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"group\": {\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0) + 2 * GROUP_MARGIN_SIDE;\n        }\n        case \"node\":\n            return ELEMENT_WIDTH * (element.size || 1);\n    }\n}","import {width} from \"./width\";\nimport {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING, MARGIN_SIDE} from \"./styling\";\nimport {Graph, Group, Layer, Node, Stack, X} from \"./graphModel\";\n\nexport function addXToNodeG<N extends Node, E, G>(\n    graph: Graph<N, E, G>\n): Graph<N & X, E, G & X> {\n    addXToNode(graph.stack, {x: MARGIN_SIDE});\n    return graph as unknown as Graph<N & X, E, G & X>;\n}\n\nexport function addXToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { x: number },\n    fullWidth: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let fullWidth = width(element);\n            element.elements.forEach(layer => {\n                addXToNode(layer, accumulator, fullWidth);\n            });\n            accumulator.x += fullWidth + HORIZONTAL_SPACING;\n            return;\n        }\n        case \"layer\": {\n            let oldX = accumulator.x;\n            accumulator.x = oldX + (fullWidth - width(element)) / 2;\n            element.elements.forEach(group => {\n                addXToNode(group, accumulator, fullWidth);\n            });\n            accumulator.x = oldX;\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n\n            accumulator.x += GROUP_MARGIN_SIDE;\n            element.elements.forEach(node => {\n                addXToNode(node, accumulator, fullWidth);\n            });\n            accumulator.x += GROUP_MARGIN_SIDE;\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n            accumulator.x += ELEMENT_WIDTH * (element.size || 1) + HORIZONTAL_SPACING;\n            return;\n        }\n    }\n}","export type X = {\n    x: number\n}\nexport type Y = {\n    y: number\n}\nexport type Height = {\n    height: number\n}\nexport type LayerDimensions = {\n    belowLayerY: number\n}\nexport type LayerIndex = {\n    layerIndex: number\n}\nexport type Index = {\n    index: number\n}\nexport type Key = {\n    key: string\n}\nexport type LayerPosition = LayerIndex & Index & Key\ntype Symbols = \"component\"\nexport type Node = {\n    kind: 'node'\n    name: string\n    symbol?: Symbols\n    size?: number\n    isPlaceholder?: boolean\n}\nexport type Edge<T> = {\n    from: T\n    to: T\n}\nexport type EdgeIndex = {\n    edgeIndex: number\n}\nexport type ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\nexport type NumberOfEdges = {\n    upperSideEdges: number\n    lowerSideEdges: number\n}\nexport type Group<N, G> = {\n    kind: 'group'\n    name: string\n    elements: ((Group<N, G> & G) | N)[]\n}\nexport type Layer<N, G> = {\n    kind: 'layer'\n    elements: ((Group<N, G> & G) | Stack<N, G> | N)[]\n}\nexport type Stack<N, G> = {\n    kind: 'stack'\n    elements: Layer<N, G>[]\n}\nexport type Graph<N, E, G> = {\n    stack: Stack<N, G>\n    edges: (Edge<N> & E)[]\n}\n\nfunction fromIsUpperLeft<T extends LayerIndex & X>(edge: Edge<T>) {\n    if (edge.from.layerIndex === edge.to.layerIndex) {\n        return edge.from.x <= edge.to.x;\n    }\n    return edge.from.layerIndex < edge.to.layerIndex;\n}\n\nexport function getUpperLeftNode<T extends LayerIndex & X>(edge: Edge<T>): T {\n    return fromIsUpperLeft(edge) ? edge.from : edge.to;\n}\n\nexport function getLowerRightNode<T extends LayerIndex & X>(edge: Edge<T>): T {\n    return fromIsUpperLeft(edge) ? edge.to : edge.from;\n}","import {and, ascending, descending} from \"./sorting\";\nimport {Edge, EdgeIndex, getLowerRightNode, getUpperLeftNode, Graph, Key, LayerIndex, LayerPosition, X} from \"./graphModel\";\n\nexport function addLayerPositionToEdgeG<N extends LayerIndex & X & Key, E, G>(graph: Graph<N, E, G>):\n    Graph<N, E & LayerPosition, G> {\n    addLayerPositionToEdge(graph.edges);\n    return graph as unknown as Graph<N, E & LayerPosition, G>;\n}\n\nexport function addLayerPositionToEdge(edges: Edge<LayerIndex & X & Key>[]) {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerIndex & X & Key> & EdgeIndex)[]>();\n\n    edges\n        .map((edge, index) => Object.assign(edge, {edgeIndex: index}))\n        .forEach(edge => {\n            let key = getUpperLeftNode(edge).layerIndex;\n            let edges = groupedByLayerIndex.get(key) || [];\n            edges.push(edge);\n            groupedByLayerIndex.set(key, edges);\n        });\n\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\n}\n\nfunction addLayerPositionToEdgeForLayer(edges: (Edge<LayerIndex & X & Key> & EdgeIndex)[]) {\n    let groupedByUpperNode = new Map<string, (Edge<LayerIndex & X & Key> & EdgeIndex)[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperLeftNode(edge).key;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerRightNode(edge).layerIndex === getUpperLeftNode(edge).layerIndex);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerRightNode(edge).x <= getUpperLeftNode(edge).x);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerRightNode(edge).x > getUpperLeftNode(edge).x);\n        let otherLayer = edges.filter(edge => getLowerRightNode(edge).layerIndex !== getUpperLeftNode(edge).layerIndex);\n        let otherLayerBefore = otherLayer.filter(edge => getLowerRightNode(edge).x <= getUpperLeftNode(edge).x);\n        let otherLayerAfter = otherLayer.filter(edge => getLowerRightNode(edge).x > getUpperLeftNode(edge).x);\n\n        sameLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n        otherLayerAfter.sort(and(descending(edge => getLowerRightNode(edge).x), descending(edge => edge.edgeIndex)));\n        sameLayerAfter.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<LayerIndex & X>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let layerIndex = getUpperLeftNode(edge).layerIndex;\n            let index = indexOffset + indexInArray;\n            Object.assign(edge, {\n                key: nodeKey + \"_\" + beforeOrAfter + \"_\" + index,\n                index: index,\n                layerIndex: layerIndex\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}","import {EDGE_SPACING} from \"./styling\";\nimport {Edge, getUpperLeftNode, LayerIndex, LayerPosition, X} from \"./graphModel\";\n\nexport function heightOfEdges(edges: (Edge<LayerIndex & X> & LayerPosition)[], numberOfLayers: number): number[] {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerIndex & X> & LayerPosition)[]>();\n    edges.forEach(edge => {\n        let layerIndex = getUpperLeftNode(edge).layerIndex;\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\n        grouped.push(edge);\n        groupedByLayerIndex.set(layerIndex, grouped);\n    });\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\n    return layerIndices.map(layerIndex => {\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\n        return Math.max(...edgeIndices) * EDGE_SPACING;\n    })\n}","import {heightOfEdges} from \"./heightOfEdges\";\nimport {\n    ELEMENT_HEIGHT,\n    GROUP_MARGIN_BOTTOM,\n    GROUP_MARGIN_TOP,\n    MARGIN_TOP,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {Graph, Group, Height, Layer, LayerDimensions, LayerIndex, LayerPosition, Node, Stack, X, Y} from \"./graphModel\";\n\nexport function heightOfNodes(\n    element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>\n): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(heightOfNodes)\n                .map((height, index) => height + (index > 0 ? VERTICAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodes));\n        case \"group\": {\n            return GROUP_MARGIN_TOP + Math.max(...element.elements.map(heightOfNodes)) + GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nexport function heightOfNodesOnlyFirstLayerOfNestedStacks(\n    element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>\n): number {\n    switch (element.kind) {\n        case \"stack\":\n            if (element.elements.length === 0) return 0;\n            return heightOfNodesOnlyFirstLayerOfNestedStacks(element.elements[0]);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodesOnlyFirstLayerOfNestedStacks));\n        case \"group\": {\n            return GROUP_MARGIN_TOP +\n                Math.max(...element.elements.map(heightOfNodesOnlyFirstLayerOfNestedStacks)) +\n                GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nfunction groupNestingLevel(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\": {\n            if (element.elements.length === 0) return 0;\n            // Ignore the nesting of the elements below the first one\n            return groupNestingLevel(element.elements[0]);\n        }\n        case \"layer\":\n            return Math.max(...element.elements.map(groupNestingLevel));\n        case \"group\":\n            return Math.max(...element.elements.map(groupNestingLevel)) + 1;\n        case \"node\":\n            return 0;\n    }\n}\n\nexport function addYToNodeG<N extends (Node & LayerIndex & X), E extends LayerPosition, G extends LayerIndex>(\n    graph: Graph<N, E, G>\n): Graph<N & Y & LayerDimensions, E, G & Y & Height> {\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n    addYToNode(graph.stack, {y: MARGIN_TOP, nodeY: 0, groupHeight: 0, belowLayerY: 0}, heightOfAllEdges);\n    return graph as unknown as Graph<N & Y & LayerDimensions, E, G & Y & Height>;\n}\n\nexport function addYToNode<N extends Node & LayerIndex, G extends LayerIndex>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { y: number, nodeY: number, groupHeight: number, belowLayerY: number },\n    heightOfEdges: number[]\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let old = {\n                y: accumulator.y,\n                nodeY: accumulator.nodeY,\n                belowLayerY: accumulator.belowLayerY\n            };\n            element.elements.forEach((layer, layerIndex) => {\n                addYToNode(layer, accumulator, heightOfEdges);\n            });\n            accumulator.y = old.y;\n            accumulator.nodeY = old.nodeY;\n            accumulator.belowLayerY = old.belowLayerY;\n            return;\n        }\n        case \"layer\": {\n            accumulator.nodeY = accumulator.y + groupNestingLevel(element) * GROUP_MARGIN_TOP;\n            accumulator.groupHeight = groupNestingLevel(element) * (GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM) + ELEMENT_HEIGHT;\n            accumulator.belowLayerY = accumulator.y + heightOfNodesOnlyFirstLayerOfNestedStacks(element) + VERTICAL_SPACING;\n            element.elements.forEach(nestedElement => {\n                addYToNode(nestedElement, accumulator, heightOfEdges);\n            });\n            accumulator.y += heightOfNodes(element) + VERTICAL_SPACING;\n            return;\n        }\n        case \"group\": {\n            let additionalEdgeHeight = heightOfEdges.slice(0, element.layerIndex).reduce((sum, add) => sum + add, 0);\n            Object.assign(element, {\n                y: accumulator.y + additionalEdgeHeight,\n                height: accumulator.groupHeight\n            });\n\n            accumulator.y += GROUP_MARGIN_TOP;\n            accumulator.groupHeight -= GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            element.elements.forEach(node => {\n                addYToNode(node, accumulator, heightOfEdges);\n            });\n            accumulator.y -= GROUP_MARGIN_TOP;\n            accumulator.groupHeight += GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            return;\n        }\n        case \"node\": {\n            let additionalEdgeHeight = heightOfEdges.slice(0, element.layerIndex).reduce((sum, add) => sum + add, 0);\n            Object.assign(element, {\n                y: accumulator.nodeY + additionalEdgeHeight,\n                belowLayerY: accumulator.belowLayerY + additionalEdgeHeight\n            });\n            return;\n        }\n    }\n}","import {ascending, descending} from \"./sorting\";\nimport {ConnectionIndex, Edge, Graph, Key, LayerIndex, NumberOfEdges, X} from \"./graphModel\";\n\nexport function addConnectionIndexAndNumberOfEdgesG<N extends LayerIndex & X & Key, E, G>(graph: Graph<N, E, G>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex, G> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    return graph as unknown as Graph<N & NumberOfEdges, E & ConnectionIndex, G>;\n}\n\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerIndex & X & Key>[]) {\n    type NodeSide = {\n        node: LayerIndex & X\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        reverseNode: LayerIndex & X\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(firstNode: LayerIndex & X & Key, secondNode: LayerIndex & X, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.key + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.x <= node.x);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.x >= node.x);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\n\n        before.sort(descending(e => e.reverseNode.x));\n        otherLayer.sort(ascending(e => e.reverseNode.x));\n        after.sort(descending(e => e.reverseNode.x));\n\n        let all = before.concat(otherLayer).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allNodes<N extends Node, G, E>(element: Stack<N, G> | Group<N, G> | N): N[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allNodes);\n        case \"group\":\n            return element.elements.flatMap(allNodes);\n        case \"node\":\n            return [element];\n    }\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allGroups<N extends Node, G, E>(element: Stack<N, G> | (Group<N, G> & G) | N): (Group<N, G> & G)[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allGroups);\n        case \"group\":\n            return [element].concat(element.elements.flatMap(allGroups));\n        case \"node\":\n            return [];\n    }\n}","import React from \"react\";\nimport {STROKE_WIDTH} from \"./styling\";\n\nexport type Symbol = {\n    x: number\n    y: number\n    width: number\n    symbolKey: string\n}\nexport const ComponentSymbol: React.FC<Symbol> = symbol => {\n    const symbolHeightRelative = 1.1;\n    const barWidthRelative = 0.4;\n    const barHeightRelative = 0.15;\n    const barWidthAbsolute = symbol.width * barWidthRelative;\n    const barHeightAbsolute = symbol.width * barHeightRelative;\n    return (\n        <g key={symbol.symbolKey}>\n            <rect\n                x={symbol.x + barWidthAbsolute / 2} y={symbol.y}\n                width={symbol.width * (1 - barWidthRelative / 2)} height={symbol.width * symbolHeightRelative}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute * 3}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, STROKE_WIDTH, SYMBOL_SPACING, SYMBOL_WIDTH, TEXT_PADDING} from \"./styling\";\nimport {Key, Node, X, Y} from \"./graphModel\";\nimport {ComponentSymbol} from \"./Symbols\";\n\nexport const NodeShape: React.FC<Node & X & Y & Key> = node => {\n    if (node.isPlaceholder) return null;\n\n    let isComponent = node.symbol === \"component\";\n    return (\n        <g key={node.key}>\n            <rect data-testid=\"rect\"\n                  x={node.x} y={node.y}\n                  width={width(node)} height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n\n            <text x={node.x + TEXT_PADDING} y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + node.key}>\n                <rect\n                    x={node.x + TEXT_PADDING} y={node.y}\n                    width={width(node) - 2 * TEXT_PADDING - (isComponent ? (SYMBOL_WIDTH + SYMBOL_SPACING) : 0)}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n\n            {isComponent ?\n                <ComponentSymbol\n                    symbolKey={node.key + \"CS\"}\n                    x={node.x + width(node) - SYMBOL_WIDTH - SYMBOL_SPACING}\n                    y={node.y + SYMBOL_SPACING}\n                    width={SYMBOL_WIDTH}/>\n                : \"\"}\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, GROUP_MARGIN_SIDE, STROKE_WIDTH} from \"./styling\";\nimport {Group, Height, Key, Node, X, Y} from \"./graphModel\";\n\nexport const GroupShape: React.FC<Group<Node, unknown> & X & Y & Key & Height> = group => {\n    return (\n        <g key={group.key}>\n            <rect\n                x={group.x} y={group.y}\n                width={width(group)}\n                height={group.height}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text x={group.x + GROUP_MARGIN_SIDE} y={group.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + group.key + \")\"}>{group.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + group.key}>\n                <rect\n                    x={group.x + GROUP_MARGIN_SIDE} y={group.y}\n                    width={width(group) - 2 * GROUP_MARGIN_SIDE}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {EDGE_SPACING, STROKE_WIDTH, VERTICAL_SPACING} from \"./styling\";\nimport {\n    ConnectionIndex,\n    Edge,\n    getUpperLeftNode,\n    LayerDimensions, LayerIndex,\n    LayerPosition,\n    Node,\n    NumberOfEdges, X,\n    Y\n} from \"./graphModel\";\nimport {heightOfNodes} from \"./addYToNode\";\n\nfunction edgeEndCoordinates<N extends Node & LayerIndex & X & Y & NumberOfEdges>(\n    node: N, edgeIndex: number, otherNode: N\n) {\n    let onLowerSide = node.layerIndex <= otherNode.layerIndex;\n    let nodeCenteringOffset = (width(node) - ((onLowerSide ? node.lowerSideEdges : node.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    return {\n        x: node.x + nodeCenteringOffset + edgeIndex * EDGE_SPACING,\n        y: node.y + (onLowerSide ? heightOfNodes(node) : 0)\n    };\n}\n\nexport const EdgeShape: React.FC<Edge<Node & LayerIndex & X & Y & LayerDimensions & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\n    let fromNode = edgeEndCoordinates(edge.from, edge.fromIndex, edge.to);\n    let upperNodeEdgesY = getUpperLeftNode(edge).belowLayerY - VERTICAL_SPACING / 2 + edge.index * EDGE_SPACING;\n    let toNode = edgeEndCoordinates(edge.to, edge.toIndex, edge.from);\n    return (\n        <path key={edge.key} d={\n            \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n            \"L \" + fromNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + toNode.y\n        }\n              stroke=\"black\"\n              strokeWidth={STROKE_WIDTH}\n              fill=\"none\"\n        />\n    );\n};","import {Graph, Group, Layer, LayerIndex, Node, Stack} from \"./graphModel\";\n\nfunction numberOfLayers(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(numberOfLayers)\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(numberOfLayers));\n        case \"group\": {\n            return Math.max(...element.elements.map(numberOfLayers));\n        }\n        case \"node\":\n            return 1;\n    }\n}\n\nexport function addLayerIndexToNodeG<N extends Node, E, G>(graph: Graph<N, E, G>):\n    Graph<N & LayerIndex, E, G & LayerIndex> {\n    addLayerIndexToNode(graph.stack);\n    return graph as unknown as Graph<N & LayerIndex, E, G & LayerIndex>;\n}\n\nexport function addLayerIndexToNode<N extends Node, G>(\n    element: N | Group<N, G> | Layer<N, G> | Stack<N, G>,\n    layerIndex: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach(nestedElement => {\n                addLayerIndexToNode(nestedElement, layerIndex);\n                layerIndex += numberOfLayers(nestedElement);\n            });\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => {\n                addLayerIndexToNode(group, layerIndex);\n            });\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n\n            element.elements.forEach(node => {\n                addLayerIndexToNode(node, layerIndex);\n            });\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n            return;\n        }\n    }\n}","import {Graph, Layer, LayerIndex, Node} from \"./graphModel\";\n\nexport function insertPlaceholdersInMultilayerEdges(graph: Graph<Node & LayerIndex, unknown, LayerIndex>): Graph<Node & LayerIndex, unknown, LayerIndex> {\n    return {\n        stack: graph.stack,\n        edges: graph.edges\n            .flatMap(edge => {\n                if (Math.abs(edge.from.layerIndex - edge.to.layerIndex) <= 1) return edge;\n\n                let from = Math.min(edge.from.layerIndex, edge.to.layerIndex);\n                let to = Math.max(edge.from.layerIndex, edge.to.layerIndex);\n                let newEdges = [];\n                let last = edge.from.layerIndex < edge.to.layerIndex ? edge.from : edge.to;\n                let end = edge.from.layerIndex >= edge.to.layerIndex ? edge.from : edge.to;\n                for (let i = from + 1; i < to; i++) {\n                    let placeholder: Node & LayerIndex = {\n                        kind: \"node\",\n                        name: \"\",\n                        size: 0.01,\n                        isPlaceholder: true,\n                        layerIndex: i\n                    };\n                    let layer: Layer<Node & LayerIndex, LayerIndex> = graph.stack.elements[i];\n                    layer.elements.splice(0, 0, placeholder);\n                    newEdges.push({from: last, to: placeholder});\n                    last = placeholder;\n                }\n                newEdges.push({from: last, to: end});\n                return newEdges;\n            })\n    };\n}","import {Graph, Group, Key, Layer, Node, Stack} from \"./graphModel\";\n\nexport function addKeyToNodeG<N extends Node, E, G>(\n    graph: Graph<N, E, G>\n): Graph<N & Key, E, G & Key> {\n    addKeyToNode(graph.stack);\n    return graph as unknown as Graph<N & Key, E, G & Key>;\n}\n\nexport function addKeyToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { globalCounter: number } = {globalCounter: 0}\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach(groups => addKeyToNode(groups, accumulator));\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => addKeyToNode(group, accumulator));\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                key: \"\" + accumulator.globalCounter\n            });\n            accumulator.globalCounter++;\n\n            element.elements.forEach(node => addKeyToNode(node, accumulator));\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                key: \"\" + accumulator.globalCounter\n            });\n            accumulator.globalCounter++;\n            return;\n        }\n    }\n}","import React from \"react\";\nimport {addXToNodeG} from \"./addXToNode\";\nimport {addLayerPositionToEdgeG} from \"./addLayerPositionToEdge\";\nimport {addYToNodeG, heightOfNodes} from \"./addYToNode\";\nimport {addConnectionIndexAndNumberOfEdgesG} from \"./addConnectionIndexAndNumberOfEdges\";\nimport {allNodes} from \"./allNodes\";\nimport {allGroups} from \"./allGroups\";\nimport {heightOfEdges} from \"./heightOfEdges\";\nimport {NodeShape} from \"./NodeShape\";\nimport {GroupShape} from \"./GroupShape\";\nimport {EdgeShape} from \"./EdgeShape\";\nimport {width} from \"./width\";\nimport {MARGIN_SIDE, MARGIN_TOP, VERTICAL_SPACING} from \"./styling\";\nimport {Graph, Node} from \"./graphModel\";\nimport {addLayerIndexToNodeG} from \"./addLayerIndexToNode\";\nimport {insertPlaceholdersInMultilayerEdges} from \"./insertPlaceholdersInMultilayerEdges\";\nimport {addKeyToNodeG} from \"./addKeyToNode\";\n\nexport const Diagram: React.FC<Graph<Node, unknown, unknown>> = graph => {\n    return [graph]\n        .map(addLayerIndexToNodeG)\n        .map(insertPlaceholdersInMultilayerEdges)\n        .map(addKeyToNodeG)\n        .map(addXToNodeG)\n        .map(addLayerPositionToEdgeG)\n        .map(addYToNodeG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(graph => {\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n            let overallWidth = width(graph.stack) + 2 * MARGIN_SIDE;\n            let height = heightOfNodes(graph.stack) + VERTICAL_SPACING +\n                heightOfAllEdges.reduce((sum, add) => sum + add) +\n                2 * MARGIN_TOP;\n\n            return (\n                <svg viewBox={\"0 0 \" + overallWidth + \" \" + height}>\n                    {allNodes(graph.stack).map(NodeShape)}\n                    {allGroups(graph.stack).map(GroupShape)}\n                    {graph.edges.map(EdgeShape)}\n                </svg>\n            );\n        })[0];\n};"],"sourceRoot":""}