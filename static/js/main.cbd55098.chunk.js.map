{"version":3,"sources":["v1/Editor.tsx","v1/parseGraph.tsx","v1/Architecture.tsx","v2/assertNever.tsx","v2/newGraphModel.tsx","v2/styling.tsx","v2/graphics/getElementLeftX.tsx","v2/graphics/getElementTopY.tsx","v2/graphics/Symbols.tsx","v2/graphics/renderShape.tsx","v2/graphics/NodeComponent.tsx","v2/elementsLayout/OffsetElementsY.tsx","v2/elementsLayout/OffsetElementsX.tsx","v2/elementsLayout/EmbeddedElementsX.tsx","v2/graphics/ContainerComponent.tsx","v2/elementsLayout/BorderIndexMaxX.tsx","v2/elementsLayout/BorderIndexLeft.tsx","v2/elementsLayout/BorderIndexRight.tsx","v2/elementsLayout/BorderIndexTop.tsx","v2/elementsLayout/BorderIndexBottom.tsx","v2/sorting.tsx","v2/sumOfPreviousRows.tsx","v2/getMostBottomOffsetElementsY.tsx","v2/elementsLayout/BorderIndexMaxBottom.tsx","v2/elementsLayout/BorderIndexMaxTop.tsx","v2/elementsLayout/EmbeddedElementsY.tsx","v2/EdgeHelper.tsx","v2/graphics/EdgeComponent.tsx","v2/edgesLayout/ConnectionIndexAndNumberOfEdges.tsx","v2/edgesLayout/SyntheticNodesAndEdges.tsx","v2/edgesLayout/MidPathSegmentOffsetY.tsx","v2/elementsLayout/ElementKey.tsx","v2/edgesLayout/MidPathSegmentOffsetYAggregates.tsx","v2/edgesLayout/EdgeIndex.tsx","v2/edgesLayout/CrossLayerPathSegmentOffsetX.tsx","v2/edgesLayout/CrossLayerPathSegmentOffsetMaxX.tsx","v2/Diagram.tsx","v2/Sample.tsx","v2/NewArchitecture.tsx","App.tsx","serviceWorker.ts","index.tsx","v1/indicesToReferences.tsx","v1/stringsToNodes.tsx","v1/styling.tsx","v1/width.tsx","v1/addXToNode.tsx","v1/sorting.tsx","v1/graphModel.tsx","v1/addLayerPositionToEdge.tsx","v1/heightOfEdges.tsx","v1/addYToNode.tsx","v1/addConnectionIndexAndNumberOfEdges.tsx","v1/allNodes.tsx","v1/allGroups.tsx","v1/Symbols.tsx","v1/NodeShape.tsx","v1/GroupShape.tsx","v1/EdgeShape.tsx","v1/addLayerIndexToNode.tsx","v1/insertPlaceholdersInMultilayerEdges.tsx","v1/addKeyToNode.tsx","v1/Diagram.tsx"],"names":["graphAsString","indicesToReferences","indicesToReferencesImport","stringsToNodes","stringsToNodesImport","initialGraph","eval","Editor","useState","graph","setGraph","errorMessage","setErrorMessage","id","className","stack","edges","cols","rows","onChange","changeEvent","result","parseGraph","target","value","defaultValue","text","undefined","every","edge","from","to","e","message","component","name","kind","symbol","size","Architecture","productAPI","stockAPI","productServiceDB","productImporter","stockImporter","categoryImporter","campaignImporter","elements","assertNever","x","Error","element","syntheticNodes","syntheticEdges","transformElements","f","transformElementsUsingGraph","node","nameOrProperties","defaults","visible","shape","Object","assign","gap","db","queue","system","allNodes","flatMap","allContainers","concat","allElements","MARGIN_Y","MARGIN_X","ELEMENT_WIDTH","ELEMENT_HEIGHT","BORDER_SPACING_X","BORDER_SPACING_TOP","BORDER_SPACING_BOTTOM","HORIZONTAL_SPACING","VERTICAL_SPACING","EDGE_SPACING","STROKE_WIDTH","STROKE_WIDTH_SELECTED","DEPLOYMENT_BOX_INDENT","DEPLOYMENT_BOX_3D_OFFSET","DB_CYLINDER_ELLIPSE_Y","QUEUE_CYLINDER_ELLIPSE_X","getElementLeftX","offsetElementsX","borderIndexMaxX","borderIndexLeft","crossLayerPathSegmentOffsetMaxX","getElementTopY","offsetElementsY","borderIndexMaxPreviousTop","borderIndexMaxTop","borderIndexTop","borderIndexMaxPreviousBottom","midPathSegmentOffsetMaxPreviousY","ComponentSymbol","symbolKey","width","y","height","barWidthAbsolute","barHeightAbsolute","key","d","stroke","strokeWidth","fill","bucketEllipseY","bucketIndentX","renderShape","selected","onClick","NodeComponent","props","textX","textY","elementKey","onNodeClick","transform","clipPath","fontSize","split","map","line","lineIndex","dy","SYMBOL_WIDTH","addOffsetElementsYG","addOffsetElementsY","accumulator","maxOffsetYElements","oldOffsetYElements","forEach","nestedElement","Math","max","addOffsetElementsXG","addOffsetElementsX","maxOffsetXElements","oldOffsetXElements","addEmbeddedElementsXG","addEmbeddedElementsX","embeddedElementsX","embeddedXElements","reduce","sum","add","ContainerComponent","container","borderIndexRight","embeddedElementsY","embeddedBorderIndexMaxTop","embeddedBorderIndexMaxBottom","embeddedMidPathSegmentY","borderIndexBottom","addBorderIndexMaxXG","determineAndAddBorderIndexMaxX","addBorderIndexMaxX","determineBorderIndexMaxX","addBorderIndexLeftG","addBorderIndexLeft","leftBorderIndex","length","addBorderIndexRightG","addBorderIndexRight","borderIndices","borderIndex","addBorderIndexTopG","addBorderIndexTopGraph","addBorderIndexTop","addBorderIndexBottomG","addBorderIndexBottom","ascending","property","o1","o2","descending","and","sortFunctions","i","sumOfPreviousRows","Map","sumOfPrevious","Array","entries","sort","entry","set","getMostBottomOffsetElementsY","addBorderIndexMaxBottomG","determineAndAddBorderIndexBottomAggregates","determineBorderIndexMaxBottom","sums","addBorderIndexMaxBottom","addition","get","calculateEmbeddedBorders","current","embeddedBorders","borderIndexMaxBottom","addBorderIndexMaxTopG","determineAndAddBorderIndexTopAggregates","determineBorderIndexMaxTop","addBorderIndexMaxTop","addEmbeddedElementsYG","addEmbeddedElementsY","fromIsUpperLeft","getUpperLeftNode","getLowerRightNode","getLeftUpperNode","fromIsLeftUpper","edgeEndCoordinates","edgeIndex","otherNode","onLowerSide","nodeCenteringOffset","lowerSideEdges","upperSideEdges","EdgeComponent","fromNode","fromIndex","upperNodeEdgesY","midPathSegmentOffsetY","toNode","toIndex","arrow","lowerLayerEdge","lowerNodeEdgesY","besideTopNodeX","crossLayerPathSegmentOffsetX","addConnectionIndexAndNumberOfEdgesG","groupedByNodeAndSide","addEdgeEnd","firstNode","secondNode","setIndex","side","nodeSide","edgeEnds","push","reverseNode","index","values","sameLayer","filter","edgeEnd","before","after","otherLayer","otherLayerBefore","otherLayerAfter","addConnectionIndexAndNumberOfEdges","edgesWithConnectionIndex","getLowerRightNodeIndex","getUpperLeftNodeIndex","isMultiLayerEdge","abs","addSyntheticNodesAndEdgesG","grid","lowerRightNode","upperLeftNode","min","has","lowerLayerEdgeProperty","isLowerLayerEdge","originalEdge","addMidPathSegmentOffsetYG","groupedByOffsetElementsY","addMidPathSegmentOffsetYForLayer","addMidPathSegmentOffsetY","groupedByUpperNode","nodeKeys","keys","indexOffset","nodeKey","sameLayerBefore","sameLayerAfter","addLayerPosition","indexInArray","beforeOrAfter","addElementKeyG","addElementKey","addMidPathSegmentOffsetYAggregatesG","addMidPathSegmentOffsetYAggregates","maxOffsetY","maxs","determineMidPathSegmentMaxOffsetY","layer","sumOfPreviousRowsFillLayers","applyMidPathSegmentOffsetYAggregates","calculateEmbeddedPaths","embeddedPaths","midPathSegmentOffsetMaxY","addEdgeIndexG","addCrossLayerPathSegmentOffsetXG","groupedByOffsetElementsX","addCrossLayerPathSegmentOffsetXForSlice","addCrossLayerPathSegmentOffsetX","addOffset","addCrossLayerPathSegmentOffsetMaxXG","determineAndAddCrossLayerPathSegmentOffsetMaxX","addCrossLayerPathSegmentOffsetMaxX","Diagram","graphState","state","oldGraph","viewBox","c","Sample","node_1_1","node_1_2","node_2_1","node_2_2","node_3_1","node_3_2","node_4_1","node_4_2","node_4_3","node_4_4","node_4_5","node_5_1","node_5_2","node_6_1","node_6_2","node_6_3","node_6_4","node_7_1","node_7_2","node_8_1","node_8_2","createInitialGraph","overall","customerBrowser","contentViewComponent","searchViewComponent","pdpViewComponent","this","coreAccount","edutainment","contentView","siteMap","core","pdpView","services","coreSiteMap","siteMapGenerator","search","factFinderDB","factFinderAPI","factFinderFeedServiceDB","factFinderUpdater","ffProductImporter","ffProductCampaignsImporter","ffCategoryImporter","productService","productCampaignsImporter","nightlyStockImporter","nearTimeStockImporter","deliveryTimeImporter","exporter","productExporterService","productStream","productExporter","productCampaignsStream","productCampaignsExporter","nightlyStockStream","nightlyStockExporter","stockExporterService","stockStream","stockExporter","deliveryTimeExporterService","deliveryTimeStream","deliveryTimeExporter","categoryExporterService","categoryStream","categoryExporter","articleS3Bucket","backendSystems","contentful","content","catalogContent","productContent","tds","shopNowDB","mediaData","mediathek","mercator","mercatorStagingDB","mercatorDB","mercatorComponent","sapERP","articleReport","sapCRM","sellAPI","NewArchitecture","App","exact","path","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","indexToReference","indexPairs","indexPair","indexPairToReference","convertStringsToNodes","strings","MARGIN_TOP","MARGIN_SIDE","GROUP_MARGIN_TOP","GROUP_MARGIN_BOTTOM","GROUP_MARGIN_SIDE","addXToNodeG","addXToNode","fullWidth","oldX","group","layerIndex","addLayerPositionToEdgeG","groupedByLayerIndex","addLayerPositionToEdgeForLayer","addLayerPositionToEdge","heightOfEdges","numberOfLayers","grouped","edgeIndices","heightOfNodes","isPlaceholder","heightOfNodesOnlyFirstLayerOfNestedStacks","groupNestingLevel","addYToNodeG","heightOfAllEdges","addYToNode","old","nodeY","belowLayerY","groupHeight","additionalEdgeHeight","slice","allGroups","NodeShape","isComponent","data-testid","GroupShape","EdgeShape","addLayerIndexToNodeG","addLayerIndexToNode","insertPlaceholdersInMultilayerEdges","newEdges","last","end","placeholder","splice","addKeyToNodeG","addKeyToNode","globalCounter","groups","overallWidth"],"mappings":"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","file":"static/js/main.cbd55098.chunk.js","sourcesContent":["import {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\nimport React, {useState} from \"react\";\nimport {parseGraph} from \"./parseGraph\";\nimport {Diagram} from \"./Diagram\";\nimport {Graph, Node} from \"./graphModel\";\nimport './Editor.css';\n\nlet graphAsString =\n    `var stack = stringsToNodes([\n    [\n        {name: \"group 1\", elements: [\n            \"element 11\", \n            {name: \"element 2\", size: 1.5, symbol: \"component\"}, \n            {name: \"an element with long text\", symbol: \"component\"}            \n        ]},\n        {name: \"group 2\", elements: [\"element 4\"]}\n    ],\n    [\n        {name: \"group 3\", elements: [\"element 1\", \"element 2\"]},\n        {name: \"group 4\", elements: [\n            {name: \"group 6\", elements: [\"element 4\"]}, \n            {name: \"placeholder\", size: 0.3, isPlaceholder: true}, \n            \"element 3\"\n        ]},\n        \"node on top level\", \n        {name: \"an element with long text\", symbol: \"component\"}     \n    ],\n    [\n        {name: \"group 5\", elements: [\n            \"element 1\", \"element 2\", \"element 3\", \n            {name: \"element with changed name\", size: 1.5}, \n            {name: \"element 5\", size: 0.7}]}\n    ]\n]);\n\nvar edgeIndices = [\n    {from: [0, 0, 0],    to: [1, 3]},\n    {from: [0, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 2],    to: [1, 1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 0, 1]},\n    {from: [1, 1, 0, 0], to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 4]},\n    {from: [1, 0, 1],    to: [2, 0, 3]},\n    {from: [1, 0, 1],    to: [2, 0, 2]},\n    {from: [1, 0, 1],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [2, 0, 0]},\n    {from: [2, 0, 0],    to: [1, 0, 0]},\n    {from: [2, 0, 1],    to: [1, 0, 0]},\n    {from: [2, 0, 0],    to: [2, 0, 3]},\n    {from: [2, 0, 1],    to: [2, 0, 3]},\n    {from: [2, 0, 4],    to: [2, 0, 3]},\n    {from: [0, 0, 0],    to: [0, 0, 2]},\n    {from: [0, 0, 0],    to: [0, 0, 1]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [1, 0, 0]},\n    {from: [0, 1, 0],    to: [1, 1, 1]},\n    {from: [1, 1, 1],    to: [2, 0, 2]},\n    {from: [0, 1, 0],    to: [1, 1, 2]},\n    {from: [1, 0, 1],    to: [1, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 0]},\n    {from: [0, 0, 0],    to: [2, 0, 1]},\n    {from: [1, 0, 1],    to: [1, 1, 0, 0]}\n];\nvar edges = indicesToReferences(stack, edgeIndices);\n\nvar graph = {\n    stack: stack,\n    edges: edges\n};\n\ngraph\n`;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\n// eslint-disable-next-line no-eval\nconst initialGraph: Graph<Node, unknown, unknown> = eval(graphAsString);\n\nexport const Editor: React.FC = () => {\n    const [graph, setGraph] = useState(initialGraph);\n    const [errorMessage, setErrorMessage] = useState(\"\");\n\n    function handleChange(changeEvent: React.ChangeEvent<HTMLTextAreaElement>) {\n        let result = parseGraph(changeEvent.target.value);\n        if (typeof result === 'string') {\n            setErrorMessage(result);\n        } else {\n            setGraph(result);\n            setErrorMessage(\"\");\n        }\n    }\n\n    return (\n        <div id=\"parent\" className=\"App\">\n            <div id=\"graph\">\n                <Diagram stack={graph.stack} edges={graph.edges}/>\n            </div>\n            <div>\n                <textarea cols={100} rows={45} onChange={handleChange} defaultValue={graphAsString}/>\n                <p className=\"error-message\">{errorMessage}</p>\n            </div>\n        </div>\n    );\n};","import {Edge, Graph, Node} from \"./graphModel\";\nimport {indicesToReferences as indicesToReferencesImport} from \"./indicesToReferences\";\nimport {stringsToNodes as stringsToNodesImport} from \"./stringsToNodes\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst indicesToReferences = indicesToReferencesImport;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringsToNodes = stringsToNodesImport;\n\nexport function parseGraph(text: string): Graph<Node, unknown, unknown> | string {\n    try {\n// eslint-disable-next-line\n        let graph: Graph<Node, unknown, unknown> = eval(text);\n\n        if (graph === undefined) return \"Script is not returning a graph object!\";\n\n        if (graph.stack === undefined) return \"Property layers is missing in graph object!\";\n        if (graph.edges === undefined) return \"Property edges is missing in graph object!\";\n\n        if (!graph.edges.every((edge: Edge<Node>) => edge.from !== undefined))\n            return \"Property from must be defined on every edge!\";\n        if (!graph.edges.every((edge: Edge<Node>) => edge.to !== undefined))\n            return \"Property to must be defined on every edge!\";\n\n        return graph;\n    } catch (e) {\n        return e.message;\n    }\n}","import React from \"react\";\nimport {Diagram} from \"./Diagram\";\nimport {Edge, Node, Stack} from \"./graphModel\";\n\nfunction component(name: string): Node {\n    return {\n        kind: \"node\", name: name, symbol: \"component\", size: 1.2\n    }\n}\n\nexport const Architecture: React.FC = () => {\n    let productAPI = component(\"Product API\");\n    let stockAPI = component(\"Stock API\");\n    let productServiceDB = component(\"Product Service DB\");\n    let productImporter = component(\"Product Importer\");\n    let stockImporter = component(\"Stock Importer\");\n    let categoryImporter = component(\"Category Importer\");\n    let campaignImporter = component(\"Campaign Importer\");\n\n    let stack: Stack<Node, unknown> = {\n        kind: \"stack\",\n        elements: [\n            {\n                kind: \"layer\",\n                elements: [productAPI, stockAPI]\n            },\n            {\n                kind: \"layer\",\n                elements: [productServiceDB]\n            },\n            {\n                kind: \"layer\",\n                elements: [productImporter, stockImporter, categoryImporter, campaignImporter]\n            }\n        ]\n    };\n\n    let edges: Edge<Node>[] = [\n        {from: productAPI, to: productServiceDB},\n        {from: stockAPI, to: productServiceDB},\n        {from: productServiceDB, to: productImporter},\n        {from: productServiceDB, to: stockImporter},\n        {from: productServiceDB, to: categoryImporter},\n        {from: productServiceDB, to: campaignImporter}\n    ];\n\n    return (\n        <Diagram stack={stack} edges={edges}/>\n    );\n};","export function assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}","import {assertNever} from \"./assertNever\";\n\nexport type Symbols = \"component\" | \"db-table\" | \"s3-bucket\"\n\ntype Shapes = \"rectangle\" | \"db-cylinder\" | \"queue-cylinder\" | \"deployment-box\"\n\nexport type Node = {\n    kind: \"node\",\n} & NodeProperties;\n\nexport type NodeProperties = {\n    name?: string,\n    visible?: boolean,\n    shape?: Shapes,\n    symbol?: Symbols,\n    selected?: boolean\n};\n\nexport type Row<N> = {\n    kind: \"row\"\n} & ContainerProperties<N>;\n\nexport type Column<N> = {\n    kind: \"column\"\n} & ContainerProperties<N>;\n\ntype ContainerProperties<N> = {\n    name?: string,\n    shape?: Shapes,\n    elements: Element<N>[]\n};\n\nexport type Container<N> = (Row<N> & N) | (Column<N> & N);\n\nexport type Element<N> = (Node & N) | (Row<N> & N) | (Column<N> & N);\n\nexport type Edge<N, E> = {\n    from: N,\n    to: N,\n    selected?: boolean\n} & E\n\nexport type Graph<N, E> = {\n    element: Element<N>\n    edges: Edge<N, E>[]\n    syntheticNodes: (Node & N)[]\n    syntheticEdges: Edge<N, E>[]\n}\n\nexport function graph<N, E>(\n    element: Element<N>,\n    edges: Edge<N, E>[] = [],\n    syntheticNodes: (Node & N)[] = [],\n    syntheticEdges: Edge<N, E>[] = []\n): Graph<N, E> {\n    return {element, edges, syntheticNodes, syntheticEdges};\n}\n\nexport function transformElements<N, A, E>(graph: Graph<N, E>, f: (element: Element<N>) => void): Graph<N & A, E> {\n    f(graph.element);\n    return graph as Graph<N & A, E>;\n}\n\nexport function transformElementsUsingGraph<N, A, E>(graph: Graph<N, E>, f: (graph: Graph<N, E>) => void): Graph<N & A, E> {\n    f(graph);\n    return graph as Graph<N & A, E>;\n}\n\nexport function node(nameOrProperties?: string | NodeProperties): Node {\n    let defaults: Node = {\n        kind: \"node\",\n        visible: true,\n        shape: \"rectangle\"\n    };\n    if (!nameOrProperties) {\n        return defaults;\n    } else if (typeof nameOrProperties === 'string') {\n        return Object.assign<Node, NodeProperties>(defaults, {name: nameOrProperties});\n    } else {\n        return Object.assign<Node, NodeProperties>(defaults, nameOrProperties);\n    }\n}\n\nexport function gap(): Node {\n    return node({visible: false});\n}\n\nexport function component(name: string): Node {\n    return node({name: name, symbol: \"component\"});\n}\n\nexport function dbTable(name: string): Node {\n    return node({name: name, symbol: \"db-table\"});\n}\n\nexport function s3Bucket(name: string): Node {\n    return node({name: name, symbol: \"s3-bucket\"});\n}\n\nexport function db(name: string): Node {\n    return node({name: name, shape: \"db-cylinder\"});\n}\n\nexport function queue(name: string): Node {\n    return node({name: name, shape: \"queue-cylinder\"});\n}\n\nexport function system(name: string): Node {\n    return node({name: name, shape: \"deployment-box\"});\n}\n\nexport function edge<N>(from: N, to: N): Edge<N, unknown> {\n    return {\n        from: from,\n        to: to\n    }\n}\n\nexport function allNodes<N>(element: Element<N>): (Node & N)[] {\n    switch (element.kind) {\n        case \"node\":\n            return [element];\n        case \"row\":\n        case \"column\":\n            return element.elements.flatMap(allNodes);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nexport function allContainers<N>(element: Element<N>): Container<N>[] {\n    switch (element.kind) {\n        case \"node\":\n            return [];\n        case \"row\":\n        case \"column\":\n            return element.elements.flatMap(allContainers).concat(element);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nexport function allElements<N>(element: Element<N>): Element<N>[] {\n    switch (element.kind) {\n        case \"node\":\n            return [element];\n        case \"row\":\n        case \"column\":\n            return element.elements.flatMap(allElements).concat(element);\n        default: {\n            assertNever(element);\n        }\n    }\n}","export const MARGIN_Y = 5;\nexport const MARGIN_X = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 60;\nexport const BORDER_SPACING_X = 15;\nexport const BORDER_SPACING_TOP = 40;\nexport const BORDER_SPACING_BOTTOM = 15;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;\nexport const STROKE_WIDTH_SELECTED = 1.5;\nexport const TEXT_PADDING = 5;\nexport const SYMBOL_WIDTH = 16;\nexport const SYMBOL_SPACING = 3;\nexport const ARROW_WIDTH = 3;\nexport const ARROW_HEIGHT = 5;\nexport const DEPLOYMENT_BOX_INDENT = BORDER_SPACING_X * 0.3;\nexport const DEPLOYMENT_BOX_3D_OFFSET = BORDER_SPACING_X * 0.4;\nexport const DB_CYLINDER_ELLIPSE_Y = BORDER_SPACING_X * 0.5;\nexport const QUEUE_CYLINDER_ELLIPSE_X = BORDER_SPACING_X * 0.4;","import {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {BorderIndexMaxX} from \"../elementsLayout/BorderIndexMaxX\";\nimport {CrossLayerPathSegmentOffsetMaxX} from \"../edgesLayout/CrossLayerPathSegmentOffsetMaxX\";\nimport {BORDER_SPACING_X, EDGE_SPACING, ELEMENT_WIDTH, HORIZONTAL_SPACING, MARGIN_X} from \"../styling\";\nimport {BorderIndexLeft} from \"../elementsLayout/BorderIndexLeft\";\n\nexport type RequiredNodeDataGetElementLeftX =\n    OffsetElementsX &\n    BorderIndexLeft & BorderIndexMaxX &\n    CrossLayerPathSegmentOffsetMaxX\n\nexport function getElementLeftX(element: RequiredNodeDataGetElementLeftX) {\n    return MARGIN_X\n        + element.offsetElementsX * (ELEMENT_WIDTH + HORIZONTAL_SPACING)\n        + (element.borderIndexMaxX * (element.offsetElementsX * 2 + 1) - element.borderIndexLeft) * BORDER_SPACING_X\n        + element.crossLayerPathSegmentOffsetMaxX * element.offsetElementsX * EDGE_SPACING;\n}","import {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {BorderIndexMaxPreviousTop, BorderIndexMaxTop} from \"../elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexMaxPreviousBottom} from \"../elementsLayout/BorderIndexMaxBottom\";\nimport {MidPathSegmentOffsetMaxPreviousY} from \"../edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    MARGIN_Y,\n    VERTICAL_SPACING\n} from \"../styling\";\nimport {BorderIndexTop} from \"../elementsLayout/BorderIndexTop\";\n\nexport type RequiredNodeDataGetElementTopY =\n    OffsetElementsY &\n    BorderIndexTop & BorderIndexMaxTop & BorderIndexMaxPreviousTop &\n    BorderIndexMaxPreviousBottom &\n    MidPathSegmentOffsetMaxPreviousY\n\nexport function getElementTopY(element: RequiredNodeDataGetElementTopY) {\n    return MARGIN_Y\n        + element.offsetElementsY * (ELEMENT_HEIGHT + VERTICAL_SPACING)\n        + (element.borderIndexMaxPreviousTop + element.borderIndexMaxTop - element.borderIndexTop) * BORDER_SPACING_TOP\n        + element.borderIndexMaxPreviousBottom * BORDER_SPACING_BOTTOM\n        + element.midPathSegmentOffsetMaxPreviousY * EDGE_SPACING;\n}","import React from \"react\";\nimport {STROKE_WIDTH} from \"../styling\";\nimport {Symbols} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type Symbol = {\n    symbol: Symbols\n    x: number\n    y: number\n    width: number\n    symbolKey: string\n}\n\nexport const ComponentSymbol: React.FC<Symbol> = ({symbol, symbolKey, width, x, y}) => {\n    let height = width * 1.2;\n    switch (symbol) {\n        case \"component\": {\n            const symbolHeightRelative = 1.1;\n            const barWidthRelative = 0.4;\n            const barHeightRelative = 0.15;\n            const barWidthAbsolute = width * barWidthRelative;\n            const barHeightAbsolute = width * barHeightRelative;\n            return (\n                <g key={symbolKey}>\n                    <path d={\n                        \"M \" + (x + barWidthAbsolute / 2) + \" \" + (y + 4 * barHeightAbsolute) + \" \" +\n                        \"h \" + (-barWidthAbsolute / 2) + \" \" +\n                        \"v \" + (-barHeightAbsolute) + \" \" +\n                        \"h \" + (barWidthAbsolute / 2) + \" \" +\n                        \"v \" + (-barHeightAbsolute) + \" \" +\n                        \"h \" + (-barWidthAbsolute / 2) + \" \" +\n                        \"v \" + (-barHeightAbsolute) + \" \" +\n                        \"h \" + (barWidthAbsolute / 2) + \" \" +\n                        \"v \" + (-barHeightAbsolute) + \" \" +\n                        \"h \" + (width * (1 - barWidthRelative / 2)) + \" \" +\n                        \"v \" + (width * symbolHeightRelative) + \" \" +\n                        \"h \" + (-width * (1 - barWidthRelative / 2)) + \" \" +\n                        \"Z\"\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"none\"\n                    />\n                    <path d={\n                        \"M \" + (x + barWidthAbsolute / 2) + \" \" + (y + 4 * barHeightAbsolute) + \" \" +\n                        \"h \" + (barWidthAbsolute / 2) + \" \" +\n                        \"v \" + (-barHeightAbsolute) + \" \" +\n                        \"h \" + (-barWidthAbsolute / 2)\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"none\"\n                    />\n                    <path d={\n                        \"M \" + (x + barWidthAbsolute / 2) + \" \" + (y + 2 * barHeightAbsolute) + \" \" +\n                        \"h \" + (barWidthAbsolute / 2) + \" \" +\n                        \"v \" + (-barHeightAbsolute) + \" \" +\n                        \"h \" + (-barWidthAbsolute / 2)\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"none\"\n                    />\n                </g>\n            );\n        }\n        case \"db-table\": {\n            return (\n                <g key={symbolKey}>\n                    <rect\n                        x={x}\n                        y={y}\n                        width={width}\n                        height={height}\n                        fill=\"none\"\n                        strokeWidth={STROKE_WIDTH}\n                        stroke=\"black\"\n                    />\n                    <path d={\n                        \"M \" + (x) + \" \" + (y + 0.25 * width) + \" \" +\n                        \"h \" + width\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"none\"\n                    />\n                    <path d={\n                        \"M \" + (x + 0.25 * width) + \" \" + (y) + \" \" +\n                        \"v \" + height\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"none\"\n                    />\n                </g>\n            )\n        }\n        case \"s3-bucket\": {\n            let bucketEllipseY = height * 0.1;\n            let bucketIndentX = width * 0.1;\n            return (\n                <g key={symbolKey}>\n                    <path d={\n                        \"M \" + x + \" \" + (y + bucketEllipseY) + \" \" +\n                        \"A \" + (width / 2) + \",\" + bucketEllipseY + \" 0 1,1 \" + (x + width) + \",\" + (y + bucketEllipseY) + \" \" +\n                        \"L \" + (x + width - bucketIndentX) + \" \" + (y + height - bucketEllipseY) + \" \" +\n                        \"A \" + (width / 2 - bucketIndentX) + \",\" + bucketEllipseY + \" 0 1,1 \" + (x + bucketIndentX) + \",\" + (y + height - bucketEllipseY) + \" \" +\n                        \"Z\"\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"white\"\n                    />\n                    <path d={\n                        \"M \" + x + \" \" + (y + bucketEllipseY) + \" \" +\n                        \"A \" + (width / 2) + \",\" + bucketEllipseY + \" 0 1,0 \" + (x + width) + \",\" + (y + bucketEllipseY)\n                    }\n                          stroke=\"black\"\n                          strokeWidth={STROKE_WIDTH}\n                          fill=\"none\"\n                    />\n                </g>\n            )\n        }\n        default: {\n            assertNever(symbol);\n        }\n    }\n};","import {\n    DB_CYLINDER_ELLIPSE_Y, DEPLOYMENT_BOX_3D_OFFSET,\n    DEPLOYMENT_BOX_INDENT,\n    QUEUE_CYLINDER_ELLIPSE_X,\n    STROKE_WIDTH,\n    STROKE_WIDTH_SELECTED\n} from \"../styling\";\nimport React from \"react\";\n\nexport function renderShape(\n    shape: \"rectangle\" | \"db-cylinder\" | \"queue-cylinder\" | \"deployment-box\" | undefined,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    fill = \"white\",\n    selected?: boolean,\n    onClick?: () => void\n) {\n    let strokeWidth = selected ? STROKE_WIDTH_SELECTED : STROKE_WIDTH;\n\n    return <>\n        {shape === \"rectangle\" &&\n        <rect\n            x={x}\n            y={y}\n            width={width}\n            height={height}\n            onClick={onClick}\n            fill={fill}\n            strokeWidth={strokeWidth}\n            stroke=\"black\"\n        />\n        }\n        {shape === \"db-cylinder\" &&\n        <g>\n            <path d={\n                \"M \" + x + \" \" + (y + DB_CYLINDER_ELLIPSE_Y) + \" \" +\n                \"A \" + (width / 2) + \",\" + DB_CYLINDER_ELLIPSE_Y + \" 0 1,1 \" + (x + width) + \",\" + (y + DB_CYLINDER_ELLIPSE_Y) + \" \" +\n                \"V \" + (y + height - DB_CYLINDER_ELLIPSE_Y) + \" \" +\n                \"A \" + (width / 2) + \",\" + DB_CYLINDER_ELLIPSE_Y + \" 0 1,1 \" + x + \",\" + (y + height - DB_CYLINDER_ELLIPSE_Y) + \" \" +\n                \"Z\"\n            }\n                  onClick={onClick}\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  fill=\"white\"\n            />\n            <path d={\n                \"M \" + x + \" \" + (y + DB_CYLINDER_ELLIPSE_Y) + \" \" +\n                \"A \" + (width / 2) + \",\" + DB_CYLINDER_ELLIPSE_Y + \" 0 1,0 \" + (x + width) + \",\" + (y + DB_CYLINDER_ELLIPSE_Y)\n            }\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  fill=\"none\"\n            />\n        </g>\n        }\n        {shape === \"queue-cylinder\" &&\n        <g>\n            <path d={\n                \"M \" + (x + QUEUE_CYLINDER_ELLIPSE_X) + \" \" + y + \" \" +\n                \"A \" + QUEUE_CYLINDER_ELLIPSE_X + \",\" + (height / 2) + \" 0 1,0 \" + (x + QUEUE_CYLINDER_ELLIPSE_X) + \",\" + (y + height) + \" \" +\n                \"H \" + (x + width - QUEUE_CYLINDER_ELLIPSE_X) + \" \" +\n                \"A \" + QUEUE_CYLINDER_ELLIPSE_X + \",\" + (height / 2) + \" 0 1,0 \" + (x + width - QUEUE_CYLINDER_ELLIPSE_X) + \",\" + y + \" \" +\n                \"Z\"\n            }\n                  onClick={onClick}\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  fill=\"white\"\n            />\n            <path d={\n                \"M \" + (x + QUEUE_CYLINDER_ELLIPSE_X) + \" \" + y + \" \" +\n                \"A \" + QUEUE_CYLINDER_ELLIPSE_X + \",\" + (height / 2) + \" 0 1,1 \" + (x + QUEUE_CYLINDER_ELLIPSE_X) + \",\" + (y + height)\n            }\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  fill=\"none\"\n            />\n        </g>\n        }\n        {(shape === \"deployment-box\") &&\n        <g>\n            <path d={\n                \"M \" + (x + DEPLOYMENT_BOX_INDENT) + \" \" + (y + DEPLOYMENT_BOX_INDENT) + \" \" +\n                \"L \" + (x + DEPLOYMENT_BOX_INDENT + DEPLOYMENT_BOX_3D_OFFSET) + \" \" + y + \" \" +\n                \"H \" + (x + width - DEPLOYMENT_BOX_INDENT + DEPLOYMENT_BOX_3D_OFFSET) + \" \" +\n                \"V \" + (y + height - DEPLOYMENT_BOX_INDENT) + \" \" +\n                \"L \" + (x + width - DEPLOYMENT_BOX_INDENT) + \" \" + (y + height) +\n                \"H \" + (x + DEPLOYMENT_BOX_INDENT) + \" \" +\n                \"Z\"\n            }\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  onClick={onClick}\n                  fill={fill}\n            />\n            <path d={\n                \"M \" + (x + DEPLOYMENT_BOX_INDENT) + \" \" + (y + DEPLOYMENT_BOX_INDENT) + \" \" +\n                \"H \" + (x + width - DEPLOYMENT_BOX_INDENT) + \" \" +\n                \"V \" + (y + height)\n            }\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  fill=\"none\"\n            />\n            <path d={\n                \"M \" + (x + width - DEPLOYMENT_BOX_INDENT) + \" \" + (y + DEPLOYMENT_BOX_INDENT) + \" \" +\n                \"L \" + (x + width - DEPLOYMENT_BOX_INDENT + DEPLOYMENT_BOX_3D_OFFSET) + \" \" + y\n            }\n                  stroke=\"black\"\n                  strokeWidth={strokeWidth}\n                  fill=\"none\"\n            />\n        </g>\n        }\n    </>;\n}","import React from \"react\";\nimport {\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    QUEUE_CYLINDER_ELLIPSE_X,\n    SYMBOL_SPACING,\n    SYMBOL_WIDTH,\n    TEXT_PADDING\n} from \"../styling\";\nimport {ElementKey} from \"../elementsLayout/ElementKey\";\nimport {Node} from \"../newGraphModel\"\nimport {getElementLeftX, RequiredNodeDataGetElementLeftX} from \"./getElementLeftX\";\nimport {getElementTopY, RequiredNodeDataGetElementTopY} from \"./getElementTopY\";\nimport {ComponentSymbol} from \"./Symbols\";\nimport {renderShape} from \"./renderShape\";\n\ntype Props = {\n    node : Node & ElementKey & RequiredNodeDataGetElementLeftX & RequiredNodeDataGetElementTopY,\n    onNodeClick: (node: Node) => void\n};\n\nexport const NodeComponent: React.FC<Props> = props => {\n    let node = props.node;\n    if (!node.visible) return null;\n\n    let x = getElementLeftX(node);\n    let y = getElementTopY(node);\n\n    let textX = x + TEXT_PADDING\n        + (node.shape === \"queue-cylinder\" ? 2 * QUEUE_CYLINDER_ELLIPSE_X : 0)\n        + (node.shape === \"deployment-box\" ? TEXT_PADDING : 0);\n    let textY = y\n        + (node.shape === \"deployment-box\" ? TEXT_PADDING : 0);\n\n    return (\n        <g key={node.elementKey}>\n            {renderShape(node.shape, x, y, ELEMENT_WIDTH, ELEMENT_HEIGHT, \"white\", node.selected, () => props.onNodeClick(node))}\n            {node.name &&\n            <g transform={\"translate(\"\n            + textX + \" \" + textY + \")\"}>\n                <text\n                    x={0}\n                    y={ELEMENT_HEIGHT * (node.shape === \"db-cylinder\" ? 0.3 : 0)}\n                    fill=\"black\"\n                    clipPath={\"url(#clip-element-text-\" + node.elementKey + \")\"}\n                    fontSize={12}\n                >\n                    {node.name.split(\"\\n\").map((line, lineIndex) => (\n                        <tspan key={node.elementKey + \"T\" + lineIndex} x=\"0\" dy=\"1.2em\">{line}</tspan>\n                    ))}\n                </text>\n                <clipPath id={\"clip-element-text-\" + node.elementKey}>\n                    <rect\n                        x={0}\n                        y={0}\n                        width={ELEMENT_WIDTH - 2 * TEXT_PADDING\n                        - (node.symbol ? (SYMBOL_WIDTH + SYMBOL_SPACING) : 0)\n                        - (node.shape === \"queue-cylinder\" ? 2 * QUEUE_CYLINDER_ELLIPSE_X : 0)}\n                        height={ELEMENT_HEIGHT * (node.shape === \"db-cylinder\" ? 0.8 : 1)}/>\n                </clipPath>\n            </g>\n            }\n            {node.symbol &&\n            <ComponentSymbol\n                symbol={node.symbol}\n                symbolKey={node.elementKey + \"CS\"}\n                x={x + ELEMENT_WIDTH - SYMBOL_WIDTH - SYMBOL_SPACING}\n                y={y + SYMBOL_SPACING}\n                width={SYMBOL_WIDTH}/>\n            }\n        </g>\n    );\n};","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type OffsetElementsY = { offsetElementsY: number };\n\nexport function addOffsetElementsYG<N, E>(graph: Graph<N, E>): Graph<N & OffsetElementsY, E> {\n    return transformElements<N, OffsetElementsY, E>(graph, addOffsetElementsY);\n}\n\nexport function addOffsetElementsY(element: Element<unknown>, accumulator = {offsetElementsY: 0}) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            accumulator.offsetElementsY++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            let maxOffsetYElements = 0;\n            let oldOffsetYElements = accumulator.offsetElementsY;\n            element.elements.forEach(nestedElement => {\n                addOffsetElementsY(nestedElement, accumulator);\n                maxOffsetYElements = Math.max(maxOffsetYElements, accumulator.offsetElementsY);\n                accumulator.offsetElementsY = oldOffsetYElements;\n            });\n            accumulator.offsetElementsY = maxOffsetYElements;\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, OffsetElementsY>(element, {\n                offsetElementsY: accumulator.offsetElementsY\n            });\n            element.elements.forEach(nestedElement => addOffsetElementsY(nestedElement, accumulator));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type OffsetElementsX = { offsetElementsX: number };\n\nexport function addOffsetElementsXG<N, E>(graph: Graph<N, E>): Graph<N & OffsetElementsX, E> {\n    return transformElements<N, OffsetElementsX, E>(graph, addOffsetElementsX);\n}\n\nexport function addOffsetElementsX(element: Element<unknown>, accumulator = {offsetElementsX: 0}) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            accumulator.offsetElementsX++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            element.elements.forEach(nestedElement => addOffsetElementsX(nestedElement, accumulator));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, OffsetElementsX>(element, {\n                offsetElementsX: accumulator.offsetElementsX\n            });\n            let maxOffsetXElements = 0;\n            let oldOffsetXElements = accumulator.offsetElementsX;\n            element.elements.forEach(nestedElement => {\n                addOffsetElementsX(nestedElement, accumulator);\n                maxOffsetXElements = Math.max(maxOffsetXElements, accumulator.offsetElementsX);\n                accumulator.offsetElementsX = oldOffsetXElements;\n            });\n            accumulator.offsetElementsX = maxOffsetXElements;\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type EmbeddedElementsX = { embeddedElementsX: number };\n\nexport function addEmbeddedElementsXG<N, E>(graph: Graph<N, E>): Graph<N & EmbeddedElementsX, E> {\n    return transformElements<N, EmbeddedElementsX, E>(graph, addEmbeddedElementsX);\n}\n\nexport function addEmbeddedElementsX(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, EmbeddedElementsX>(element, {\n                embeddedElementsX: 1\n            });\n            return 1;\n        }\n        case \"row\": {\n            let embeddedXElements =\n                element.elements.map(addEmbeddedElementsX).reduce((sum, add) => sum + add, 0);\n\n            Object.assign<Row<unknown>, EmbeddedElementsX>(element, {\n                embeddedElementsX: embeddedXElements\n            });\n            return embeddedXElements;\n        }\n        case \"column\": {\n            let embeddedXElements =\n                Math.max(...element.elements.map(addEmbeddedElementsX), 0);\n\n            Object.assign<Column<unknown>, EmbeddedElementsX>(element, {\n                embeddedElementsX: embeddedXElements\n            });\n            return embeddedXElements;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import React from \"react\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    BORDER_SPACING_X,\n    DB_CYLINDER_ELLIPSE_Y,\n    EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    HORIZONTAL_SPACING,\n    TEXT_PADDING,\n    VERTICAL_SPACING\n} from \"../styling\";\nimport {Container} from \"../newGraphModel\";\nimport {EmbeddedElementsX} from \"../elementsLayout/EmbeddedElementsX\";\nimport {BorderIndexMaxBottom, EmbeddedBorderIndexMaxBottom} from \"../elementsLayout/BorderIndexMaxBottom\";\nimport {EmbeddedBorderIndexMaxTop} from \"../elementsLayout/BorderIndexMaxTop\";\nimport {BorderIndexBottom} from \"../elementsLayout/BorderIndexBottom\";\nimport {BorderIndexRight} from \"../elementsLayout/BorderIndexRight\";\nimport {EmbeddedElementsY} from \"../elementsLayout/EmbeddedElementsY\";\nimport {ElementKey} from \"../elementsLayout/ElementKey\";\nimport {EmbeddedMidPathSegmentY} from \"../edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {getElementLeftX, RequiredNodeDataGetElementLeftX} from \"./getElementLeftX\";\nimport {getElementTopY, RequiredNodeDataGetElementTopY} from \"./getElementTopY\";\nimport {renderShape} from \"./renderShape\";\n\ntype Props = Container<\n    ElementKey &\n    RequiredNodeDataGetElementLeftX &\n    RequiredNodeDataGetElementTopY &\n    EmbeddedElementsX & EmbeddedElementsY &\n    BorderIndexRight &\n    EmbeddedBorderIndexMaxTop &\n    BorderIndexBottom & BorderIndexMaxBottom & EmbeddedBorderIndexMaxBottom &\n    EmbeddedMidPathSegmentY>;\n\nexport const ContainerComponent: React.FC<Props> = container => {\n    let x = getElementLeftX(container);\n    let y = getElementTopY(container);\n\n    let width = container.embeddedElementsX * ELEMENT_WIDTH + (container.embeddedElementsX - 1) * HORIZONTAL_SPACING\n        + ((container.embeddedElementsX - 1) * container.borderIndexMaxX * 2 + container.borderIndexLeft + container.borderIndexRight) * BORDER_SPACING_X\n        + (container.embeddedElementsX - 1) * container.crossLayerPathSegmentOffsetMaxX * EDGE_SPACING;\n    let height = container.embeddedElementsY * ELEMENT_HEIGHT +\n        (container.embeddedElementsY - 1) * VERTICAL_SPACING +\n        container.borderIndexTop * BORDER_SPACING_TOP +\n        container.embeddedBorderIndexMaxTop * BORDER_SPACING_TOP +\n        container.embeddedBorderIndexMaxBottom * BORDER_SPACING_BOTTOM +\n        container.embeddedMidPathSegmentY * EDGE_SPACING +\n        container.borderIndexBottom * BORDER_SPACING_BOTTOM;\n\n    let textX = x + BORDER_SPACING_X;\n    let textY = y + TEXT_PADDING\n        + (container.shape === \"db-cylinder\" ? DB_CYLINDER_ELLIPSE_Y : 0);\n\n    return (\n        <g key={container.elementKey}>\n            {renderShape(container.shape, x, y, width, height, \"none\")}\n\n            {container.name &&\n            <g transform={\"translate(\" + textX + \" \" + textY + \")\"}>\n                <text\n                    x={0}\n                    y={0}\n                    fill=\"black\"\n                    clipPath={\"url(#clip-element-text-\" + container.elementKey + \")\"}\n                    fontSize={12}\n                >\n                    {container.name.split(\"\\n\").map((line, lineIndex) => (\n                        <tspan key={container.elementKey + \"T\" + lineIndex} x=\"0\" dy=\"1.2em\">{line}</tspan>\n                    ))}\n                </text>\n\n                <clipPath id={\"clip-element-text-\" + container.elementKey}>\n                    <rect\n                        x={0}\n                        y={0}\n                        width={width - 2 * BORDER_SPACING_X}\n                        height={BORDER_SPACING_TOP}/>\n                </clipPath>\n            </g>\n            }\n        </g>\n    );\n};","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexLeft} from \"./BorderIndexLeft\";\nimport {BorderIndexRight} from \"./BorderIndexRight\";\n\nexport type BorderIndexMaxX = { borderIndexMaxX: number };\n\nexport function addBorderIndexMaxXG<N extends BorderIndexLeft & BorderIndexRight, E>(\n    graph: Graph<N, E>\n): Graph<N & BorderIndexMaxX, E> {\n    return transformElements<N, BorderIndexMaxX, E>(graph, determineAndAddBorderIndexMaxX);\n}\n\nfunction determineAndAddBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>) {\n    let maxEmbeddedXBorders = determineBorderIndexMaxX(element);\n    addBorderIndexMaxX(element, maxEmbeddedXBorders);\n}\n\nfunction determineBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>): number {\n    switch (element.kind) {\n        case \"node\": return 0;\n        case \"row\": return Math.max(\n            ...element.elements.map(determineBorderIndexMaxX),\n            element.borderIndexLeft,\n            element.borderIndexRight\n        );\n        case \"column\": return Math.max(\n            ...element.elements.map(determineBorderIndexMaxX),\n            element.borderIndexLeft,\n            element.borderIndexRight\n        );\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nexport function addBorderIndexMaxX(element: Element<BorderIndexLeft & BorderIndexRight>, borderIndexMaxX: number) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxX(nestedElement, borderIndexMaxX));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxX>(element, {\n                borderIndexMaxX: borderIndexMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxX(nestedElement, borderIndexMaxX));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexLeft = { borderIndexLeft: number };\n\nexport function addBorderIndexLeftG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexLeft, E> {\n    return transformElements<N, BorderIndexLeft, E>(graph, addBorderIndexLeft);\n}\n\nexport function addBorderIndexLeft(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexLeft>(element, {\n                borderIndexLeft: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let leftBorderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexLeft) :  [0];\n            let leftBorderIndex = leftBorderIndices[0] + (element.shape ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexLeft>(element, {\n                borderIndexLeft: leftBorderIndex\n            });\n            return leftBorderIndex;\n        }\n        case \"column\": {\n            let leftBorderIndex =\n                Math.max(...element.elements.map(addBorderIndexLeft), 0) +\n                (element.shape ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexLeft>(element, {\n                borderIndexLeft: leftBorderIndex\n            });\n            return leftBorderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexRight = { borderIndexRight: number };\n\nexport function addBorderIndexRightG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexRight, E> {\n    return transformElements<N, BorderIndexRight, E>(graph, addBorderIndexRight);\n}\n\nexport function addBorderIndexRight(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexRight>(element, {\n                borderIndexRight: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexRight) :  [0];\n            let borderIndex = borderIndices[borderIndices.length - 1] + (element.shape ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexRight>(element, {\n                borderIndexRight: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexRight), 0) +\n                (element.shape ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexRight>(element, {\n                borderIndexRight: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexTop = { borderIndexTop: number };\n\nexport function addBorderIndexTopG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexTop, E> {\n    return transformElementsUsingGraph<N, BorderIndexTop, E>(graph, addBorderIndexTopGraph);\n}\n\nfunction addBorderIndexTopGraph(graph: Graph<unknown, unknown>) {\n    addBorderIndexTop(graph.element);\n    graph.syntheticNodes.forEach(node => Object.assign<Node, BorderIndexTop>(node, {borderIndexTop: 0}));\n}\n\nexport function addBorderIndexTop(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexTop>(element, {\n                borderIndexTop: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexTop), 0) +\n                (element.shape ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexTop>(element, {\n                borderIndexTop: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexTop) :  [0];\n            let borderIndex = borderIndices[0] + (element.shape ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexTop>(element, {\n                borderIndexTop: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type BorderIndexBottom = { borderIndexBottom: number };\n\nexport function addBorderIndexBottomG<N, E>(graph: Graph<N, E>): Graph<N & BorderIndexBottom, E> {\n    return transformElements<N, BorderIndexBottom, E>(graph, addBorderIndexBottom);\n}\n\nexport function addBorderIndexBottom(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexBottom>(element, {\n                borderIndexBottom: 0\n            });\n            return 0;\n        }\n        case \"row\": {\n            let borderIndex =\n                Math.max(...element.elements.map(addBorderIndexBottom), 0) +\n                (element.shape ?  1 : 0);\n\n            Object.assign<Row<unknown>, BorderIndexBottom>(element, {\n                borderIndexBottom: borderIndex\n            });\n            return borderIndex;\n        }\n        case \"column\": {\n            let borderIndices = element.elements.length > 0 ? element.elements.map(addBorderIndexBottom) :  [0];\n            let borderIndex = borderIndices[borderIndices.length - 1] + (element.shape ?  1 : 0);\n\n            Object.assign<Column<unknown>, BorderIndexBottom>(element, {\n                borderIndexBottom: borderIndex\n            });\n            return borderIndex;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","export function ascending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o1) - property(o2);\n}\n\nexport function descending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o2) - property(o1);\n}\n\nexport function and<T>(...sortFunctions: ((o1: T, o2: T) => number)[]) {\n    return (o1: T, o2: T) => {\n        let i = 0;\n        while (true) {\n            if (i === sortFunctions.length) return 0;\n            let result = sortFunctions[i](o1, o2);\n            if (result !== 0) return result;\n            i++;\n        }\n    }\n}","import {ascending} from \"./sorting\";\n\nexport function sumOfPreviousRows(max: Map<number, number>): Map<number, number> {\n    let result = new Map<number, number>();\n\n    let sumOfPrevious = 0;\n    Array.from(max.entries()).sort(ascending(entry => entry[0])).forEach(entry => {\n        result.set(entry[0], sumOfPrevious);\n        sumOfPrevious += entry[1];\n    });\n\n    return result;\n}\n\nexport function sumOfPreviousRowsFillLayers(max: Map<number, number>, maxOffsetY: number): Map<number, number> {\n    let result = new Map<number, number>();\n\n    let sumOfPrevious = 0;\n    Array.from(Array(maxOffsetY + 1).keys()).forEach(layer => {\n        result.set(layer, sumOfPrevious);\n        sumOfPrevious += max.get(layer) || 0;\n    });\n\n    return result;\n}","import {Element} from \"./newGraphModel\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {assertNever} from \"./assertNever\";\n\nexport function getMostBottomOffsetElementsY(element: Element<OffsetElementsY>): number {\n    switch (element.kind) {\n        case \"node\":\n            return element.offsetElementsY;\n        case \"row\":\n        case \"column\":\n            return Math.max(...element.elements.map(getMostBottomOffsetElementsY), element.offsetElementsY);\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexBottom} from \"./BorderIndexBottom\";\nimport {OffsetElementsY} from \"./OffsetElementsY\";\nimport {sumOfPreviousRows} from \"../sumOfPreviousRows\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type BorderIndexMaxBottom = { borderIndexMaxBottom: number };\nexport type BorderIndexMaxPreviousBottom = { borderIndexMaxPreviousBottom: number };\nexport type EmbeddedBorderIndexMaxBottom = { embeddedBorderIndexMaxBottom: number };\n\nexport function addBorderIndexMaxBottomG<N extends OffsetElementsY & BorderIndexBottom, E>(\n    graph: Graph<N, E>\n): Graph<N & BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom, E> {\n    return transformElementsUsingGraph<N, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom, E>(\n        graph, determineAndAddBorderIndexBottomAggregates);\n}\n\nfunction determineAndAddBorderIndexBottomAggregates(graph: Graph<OffsetElementsY & BorderIndexBottom, unknown>) {\n    let max = determineBorderIndexMaxBottom(graph.element);\n    let sums = sumOfPreviousRows(max);\n    addBorderIndexMaxBottom(graph.element, max, sums);\n    graph.syntheticNodes.forEach(node => addBorderIndexMaxBottom(node, max, sums));\n}\n\nfunction determineBorderIndexMaxBottom(element: Element<OffsetElementsY & BorderIndexBottom>): Map<number, number> {\n    switch (element.kind) {\n        case \"node\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexBottom);\n            return map;\n        }\n        case \"row\":\n        case \"column\": {\n            let map = new Map<number, number>();\n            map.set(getMostBottomOffsetElementsY(element), element.borderIndexBottom);\n            return element.elements.map(determineBorderIndexMaxBottom).reduce((accumulator, addition) => {\n                Array.from(addition.entries()).forEach((entry) => {\n                    let max = Math.max(accumulator.get(entry[0]) || 0, entry[1]);\n                    accumulator.set(entry[0], max);\n                });\n                return accumulator;\n            }, map);\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction calculateEmbeddedBorders(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY;\n    let to = getMostBottomOffsetElementsY(element) - 1;\n    let embeddedBorders = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedBorders += current.get(i) || 0;\n    }\n    return embeddedBorders;\n}\n\nfunction addBorderIndexMaxBottom(\n    element: Element<OffsetElementsY & BorderIndexBottom>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(getMostBottomOffsetElementsY(element))!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxBottom(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxBottom & BorderIndexMaxPreviousBottom & EmbeddedBorderIndexMaxBottom>(element, {\n                borderIndexMaxBottom: current.get(getMostBottomOffsetElementsY(element))!,\n                borderIndexMaxPreviousBottom: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxBottom: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxBottom(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {BorderIndexTop} from \"./BorderIndexTop\";\nimport {OffsetElementsY} from \"./OffsetElementsY\";\nimport {sumOfPreviousRows} from \"../sumOfPreviousRows\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type BorderIndexMaxTop = { borderIndexMaxTop: number };\nexport type BorderIndexMaxPreviousTop = { borderIndexMaxPreviousTop: number };\nexport type EmbeddedBorderIndexMaxTop = { embeddedBorderIndexMaxTop: number };\n\nexport function addBorderIndexMaxTopG<N extends OffsetElementsY & BorderIndexTop, E>(\n    graph: Graph<N, E>\n): Graph<N & BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop, E> {\n    return transformElementsUsingGraph<N, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop, E>(\n        graph, determineAndAddBorderIndexTopAggregates\n    );\n}\n\nfunction determineAndAddBorderIndexTopAggregates(graph: Graph<OffsetElementsY & BorderIndexTop, unknown>) {\n    let max = determineBorderIndexMaxTop(graph.element);\n    let sums = sumOfPreviousRows(max);\n    addBorderIndexMaxTop(graph.element, max, sums);\n    graph.syntheticNodes.forEach(node => addBorderIndexMaxTop(node, max, sums));\n}\n\nfunction determineBorderIndexMaxTop(element: Element<OffsetElementsY & BorderIndexTop>): Map<number, number> {\n    switch (element.kind) {\n        case \"node\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexTop);\n            return map;\n        }\n        case \"row\":\n        case \"column\": {\n            let map = new Map<number, number>();\n            map.set(element.offsetElementsY, element.borderIndexTop);\n            return element.elements.map(determineBorderIndexMaxTop).reduce((accumulator, addition) => {\n                Array.from(addition.entries()).forEach(([offsetElementsY, borderIndexTop]) => {\n                    let max = Math.max(accumulator.get(offsetElementsY) || 0, borderIndexTop);\n                    accumulator.set(offsetElementsY, max);\n                });\n                return accumulator;\n            }, map);\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction calculateEmbeddedBorders(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY + 1;\n    let to = getMostBottomOffsetElementsY(element);\n    let embeddedBorders = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedBorders += current.get(i) || 0;\n    }\n    return embeddedBorders;\n}\n\nfunction addBorderIndexMaxTop(\n    element: Element<OffsetElementsY & BorderIndexTop>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxTop(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, BorderIndexMaxTop & BorderIndexMaxPreviousTop & EmbeddedBorderIndexMaxTop>(element, {\n                borderIndexMaxTop: current.get(element.offsetElementsY)!,\n                borderIndexMaxPreviousTop: sums.get(element.offsetElementsY)!,\n                embeddedBorderIndexMaxTop: calculateEmbeddedBorders(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                addBorderIndexMaxTop(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type EmbeddedElementsY = { embeddedElementsY: number };\n\nexport function addEmbeddedElementsYG<N, E>(graph: Graph<N, E>): Graph<N & EmbeddedElementsY, E> {\n    return transformElements<N, EmbeddedElementsY, E>(graph, addEmbeddedElementsY);\n}\n\nexport function addEmbeddedElementsY(element: Element<unknown>): number {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, EmbeddedElementsY>(element, {\n                embeddedElementsY: 1\n            });\n            return 1;\n        }\n        case \"row\": {\n            let embeddedElementsY =\n                Math.max(...element.elements.map(addEmbeddedElementsY), 0);\n\n            Object.assign<Row<unknown>, EmbeddedElementsY>(element, {\n                embeddedElementsY: embeddedElementsY\n            });\n            return embeddedElementsY;\n        }\n        case \"column\": {\n            let embeddedElementsY =\n                element.elements.map(addEmbeddedElementsY).reduce((sum, add) => sum + add, 0);\n\n            Object.assign<Column<unknown>, EmbeddedElementsY>(element, {\n                embeddedElementsY: embeddedElementsY\n            });\n            return embeddedElementsY;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {Edge} from \"./newGraphModel\";\n\nexport function fromIsUpperLeft<N extends OffsetElementsX & OffsetElementsY, E>(edge: Edge<N, E>) {\n    if (edge.from.offsetElementsY === edge.to.offsetElementsY) {\n        return edge.from.offsetElementsX <= edge.to.offsetElementsX;\n    }\n    return edge.from.offsetElementsY < edge.to.offsetElementsY;\n}\n\nexport function getUpperLeftNode<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, unknown>): N {\n    return fromIsUpperLeft(edge) ? edge.from : edge.to;\n}\n\nexport function getLowerRightNode<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, unknown>): N {\n    return fromIsUpperLeft(edge) ? edge.to : edge.from;\n}\n\nexport function fromIsLeftUpper<N extends OffsetElementsX & OffsetElementsY, E>(edge: Edge<N, E>) {\n    if (edge.from.offsetElementsX === edge.to.offsetElementsX) {\n        return edge.from.offsetElementsY <= edge.to.offsetElementsY;\n    }\n    return edge.from.offsetElementsX < edge.to.offsetElementsX;\n}\n\nexport function getLeftUpperNode<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, unknown>): N {\n    return fromIsLeftUpper(edge) ? edge.from : edge.to;\n}","import React from \"react\";\nimport {\n    ARROW_HEIGHT,\n    ARROW_WIDTH,\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_X,\n    EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    STROKE_WIDTH, STROKE_WIDTH_SELECTED,\n    VERTICAL_SPACING\n} from \"../styling\";\nimport {BorderIndexMaxBottom} from \"../elementsLayout/BorderIndexMaxBottom\";\nimport {Edge} from \"../newGraphModel\";\nimport {getLeftUpperNode, getUpperLeftNode} from \"../EdgeHelper\";\nimport {MidPathSegmentOffsetY} from \"../edgesLayout/MidPathSegmentOffsetY\";\nimport {ConnectionIndex, NumberOfEdges} from \"../edgesLayout/ConnectionIndexAndNumberOfEdges\";\nimport {EdgeIndex} from \"../edgesLayout/EdgeIndex\";\nimport {IsLowerLayerEdge, LowerLayerEdge, OriginalEdge} from \"../edgesLayout/SyntheticNodesAndEdges\";\nimport {CrossLayerPathSegmentOffsetX} from \"../edgesLayout/CrossLayerPathSegmentOffsetX\";\nimport {getElementLeftX, RequiredNodeDataGetElementLeftX} from \"./getElementLeftX\";\nimport {getElementTopY, RequiredNodeDataGetElementTopY} from \"./getElementTopY\";\n\nfunction edgeEndCoordinates<N extends RequiredNodeDataGetElementLeftX &\n    RequiredNodeDataGetElementTopY & NumberOfEdges>(\n    node: N, edgeIndex: number, otherNode: N\n) {\n    let onLowerSide = node.offsetElementsY <= otherNode.offsetElementsY;\n    let nodeCenteringOffset = (ELEMENT_WIDTH - (((onLowerSide ? node.lowerSideEdges : node.upperSideEdges) || 0) - 1) * EDGE_SPACING) / 2;\n    return {\n        x: getElementLeftX(node) + nodeCenteringOffset + edgeIndex * EDGE_SPACING,\n        y: getElementTopY(node) + (onLowerSide ? ELEMENT_HEIGHT : 0)\n    };\n}\n\nexport const EdgeComponent: React.FC<Edge<RequiredNodeDataGetElementLeftX &\n    RequiredNodeDataGetElementTopY &\n    BorderIndexMaxBottom &\n    NumberOfEdges,\n    LowerLayerEdge<any, unknown> & EdgeIndex & MidPathSegmentOffsetY & ConnectionIndex & CrossLayerPathSegmentOffsetX>> = edge => {\n    let fromNode = edgeEndCoordinates(edge.from, edge.fromIndex, edge.to);\n    let upperNodeEdgesY = getElementTopY(getUpperLeftNode(edge))\n        + ELEMENT_HEIGHT\n        + getUpperLeftNode(edge).borderIndexMaxBottom * BORDER_SPACING_BOTTOM\n        + VERTICAL_SPACING / 2\n        + edge.midPathSegmentOffsetY * EDGE_SPACING;\n    let toNode = edgeEndCoordinates(edge.to, edge.toIndex, edge.from);\n\n    let strokeWidth = edge.selected ? STROKE_WIDTH_SELECTED: STROKE_WIDTH;\n\n    let onLowerSide = edge.to.offsetElementsY <= edge.from.offsetElementsY;\n    let arrow = (\n        <path d={\n            \"M \" + (toNode.x + ARROW_WIDTH) + \" \" + (toNode.y + ARROW_HEIGHT * (onLowerSide ? 1 : -1)) + \" \" +\n            \"L \" + toNode.x + \" \" + toNode.y + \" \" +\n            \"L \" + (toNode.x - ARROW_WIDTH) + \" \" + (toNode.y + ARROW_HEIGHT * (onLowerSide ? 1 : -1))\n        }\n              stroke=\"black\"\n              strokeWidth={strokeWidth}\n              fill=\"none\"\n        />\n    );\n\n    if (!edge.lowerLayerEdge) {\n        return (\n            <g key={edge.edgeIndex}>\n                <path d={\n                    \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n                    \"V \" + upperNodeEdgesY + \" \" +\n                    \"H \" + toNode.x + \" \" +\n                    \"V \" + toNode.y\n                }\n                      stroke=\"black\"\n                      strokeWidth={strokeWidth}\n                      fill=\"none\"\n                />\n                {arrow}\n            </g>\n        );\n    } else {\n        let lowerLayerEdge = edge.lowerLayerEdge as Edge<unknown, MidPathSegmentOffsetY> & IsLowerLayerEdge & OriginalEdge<unknown, unknown>;\n        let lowerNodeEdgesY = getElementTopY(getUpperLeftNode(edge.lowerLayerEdge))\n            + ELEMENT_HEIGHT\n            + getUpperLeftNode(edge.lowerLayerEdge).borderIndexMaxBottom * BORDER_SPACING_BOTTOM\n            + VERTICAL_SPACING / 2\n            + lowerLayerEdge.midPathSegmentOffsetY * EDGE_SPACING;\n        let besideTopNodeX = getElementLeftX(getLeftUpperNode(edge))\n            + ELEMENT_WIDTH + getUpperLeftNode(edge).borderIndexMaxX * BORDER_SPACING_X\n            + (edge.crossLayerPathSegmentOffsetX! + 1) * EDGE_SPACING;\n        return (\n            <g key={edge.edgeIndex}>\n                <path d={\n                    \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n                    \"V \" + upperNodeEdgesY + \" \" +\n                    \"H \" + besideTopNodeX + \" \" +\n                    \"V \" + lowerNodeEdgesY + \" \" +\n                    \"H \" + toNode.x + \" \" +\n                    \"V \" + toNode.y\n                }\n                      stroke=\"black\"\n                      strokeWidth={strokeWidth}\n                      fill=\"none\"\n                />\n                {arrow}\n            </g>\n        );\n    }\n};","import {ElementKey} from \"../elementsLayout/ElementKey\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {Edge, Graph} from \"../newGraphModel\";\nimport {and, ascending, descending} from \"../sorting\";\nimport {EdgeIndex} from \"./EdgeIndex\";\nimport {LowerLayerEdge} from \"./SyntheticNodesAndEdges\";\nimport {fromIsUpperLeft} from \"../EdgeHelper\";\n\nexport type ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\n\nexport type NumberOfEdges = {\n    upperSideEdges?: number\n    lowerSideEdges?: number\n}\n\nexport function addConnectionIndexAndNumberOfEdgesG<\n    N extends OffsetElementsY & OffsetElementsX & ElementKey,\n    E extends EdgeIndex & LowerLayerEdge<unknown, unknown>, G>(\n        graph: Graph<N, E>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    let edgesWithConnectionIndex = graph.edges as unknown as Edge<OffsetElementsX & OffsetElementsY, ConnectionIndex & LowerLayerEdge<unknown, unknown>>[];\n    copyConnectionIndexToLowerLayerEdge(edgesWithConnectionIndex);\n    return graph as Graph<N & NumberOfEdges, E & ConnectionIndex>;\n}\n\ntype EdgeType = Edge<OffsetElementsY & OffsetElementsX & ElementKey, EdgeIndex>\n\nexport function addConnectionIndexAndNumberOfEdges(edges: EdgeType[]) {\n    type NodeSide = {\n        node: OffsetElementsY & OffsetElementsX\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        edge: EdgeType\n        reverseNode: OffsetElementsY & OffsetElementsX\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(edge: EdgeType, firstNode: OffsetElementsY & OffsetElementsX & ElementKey, secondNode: OffsetElementsY & OffsetElementsX, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.offsetElementsY <= secondNode.offsetElementsY ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.elementKey + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            edge: edge,\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge, edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge, edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsY === node.offsetElementsY);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX <= node.offsetElementsX);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX > node.offsetElementsX);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsY !== node.offsetElementsY);\n        let otherLayerBefore = otherLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX <= node.offsetElementsX);\n        let otherLayerAfter = otherLayer.filter(edgeEnd => edgeEnd.reverseNode.offsetElementsX > node.offsetElementsX);\n\n        before.sort(and(descending(e => e.reverseNode.offsetElementsX), descending(e => e.edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(e => e.reverseNode.offsetElementsX), descending(e => e.reverseNode.offsetElementsY)));\n        otherLayerAfter.sort(and(ascending(e => e.reverseNode.offsetElementsX), ascending(e => e.reverseNode.offsetElementsY)));\n        after.sort(and(descending(e => e.reverseNode.offsetElementsX), ascending(e => e.edge.edgeIndex)));\n\n        let all = before.concat(otherLayerBefore).concat(otherLayerAfter).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}\n\nfunction copyConnectionIndexToLowerLayerEdge(edges: Edge<OffsetElementsX & OffsetElementsY, ConnectionIndex & LowerLayerEdge<unknown, unknown>>[]) {\n    edges.forEach(edge => {\n        if (edge.lowerLayerEdge) {\n            Object.assign<Edge<unknown, unknown>, ConnectionIndex>(edge.lowerLayerEdge, {\n                fromIndex: 0,\n                toIndex: getLowerRightNodeIndex(edge)\n            });\n        }\n    });\n}\n\nexport function getUpperLeftNodeIndex<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, ConnectionIndex>): number {\n    return fromIsUpperLeft(edge) ? edge.fromIndex : edge.toIndex;\n}\n\nexport function getLowerRightNodeIndex<N extends OffsetElementsX & OffsetElementsY>(edge: Edge<N, ConnectionIndex>): number {\n    return fromIsUpperLeft(edge) ? edge.toIndex : edge.fromIndex;\n}","import {allElements, allNodes, Edge, Graph, Node, node} from \"../newGraphModel\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {getLowerRightNode, getUpperLeftNode} from \"../EdgeHelper\";\nimport {ElementKey} from \"../elementsLayout/ElementKey\";\n\nexport type NodeData = OffsetElementsX & OffsetElementsY & ElementKey\n\nexport type IsLowerLayerEdge = {\n    isLowerLayerEdge: true\n};\n\nexport type OriginalEdge<N, E> = {\n    originalEdge: Edge<N, E>\n};\n\nexport type LowerLayerEdge<N, E> = {\n    lowerLayerEdge?: Edge<N, E> & IsLowerLayerEdge & OriginalEdge<N, E>\n}\n\nexport function isMultiLayerEdge(edge: Edge<OffsetElementsY, unknown>) {\n    return Math.abs(edge.from.offsetElementsY - edge.to.offsetElementsY) >= 2;\n}\n\nexport function addSyntheticNodesAndEdgesG(graph: Graph<NodeData, unknown>): Graph<NodeData, LowerLayerEdge<NodeData, unknown>> {\n    let elementKey = Math.max(...allElements(graph.element).map(element => element.elementKey));\n\n    let grid = new Map<string, boolean>();\n    allNodes(graph.element)\n        .filter(node => node.visible)\n        .forEach(node => grid.set(node.offsetElementsX + \"_\" + node.offsetElementsY, true));\n\n    function nodesOnPath(edge: Edge<OffsetElementsX & OffsetElementsY, unknown>): boolean {\n        let lowerRightNode = getLowerRightNode(edge);\n        let upperLeftNode = getUpperLeftNode(edge);\n        let offsetElementsX = Math.min(upperLeftNode.offsetElementsX, lowerRightNode.offsetElementsX);\n\n        for (let i = upperLeftNode.offsetElementsY + 1; i <= lowerRightNode.offsetElementsY - 1; i++) {\n            if (grid.has(offsetElementsX + \"_\" + i)) return true;\n        }\n        return false;\n    }\n\n    let syntheticNodes: NodeData[] = [];\n    let syntheticEdges = graph.edges\n        .filter(isMultiLayerEdge)\n        .filter(nodesOnPath)\n        .map(edge => {\n            let lowerRightNode = getLowerRightNode(edge);\n            let upperLeftNode = getUpperLeftNode(edge);\n            elementKey++;\n            let from: NodeData = Object.assign<Node, NodeData>(node(), {\n                elementKey: elementKey,\n                offsetElementsY: lowerRightNode.offsetElementsY - 1,\n                offsetElementsX: Math.min(upperLeftNode.offsetElementsX, lowerRightNode.offsetElementsX)\n            });\n            syntheticNodes.push(from);\n            let lowerLayerEdgeProperty: LowerLayerEdge<NodeData, unknown> = {\n                lowerLayerEdge: {\n                    from: from,\n                    to: lowerRightNode,\n                    isLowerLayerEdge: true,\n                    originalEdge: edge\n                }};\n            Object.assign<Edge<NodeData, unknown>, LowerLayerEdge<NodeData, unknown>>(\n                edge, lowerLayerEdgeProperty);\n            return lowerLayerEdgeProperty.lowerLayerEdge;\n        });\n\n    return Object.assign(graph, {syntheticNodes, syntheticEdges});\n}","import {and, ascending, descending} from \"../sorting\";\nimport {Edge, Graph} from \"../newGraphModel\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {getLowerRightNode, getUpperLeftNode} from \"../EdgeHelper\";\nimport {\n    ConnectionIndex,\n    getLowerRightNodeIndex,\n    getUpperLeftNodeIndex,\n    NumberOfEdges\n} from \"./ConnectionIndexAndNumberOfEdges\";\nimport {EdgeIndex} from \"./EdgeIndex\";\nimport {IsLowerLayerEdge, isMultiLayerEdge, OriginalEdge} from \"./SyntheticNodesAndEdges\";\n\nexport type MidPathSegmentOffsetY = {\n    midPathSegmentOffsetY: number\n}\n\nexport function addMidPathSegmentOffsetYG<N extends OffsetElementsY & OffsetElementsX & NumberOfEdges, E extends ConnectionIndex & EdgeIndex>(graph: Graph<N, E>):\n    Graph<N, E & MidPathSegmentOffsetY> {\n    addMidPathSegmentOffsetY(graph.edges.concat(graph.syntheticEdges));\n    return graph as unknown as Graph<N, E & MidPathSegmentOffsetY>;\n}\n\nexport function addMidPathSegmentOffsetY(edges: Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, ConnectionIndex & EdgeIndex>[]) {\n    let groupedByOffsetElementsY = new Map<number, (Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, ConnectionIndex & EdgeIndex>)[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperLeftNode(edge).offsetElementsY;\n        let edges = groupedByOffsetElementsY.get(key) || [];\n        edges.push(edge);\n        groupedByOffsetElementsY.set(key, edges);\n    });\n\n    Array.from(groupedByOffsetElementsY.values()).forEach(addMidPathSegmentOffsetYForLayer);\n}\n\nfunction addMidPathSegmentOffsetYForLayer(edges: Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, EdgeIndex & ConnectionIndex>[]) {\n    let groupedByUpperNode = new Map<string, Edge<OffsetElementsY & OffsetElementsX & NumberOfEdges, EdgeIndex & ConnectionIndex>[]>();\n\n    edges.forEach(edge => {\n        let upperLeftNode = getUpperLeftNode(edge);\n        let key = upperLeftNode.offsetElementsY + \"_\" + upperLeftNode.offsetElementsX;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerRightNode(edge).offsetElementsY === getUpperLeftNode(edge).offsetElementsY);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerRightNode(edge).offsetElementsX <= getUpperLeftNode(edge).offsetElementsX);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerRightNode(edge).offsetElementsX > getUpperLeftNode(edge).offsetElementsX);\n        let otherLayer = edges.filter(edge => getLowerRightNode(edge).offsetElementsY !== getUpperLeftNode(edge).offsetElementsY);\n        let otherLayerBefore = otherLayer.filter(edge => {\n            if (getLowerRightNode(edge).offsetElementsX === getUpperLeftNode(edge).offsetElementsX) {\n                if (isMultiLayerEdge(edge)) return false;\n                if ((edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return false;\n\n                return getLowerRightNodeIndex(edge) - ((getLowerRightNode(edge).upperSideEdges || 1) - 1) / 2 <\n                    getUpperLeftNodeIndex(edge) - ((getUpperLeftNode(edge).lowerSideEdges || 1) - 1) / 2;\n            }\n            return getLowerRightNode(edge).offsetElementsX <= getUpperLeftNode(edge).offsetElementsX\n        });\n        let otherLayerAfter = otherLayer.filter(edge => {\n            if (getLowerRightNode(edge).offsetElementsX === getUpperLeftNode(edge).offsetElementsX) {\n                if (isMultiLayerEdge(edge)) return true;\n                if ((edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return true;\n\n                return getLowerRightNodeIndex(edge) - ((getLowerRightNode(edge).upperSideEdges || 1) - 1) / 2 >=\n                    getUpperLeftNodeIndex(edge) - ((getUpperLeftNode(edge).lowerSideEdges || 1) - 1) / 2;\n            }\n            return getLowerRightNode(edge).offsetElementsX > getUpperLeftNode(edge).offsetElementsX\n        });\n\n        sameLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), descending(edge => edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), ascending(edge => edge.edgeIndex)));\n        otherLayerAfter.sort(and(\n            descending(edge => getLowerRightNode(edge).offsetElementsX),\n            ascending(edge => {\n                if (!(edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return 0;\n                let edgeWithOriginalEdge = edge as unknown as OriginalEdge<OffsetElementsX & OffsetElementsY, EdgeIndex>;\n                return getUpperLeftNode(edgeWithOriginalEdge.originalEdge).offsetElementsX;\n            }),\n            ascending(edge => {\n                if (!(edge as unknown as IsLowerLayerEdge).isLowerLayerEdge) return 0;\n                let edgeWithOriginalEdge = edge as unknown as OriginalEdge<OffsetElementsX & OffsetElementsY, EdgeIndex>;\n                return edgeWithOriginalEdge.originalEdge.edgeIndex;\n            }),\n            descending(edge => edge.edgeIndex)\n        ));\n        sameLayerAfter.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), descending(edge => edge.edgeIndex)));\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<OffsetElementsY & OffsetElementsX, unknown>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let index = indexOffset + indexInArray;\n            Object.assign<Edge<OffsetElementsY & OffsetElementsX, unknown>, MidPathSegmentOffsetY>(edge, {\n                midPathSegmentOffsetY: index\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}","import {Column, Element, Graph, Node, Row, transformElements} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\n\nexport type ElementKey = { elementKey: number };\n\nexport function addElementKeyG<N, E>(graph: Graph<N, E>): Graph<N & ElementKey, E> {\n    return transformElements<N, ElementKey, E>(graph, addElementKey);\n}\n\nexport function addElementKey(\n    element: Element<unknown>,\n    accumulator: { elementKey: number } = { elementKey: 0 }) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, ElementKey>(element, {\n                elementKey: accumulator.elementKey\n            });\n            accumulator.elementKey++;\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, ElementKey>(element, {\n                elementKey: accumulator.elementKey\n            });\n            accumulator.elementKey++;\n            element.elements.forEach(nestedElement => addElementKey(nestedElement, accumulator));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, ElementKey>(element, {\n                elementKey: accumulator.elementKey\n            });\n            accumulator.elementKey++;\n            element.elements.forEach(nestedElement => addElementKey(nestedElement, accumulator));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Column, Edge, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {getUpperLeftNode} from \"../EdgeHelper\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {MidPathSegmentOffsetY} from \"./MidPathSegmentOffsetY\";\nimport {sumOfPreviousRowsFillLayers} from \"../sumOfPreviousRows\";\nimport {assertNever} from \"../assertNever\";\nimport {getMostBottomOffsetElementsY} from \"../getMostBottomOffsetElementsY\";\n\nexport type MidPathSegmentOffsetMaxY = { midPathSegmentOffsetMaxY: number };\nexport type MidPathSegmentOffsetMaxPreviousY = { midPathSegmentOffsetMaxPreviousY: number }\nexport type EmbeddedMidPathSegmentY = { embeddedMidPathSegmentY: number };\n\nexport type NodeData = OffsetElementsX & OffsetElementsY\nexport type EdgeData = MidPathSegmentOffsetY\ntype EdgeType = Edge<NodeData, EdgeData>\nexport type AddedNodeData = MidPathSegmentOffsetMaxY & MidPathSegmentOffsetMaxPreviousY & EmbeddedMidPathSegmentY\n\nexport function addMidPathSegmentOffsetYAggregatesG<N extends NodeData, E extends EdgeData>(\n    graph: Graph<N, E>\n): Graph<N & AddedNodeData, E> {\n    return transformElementsUsingGraph<N, AddedNodeData, E>(graph, addMidPathSegmentOffsetYAggregates);\n}\n\nexport function addMidPathSegmentOffsetYAggregates<N extends NodeData, E extends EdgeData>(graph: Graph<N, E>) {\n    let maxOffsetY = getMostBottomOffsetElementsY(graph.element);\n    let maxs = determineMidPathSegmentMaxOffsetY(graph.edges.concat(graph.syntheticEdges));\n    let sums = sumOfPreviousRowsFillLayers(maxs, maxOffsetY);\n    applyMidPathSegmentOffsetYAggregates(graph.element, maxs, sums);\n    graph.syntheticNodes.forEach(node => applyMidPathSegmentOffsetYAggregates(node, maxs, sums));\n}\n\nfunction determineMidPathSegmentMaxOffsetY(edges: EdgeType[]): Map<number, number> {\n    let result = new Map<number, number>();\n    edges.forEach(edge => {\n        let offsetElementsY = getUpperLeftNode(edge).offsetElementsY;\n        let midPathSegmentOffsetY = result.get(offsetElementsY) || 0;\n        result.set(offsetElementsY, Math.max(midPathSegmentOffsetY, edge.midPathSegmentOffsetY));\n    });\n    return result;\n}\n\nfunction calculateEmbeddedPaths(element: Element<OffsetElementsY>, current: Map<number, number>) {\n    let from = element.offsetElementsY;\n    let to = getMostBottomOffsetElementsY(element) - 1;\n    let embeddedPaths = 0;\n    for (let i = from; i <= to; i++) {\n        embeddedPaths += current.get(i) || 0;\n    }\n    return embeddedPaths;\n}\n\nfunction applyMidPathSegmentOffsetYAggregates<N extends NodeData, E extends EdgeData>(\n    element: Element<N>,\n    current: Map<number, number>,\n    sums: Map<number, number>\n) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, AddedNodeData>(element, {\n                midPathSegmentOffsetMaxY: current.get(element.offsetElementsY) || 0,\n                midPathSegmentOffsetMaxPreviousY: sums.get(element.offsetElementsY) || 0,\n                embeddedMidPathSegmentY: 0\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, AddedNodeData>(element, {\n                midPathSegmentOffsetMaxY: current.get(element.offsetElementsY) || 0,\n                midPathSegmentOffsetMaxPreviousY: sums.get(element.offsetElementsY) || 0,\n                embeddedMidPathSegmentY: calculateEmbeddedPaths(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                applyMidPathSegmentOffsetYAggregates(nestedElement, current, sums));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, AddedNodeData>(element, {\n                midPathSegmentOffsetMaxY: current.get(element.offsetElementsY) || 0,\n                midPathSegmentOffsetMaxPreviousY: sums.get(element.offsetElementsY) || 0,\n                embeddedMidPathSegmentY: calculateEmbeddedPaths(element, current)\n            });\n            element.elements.forEach(nestedElement =>\n                applyMidPathSegmentOffsetYAggregates(nestedElement, current, sums));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import {Edge, Graph} from \"../newGraphModel\";\n\nexport type EdgeIndex = {\n    edgeIndex: number\n}\n\nexport function addEdgeIndexG<N, E>(graph: Graph<N, E>):\n    Graph<N, E & EdgeIndex> {\n    addEdgeIndex(graph.edges.concat(graph.syntheticEdges));\n    return graph as unknown as Graph<N, E & EdgeIndex>;\n}\n\nexport function addEdgeIndex(edges: Edge<unknown, unknown>[]) {\n    edges.forEach((edge, index) => {\n        Object.assign<Edge<unknown, unknown>, EdgeIndex>(\n            edge, {edgeIndex: index});\n    });\n}","import {Edge, Graph} from \"../newGraphModel\";\nimport {OffsetElementsX} from \"../elementsLayout/OffsetElementsX\";\nimport {LowerLayerEdge} from \"./SyntheticNodesAndEdges\";\nimport {OffsetElementsY} from \"../elementsLayout/OffsetElementsY\";\nimport {EdgeIndex} from \"./EdgeIndex\";\nimport {getLeftUpperNode, getLowerRightNode} from \"../EdgeHelper\";\nimport {and, ascending} from \"../sorting\";\n\nexport type CrossLayerPathSegmentOffsetX = {\n    crossLayerPathSegmentOffsetX?: number\n}\n\nexport type RequiredNodeDataTypes = OffsetElementsX & OffsetElementsY\nexport type RequiredEdgeDataTypes = EdgeIndex & LowerLayerEdge<unknown, unknown>\nexport type RequiredEdgeType = Edge<RequiredNodeDataTypes, RequiredEdgeDataTypes>\n\nexport function addCrossLayerPathSegmentOffsetXG<N extends RequiredNodeDataTypes, E extends RequiredEdgeDataTypes>(graph: Graph<N, E>):\n    Graph<N, E & CrossLayerPathSegmentOffsetX> {\n    addCrossLayerPathSegmentOffsetX(graph.edges);\n    return graph as unknown as Graph<N, E & CrossLayerPathSegmentOffsetX>;\n}\n\nexport function addCrossLayerPathSegmentOffsetX(edges: RequiredEdgeType[]) {\n    let groupedByOffsetElementsX = new Map<number, RequiredEdgeType[]>();\n\n    edges.filter(edge => edge.lowerLayerEdge).forEach(edge => {\n        let key = getLeftUpperNode(edge).offsetElementsX;\n        let edges = groupedByOffsetElementsX.get(key) || [];\n        edges.push(edge);\n        groupedByOffsetElementsX.set(key, edges);\n    });\n\n    Array.from(groupedByOffsetElementsX.values()).forEach(addCrossLayerPathSegmentOffsetXForSlice);\n}\n\nfunction addCrossLayerPathSegmentOffsetXForSlice(edges: RequiredEdgeType[]) {\n    let groupedByUpperNode = new Map<string, RequiredEdgeType[]>();\n\n    edges.forEach(edge => {\n        let upperLeftNode = getLeftUpperNode(edge);\n        let key = upperLeftNode.offsetElementsY + \"_\" + upperLeftNode.offsetElementsX;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        edges.sort(and(ascending(edge => getLowerRightNode(edge).offsetElementsX), ascending(edge => edge.edgeIndex)));\n\n        function addOffset(edge: RequiredEdgeType, indexInArray: number) {\n            let index = indexOffset + indexInArray;\n            Object.assign<RequiredEdgeType, CrossLayerPathSegmentOffsetX>(edge, {\n                crossLayerPathSegmentOffsetX: index\n            });\n        }\n\n        edges.forEach((edge, index) => addOffset(edge, index));\n\n        indexOffset += edges.length;\n    });\n}","import {Column, Element, Graph, Node, Row, transformElementsUsingGraph} from \"../newGraphModel\";\nimport {assertNever} from \"../assertNever\";\nimport {CrossLayerPathSegmentOffsetX} from \"./CrossLayerPathSegmentOffsetX\";\n\nexport type CrossLayerPathSegmentOffsetMaxX = { crossLayerPathSegmentOffsetMaxX: number };\n\ntype RequiredEdgeDataTypes = CrossLayerPathSegmentOffsetX;\n\nexport function addCrossLayerPathSegmentOffsetMaxXG<N, E extends RequiredEdgeDataTypes>(\n    graph: Graph<N, E>\n): Graph<N & CrossLayerPathSegmentOffsetMaxX, E> {\n    return transformElementsUsingGraph<N, CrossLayerPathSegmentOffsetMaxX, E>(graph, determineAndAddCrossLayerPathSegmentOffsetMaxX);\n}\n\nfunction determineAndAddCrossLayerPathSegmentOffsetMaxX(graph: Graph<unknown, RequiredEdgeDataTypes>) {\n    let crossLayerPathSegmentOffsetMaxX = determineCrossLayerPathSegmentOffsetMaxX(graph.edges);\n    addCrossLayerPathSegmentOffsetMaxX(graph.element, crossLayerPathSegmentOffsetMaxX);\n}\n\nfunction determineCrossLayerPathSegmentOffsetMaxX(edges: RequiredEdgeDataTypes[]): number {\n    return Math.max(...edges.map(edge => (edge.crossLayerPathSegmentOffsetX || 0) + 1), 0);\n}\n\nexport function addCrossLayerPathSegmentOffsetMaxX(element: Element<unknown>, crossLayerPathSegmentOffsetMaxX: number) {\n    switch (element.kind) {\n        case \"node\": {\n            Object.assign<Node, CrossLayerPathSegmentOffsetMaxX>(element, {\n                crossLayerPathSegmentOffsetMaxX: crossLayerPathSegmentOffsetMaxX\n            });\n            return;\n        }\n        case \"row\": {\n            Object.assign<Row<unknown>, CrossLayerPathSegmentOffsetMaxX>(element, {\n                crossLayerPathSegmentOffsetMaxX: crossLayerPathSegmentOffsetMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addCrossLayerPathSegmentOffsetMaxX(nestedElement, crossLayerPathSegmentOffsetMaxX));\n            return;\n        }\n        case \"column\": {\n            Object.assign<Column<unknown>, CrossLayerPathSegmentOffsetMaxX>(element, {\n                crossLayerPathSegmentOffsetMaxX: crossLayerPathSegmentOffsetMaxX\n            });\n            element.elements.forEach(nestedElement =>\n                addCrossLayerPathSegmentOffsetMaxX(nestedElement, crossLayerPathSegmentOffsetMaxX));\n            return;\n        }\n        default: {\n            assertNever(element);\n        }\n    }\n}","import React, {useState} from \"react\";\nimport {allContainers, allNodes, Element, graph, Graph, Node} from \"./newGraphModel\";\nimport {NodeComponent} from \"./graphics/NodeComponent\";\nimport {assertNever} from \"./assertNever\";\nimport {addOffsetElementsYG, OffsetElementsY} from \"./elementsLayout/OffsetElementsY\";\nimport {addOffsetElementsXG, OffsetElementsX} from \"./elementsLayout/OffsetElementsX\";\nimport {addEmbeddedElementsXG} from \"./elementsLayout/EmbeddedElementsX\";\nimport {ContainerComponent} from \"./graphics/ContainerComponent\";\nimport {addBorderIndexMaxXG, BorderIndexMaxX} from \"./elementsLayout/BorderIndexMaxX\";\nimport {addBorderIndexLeftG} from \"./elementsLayout/BorderIndexLeft\";\nimport {addBorderIndexRightG} from \"./elementsLayout/BorderIndexRight\";\nimport {addBorderIndexTopG} from \"./elementsLayout/BorderIndexTop\";\nimport {addBorderIndexBottomG} from \"./elementsLayout/BorderIndexBottom\";\nimport {\n    addBorderIndexMaxBottomG,\n    BorderIndexMaxBottom,\n    BorderIndexMaxPreviousBottom\n} from \"./elementsLayout/BorderIndexMaxBottom\";\nimport {addBorderIndexMaxTopG, BorderIndexMaxPreviousTop, BorderIndexMaxTop} from \"./elementsLayout/BorderIndexMaxTop\";\nimport {addEmbeddedElementsYG} from \"./elementsLayout/EmbeddedElementsY\";\nimport {EdgeComponent} from \"./graphics/EdgeComponent\";\nimport {addMidPathSegmentOffsetYG} from \"./edgesLayout/MidPathSegmentOffsetY\";\nimport {addElementKeyG} from \"./elementsLayout/ElementKey\";\nimport {\n    addMidPathSegmentOffsetYAggregatesG,\n    MidPathSegmentOffsetMaxPreviousY,\n    MidPathSegmentOffsetMaxY\n} from \"./edgesLayout/MidPathSegmentOffsetYAggregates\";\nimport {addConnectionIndexAndNumberOfEdgesG} from \"./edgesLayout/ConnectionIndexAndNumberOfEdges\";\nimport {addEdgeIndexG} from \"./edgesLayout/EdgeIndex\";\nimport {addSyntheticNodesAndEdgesG} from \"./edgesLayout/SyntheticNodesAndEdges\";\nimport {addCrossLayerPathSegmentOffsetXG} from \"./edgesLayout/CrossLayerPathSegmentOffsetX\";\nimport {\n    addCrossLayerPathSegmentOffsetMaxXG,\n    CrossLayerPathSegmentOffsetMaxX\n} from \"./edgesLayout/CrossLayerPathSegmentOffsetMaxX\";\nimport {\n    BORDER_SPACING_BOTTOM,\n    BORDER_SPACING_TOP,\n    BORDER_SPACING_X,\n    EDGE_SPACING,\n    ELEMENT_HEIGHT,\n    ELEMENT_WIDTH,\n    HORIZONTAL_SPACING,\n    MARGIN_X,\n    MARGIN_Y,\n    VERTICAL_SPACING\n} from \"./styling\";\n\nfunction width(element: Element<OffsetElementsX & BorderIndexMaxX & CrossLayerPathSegmentOffsetMaxX>): number {\n    switch (element.kind) {\n        case \"node\": return MARGIN_X * 2\n            + element.offsetElementsX * HORIZONTAL_SPACING\n            + (element.offsetElementsX + 1) * ELEMENT_WIDTH\n            + element.borderIndexMaxX * (element.offsetElementsX + 1) * 2 * BORDER_SPACING_X\n            + element.crossLayerPathSegmentOffsetMaxX * (element.offsetElementsX + 1) * EDGE_SPACING;\n        case \"row\":\n        case \"column\": return Math.max(...element.elements.map(width), 0);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\nfunction height(element: Element<OffsetElementsY &\n    BorderIndexMaxTop & BorderIndexMaxPreviousTop &\n    BorderIndexMaxBottom & BorderIndexMaxPreviousBottom &\n    MidPathSegmentOffsetMaxY & MidPathSegmentOffsetMaxPreviousY>): number {\n    switch (element.kind) {\n        case \"node\": return MARGIN_Y * 2\n            + (element.offsetElementsY + 1) * VERTICAL_SPACING\n            + (element.offsetElementsY + 1) * ELEMENT_HEIGHT\n            + (element.borderIndexMaxPreviousTop + element.borderIndexMaxTop) * BORDER_SPACING_TOP\n            + (element.borderIndexMaxPreviousBottom + element.borderIndexMaxBottom) * BORDER_SPACING_BOTTOM\n            + (element.midPathSegmentOffsetMaxPreviousY + element.midPathSegmentOffsetMaxY) * EDGE_SPACING;\n        case \"row\":\n        case \"column\": return Math.max(...element.elements.map(height), 0);\n        default: {\n            assertNever(element);\n        }\n    }\n}\n\ntype DiagramProps = {\n    initialGraph: Graph<unknown, unknown>\n}\n\nexport const Diagram: React.FC<DiagramProps> = props => {\n\n    const [graphState, setGraph] = useState(props.initialGraph);\n\n    function onNodeClick(node: Node) {\n        function setSelected(state: boolean) {\n            node.selected = state;\n            setGraph(oldGraph => {\n                oldGraph.edges\n                    .filter(edge => edge.from === node || edge.to === node)\n                    .forEach(edge => edge.selected = state);\n\n                return graph(oldGraph.element, oldGraph.edges, oldGraph.syntheticNodes, oldGraph.syntheticEdges)\n            });\n        }\n\n        setSelected(!node.selected);\n    }\n\n    return [graphState]\n        .map(addElementKeyG)\n        .map(addOffsetElementsXG)\n        .map(addOffsetElementsYG)\n        .map(addSyntheticNodesAndEdgesG)\n        .map(addBorderIndexLeftG)\n        .map(addBorderIndexRightG)\n        .map(addBorderIndexTopG)\n        .map(addBorderIndexBottomG)\n        .map(addBorderIndexMaxXG)\n        .map(addBorderIndexMaxTopG)\n        .map(addBorderIndexMaxBottomG)\n        .map(addEmbeddedElementsXG)\n        .map(addEmbeddedElementsYG)\n        .map(addEdgeIndexG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(addMidPathSegmentOffsetYG)\n        .map(addMidPathSegmentOffsetYAggregatesG)\n        .map(addCrossLayerPathSegmentOffsetXG)\n        .map(addCrossLayerPathSegmentOffsetMaxXG)\n        .map(graph => {\n            return (\n                <svg viewBox={\"0 0 \" + width(graph.element) + \" \" + height(graph.element)}>\n                    {allContainers(graph.element).filter(c => c.shape).map(ContainerComponent)}\n                    {allNodes(graph.element).map(node => (<NodeComponent key={node.elementKey+\"O\"} node={node} onNodeClick={onNodeClick}/>))}\n                    {graph.edges.map(EdgeComponent)}\n                </svg>\n            );\n        })[0];\n};","import React from \"react\";\nimport {edge, Element, gap, graph, node} from \"./newGraphModel\";\nimport {Diagram} from \"./Diagram\";\n\nexport const Sample: React.FC = () => {\n    let node_1_1 = node(\"Some node\");\n    let node_1_2 = node();\n    let node_2_1 = node();\n    let node_2_2 = node({name: \"Component node\", symbol: \"component\"});\n    let node_3_1 = node({name: \"Another component node\", symbol: \"component\"});\n    let node_3_2 = node();\n    let node_4_1 = node(\"Some node with long text\");\n    let node_4_2 = node();\n    let node_4_3 = node();\n    let node_4_4 = node();\n    let node_4_5 = node();\n    let node_5_1 = node();\n    let node_5_2 = node();\n    let node_6_1 = node();\n    let node_6_2 = node();\n    let node_6_3 = node();\n    let node_6_4 = node();\n    let node_7_1 = node({visible: false});\n    let node_7_2 = node();\n    let node_8_1 = node();\n    let node_8_2 = node();\n    let element: Element<unknown> = {\n        kind: \"column\", elements: [{\n            kind: \"row\", name: \"Top row\", shape: \"rectangle\", elements: [{\n                kind: \"column\", name: \"Left column\", shape: \"rectangle\", elements: [node_1_1, node_1_2]\n            }, {\n                kind: \"column\", name: \"Right column\", shape: \"rectangle\", elements: [{\n                    kind: \"row\", name: \"Nested row\", shape: \"rectangle\", elements: [node_2_1, node_2_2]\n                }, node_3_1, node_3_2]\n            }, node_7_1, {\n                kind: \"column\", elements: [node_8_1, gap(), node_8_2]\n            }, node_7_2]\n        }, {\n            kind: \"row\", elements: [node_4_1, node_4_2, node_4_3, node_4_4, node_4_5]\n        }, {\n            kind: \"row\", name: \"Bottom row\", shape: \"rectangle\", elements: [{\n                kind: \"row\", name: \"Left row in row\", shape: \"rectangle\", elements: [node_5_1, node_5_2]\n            }, {\n                kind: \"row\", name: \"Right row in row\", shape: \"rectangle\", elements: [node_6_1, node_6_2, node_6_3, node_6_4]\n            }]\n        }]\n    };\n    let edges = [\n        edge(node_1_1, node_4_1),\n        edge(node_1_1, node_1_2),\n        edge(node_2_1, node_1_1),\n        edge(node_2_1, node_1_1),\n        edge(node_2_1, node_2_2),\n        edge(node_2_1, node_2_2),\n        edge(node_2_1, node_4_1),\n        edge(node_2_1, node_4_1),\n        edge(node_2_1, node_4_3),\n        edge(node_2_1, node_4_3),\n        edge(node_2_1, node_4_4),\n        edge(node_2_2, node_4_4),\n        edge(node_2_2, node_4_2),\n        edge(node_2_2, node_6_4),\n        edge(node_3_2, node_4_1),\n        edge(node_3_2, node_4_1),\n        edge(node_3_2, node_4_3),\n        edge(node_3_2, node_4_4),\n        edge(node_3_2, node_4_5),\n        edge(node_3_2, node_4_5),\n        edge(node_4_1, node_4_2),\n        edge(node_5_1, node_4_2),\n        edge(node_5_2, node_4_2),\n        edge(node_6_1, node_4_2),\n        edge(node_6_2, node_4_2),\n        edge(node_6_3, node_4_2),\n        edge(node_6_3, node_4_2),\n        edge(node_6_4, node_4_2),\n        edge(node_5_1, node_4_5),\n        edge(node_5_2, node_4_5),\n        edge(node_6_1, node_4_5),\n        edge(node_6_2, node_4_5),\n        edge(node_6_3, node_4_5),\n        edge(node_6_4, node_4_5),\n        edge(node_6_4, node_6_3),\n        edge(node_6_4, node_6_3),\n        edge(node_7_2, node_6_4),\n        edge(node_8_1, node_8_2)\n    ];\n    return (\n        <Diagram initialGraph={graph(element, edges)}/>\n    );\n};","import React from \"react\";\nimport {component, db, dbTable, edge, Element, gap, graph, node, queue, s3Bucket, system} from \"./newGraphModel\";\nimport {Diagram} from \"./Diagram\";\n\nfunction createInitialGraph() {\n    let overall = new class {\n        customerBrowser = new class {\n            contentViewComponent = component(\"Content View HTML\");\n            searchViewComponent = component(\"Search View HTML\");\n            pdpViewComponent = component(\"PDP View HTML\");\n\n            element: Element<unknown> = {\n                kind: \"row\", name: \"Customer Browser\", shape: \"deployment-box\",\n                elements: [\n                    gap(),\n                    this.contentViewComponent, gap(), gap(), gap(),\n                    this.searchViewComponent, gap(), gap(), gap(), gap(),\n                    this.pdpViewComponent, gap(), gap(), gap()\n                ]\n            };\n        }();\n\n        coreAccount = new class {\n            edutainment = new class {\n                contentView = new class {\n                    siteMap = component(\"Content Site Map\");\n                    component = component(\"Content View\");\n\n                    element: Element<unknown> = {\n                        kind: \"row\", name: \"Content View\", shape: \"deployment-box\",\n                        elements: [this.siteMap, this.component]\n                    };\n                }();\n\n                element: Element<unknown> = {\n                    kind: \"column\", elements: [this.contentView.element]\n                };\n            }();\n\n            core = new class {\n                pdpView = new class {\n                    searchViewComponent = component(\"Search View\");\n                    pdpViewComponent = component(\"PDP View\");\n\n                    element: Element<unknown> = {\n                        kind: \"row\",\n                        elements: [gap(), gap(), {\n                            kind: \"row\", name: \"PDP View\", shape: \"deployment-box\",\n                            elements: [\n                                gap(),\n                                this.searchViewComponent,\n                                gap(), gap(), gap(), gap(),\n                                this.pdpViewComponent,\n                                gap(), gap(), gap()\n                            ]\n                        }]\n                    };\n                }();\n\n                services = new class {\n                    coreSiteMap = new class {\n                        siteMapGenerator = component(\"Site Map Generator\");\n\n                        element: Element<unknown> = {\n                            kind: \"column\", elements: [gap(), {\n                                kind: \"row\", name: \"Site Map Generator\", shape: \"deployment-box\", elements: [\n                                    this.siteMapGenerator\n                                ]\n                            }]\n                        };\n                    }();\n\n                    search = new class {\n                        factFinderDB = db(\"FACTFinder DB\");\n                        factFinderAPI = component(\"FACTFinder API\");\n\n                        factFinderFeedServiceDB = db(\"FACTFinder Feed\\nService DB\");\n                        factFinderUpdater = component(\"FACTFinder Updater\");\n                        ffProductImporter = component(\"Product Importer\");\n                        ffProductCampaignsImporter = component(\"Product Campaigns\\nImporter\");\n                        ffCategoryImporter = component(\"Category Importer\");\n\n                        element: Element<unknown> = {\n                            kind: \"column\", elements: [{\n                                kind: \"row\",\n                                elements: [\n                                    this.factFinderDB,\n                                    {\n                                        kind: \"row\", name: \"FACT Finder\", shape: \"deployment-box\", elements: [\n                                            gap(), this.factFinderAPI, gap()\n                                        ]\n                                    }\n                                ]\n                            }, {\n                                kind: \"row\",\n                                elements: [this.factFinderFeedServiceDB, {\n                                    kind: \"column\", name: \"FACT Finder Feed Service\", shape: \"deployment-box\",\n                                    elements: [\n                                        {kind: \"row\", elements: [gap(), this.factFinderUpdater]},\n                                        {kind: \"row\", elements: [this.ffProductImporter, this.ffProductCampaignsImporter, this.ffCategoryImporter]}\n                                    ]\n                                }]\n                            }]\n                        };\n\n                        edges = [\n                            edge(this.factFinderAPI, this.factFinderDB),\n                            edge(this.factFinderUpdater, this.factFinderAPI),\n                            edge(this.factFinderUpdater, this.factFinderFeedServiceDB),\n                            edge(this.ffProductImporter, this.factFinderFeedServiceDB),\n                            edge(this.ffProductCampaignsImporter, this.factFinderFeedServiceDB),\n                            edge(this.ffCategoryImporter, this.factFinderFeedServiceDB)\n                        ];\n                    }();\n\n                    productService = new class {\n                        productServiceDB = db(\"Product Service DB\");\n                        productAPI = component(\"Product API\");\n                        stockAPI = component(\"Stock API\");\n                        productImporter = component(\"Product Importer\");\n                        productCampaignsImporter = component(\"Product Campaigns\\nImporter\");\n                        nightlyStockImporter = component(\"Nightly Stock Importer\");\n                        nearTimeStockImporter = component(\"Near Time Stock\\nImporter\");\n                        deliveryTimeImporter = component(\"Delivery Time Importer\");\n                        categoryImporter = component(\"Category Importer\");\n\n                        element: Element<unknown> = {\n                            kind: \"row\", elements: [{\n                                kind: \"column\", elements: [gap(), this.productServiceDB]\n                            }, {\n                                kind: \"column\", name: \"Product Service\", shape: \"deployment-box\", elements: [\n                                    {\n                                        kind: \"row\", elements: [\n                                            gap(), gap(), this.productAPI, this.stockAPI\n                                        ]\n                                    },\n                                    gap(),\n                                    {\n                                        kind: \"row\", elements: [\n                                            this.productImporter, this.productCampaignsImporter, this.nightlyStockImporter,\n                                            this.nearTimeStockImporter, this.deliveryTimeImporter, this.categoryImporter\n                                        ]\n                                    }\n                                ]\n                            }]\n                        };\n\n                        edges = [\n                            edge(this.productAPI, this.productServiceDB),\n                            edge(this.stockAPI, this.productServiceDB),\n                            edge(this.productImporter, this.productServiceDB),\n                            edge(this.productCampaignsImporter, this.productServiceDB),\n                            edge(this.nightlyStockImporter, this.productServiceDB),\n                            edge(this.nearTimeStockImporter, this.productServiceDB),\n                            edge(this.deliveryTimeImporter, this.productServiceDB),\n                            edge(this.categoryImporter, this.productServiceDB),\n                        ];\n                    }();\n\n                    element: Element<unknown> = {\n                        kind: \"row\", elements: [this.coreSiteMap.element, this.search.element, this.productService.element]\n                    };\n\n                    edges = this.search.edges.concat(this.productService.edges);\n                }();\n\n                exporter = new class {\n                    productExporterService = new class {\n                        productStream = queue(\"Product Stream\");\n                        productExporter = component(\"Product Exporter\");\n                        productCampaignsStream = queue(\"Product Campaigns\\nStream\");\n                        productCampaignsExporter = component(\"Product Campaigns\\nExporter\");\n                        nightlyStockStream = queue(\"Nightly Stock Stream\");\n                        nightlyStockExporter = component(\"Nightly Stock Exporter\");\n\n                        element: Element<unknown> = {\n                            kind: \"column\", elements: [{\n                                kind: \"row\", elements: [\n                                    this.productStream, this.productCampaignsStream, this.nightlyStockStream\n                                ]\n                            }, {\n                                kind: \"row\", name: \"Product Exporter Service\", shape: \"deployment-box\",\n                                elements: [\n                                    this.productExporter, this.productCampaignsExporter, this.nightlyStockExporter\n                                ]\n                            }]\n                        };\n\n                        edges = [\n                            edge(this.productExporter, this.productStream),\n                            edge(this.productCampaignsExporter, this.productCampaignsStream),\n                            edge(this.nightlyStockExporter, this.nightlyStockStream),\n                        ];\n                    }();\n\n                    stockExporterService = new class {\n                        stockStream = queue(\"Stock Stream\");\n                        stockExporter = component(\"Stock Exporter\");\n\n                        element: Element<unknown> = {\n                            kind: \"column\", elements: [\n                                this.stockStream,\n                                {kind: \"row\", name: \"Stock Exporter Service\", shape: \"deployment-box\", elements: [\n                                        this.stockExporter\n                                    ]}\n                            ]\n                        };\n\n                        edges = [\n                            edge(this.stockExporter, this.stockStream)\n                        ];\n                    }();\n\n                    deliveryTimeExporterService = new class {\n                        deliveryTimeStream = queue(\"Delivery Time Stream\");\n                        deliveryTimeExporter = component(\"Delivery Time Exporter\");\n\n                        element: Element<unknown> = {\n                            kind: \"column\", elements: [\n                                this.deliveryTimeStream,\n                                {\n                                    kind: \"row\",\n                                    name: \"Delivery Time\\nExporter Service\",\n                                    shape: \"deployment-box\",\n                                    elements: [this.deliveryTimeExporter]\n                                }\n                            ]\n                        };\n\n                        edges = [\n                            edge(this.deliveryTimeExporter, this.deliveryTimeStream)\n                        ];\n                    }();\n\n                    categoryExporterService = new class {\n                        categoryStream = queue(\"Category Stream\");\n                        categoryExporter = component(\"Category Exporter\");\n                        articleS3Bucket = s3Bucket(\"Article S3 Bucket\");\n\n                        element: Element<unknown> = {\n                            kind: \"column\", elements: [\n                                this.categoryStream,\n                                {\n                                    kind: \"row\", name: \"Category Exporter Service\", shape: \"deployment-box\", elements: [\n                                        this.categoryExporter\n                                    ]\n                                },\n                                this.articleS3Bucket\n                            ]\n                        };\n                        edges = [\n                            edge(this.categoryExporter, this.categoryStream),\n                            edge(this.categoryExporter, this.articleS3Bucket)\n                        ];\n                    }();\n\n                    element: Element<unknown> = {\n                        kind: \"row\", elements: [\n                            gap(), gap(), gap(), gap(), gap(), gap(),\n                            this.productExporterService.element, this.stockExporterService.element,\n                            this.deliveryTimeExporterService.element, this.categoryExporterService.element\n                        ]\n                    };\n\n                    edges = this.productExporterService.edges\n                        .concat(this.stockExporterService.edges)\n                        .concat(this.deliveryTimeExporterService.edges)\n                        .concat(this.categoryExporterService.edges);\n                }();\n\n                element: Element<unknown> = {\n                    kind: \"column\", elements: [\n                        this.pdpView.element,\n                        this.services.element,\n                        this.exporter.element\n                    ]\n                };\n\n                edges = this.services.edges.concat(this.exporter.edges).concat([\n                    edge(this.pdpView.pdpViewComponent, this.services.productService.productAPI),\n                    edge(this.pdpView.pdpViewComponent, this.services.productService.stockAPI),\n                    edge(this.pdpView.searchViewComponent, this.services.search.factFinderAPI),\n                    edge(this.services.coreSiteMap.siteMapGenerator, this.services.search.factFinderFeedServiceDB),\n                    edge(this.services.search.ffProductImporter, this.exporter.productExporterService.productStream),\n                    edge(this.services.search.ffProductCampaignsImporter, this.exporter.productExporterService.productCampaignsStream),\n                    edge(this.services.search.ffCategoryImporter, this.exporter.categoryExporterService.categoryStream),\n                    edge(this.services.productService.productImporter, this.exporter.productExporterService.productStream),\n                    edge(this.services.productService.productCampaignsImporter, this.exporter.productExporterService.productCampaignsStream),\n                    edge(this.services.productService.nightlyStockImporter, this.exporter.productExporterService.nightlyStockStream),\n                    edge(this.services.productService.nearTimeStockImporter, this.exporter.stockExporterService.stockStream),\n                    edge(this.services.productService.deliveryTimeImporter, this.exporter.deliveryTimeExporterService.deliveryTimeStream),\n                    edge(this.services.productService.categoryImporter, this.exporter.categoryExporterService.categoryStream)\n                ]);\n            }();\n\n            element: Element<unknown> = {\n                kind: \"row\", shape: \"rectangle\", name: \"Core VPC\", elements: [\n                    this.edutainment.element, this.core.element\n                ]\n            };\n\n            edges = this.core.edges.concat([\n                edge(this.edutainment.contentView.component, this.core.services.search.factFinderAPI),\n                edge(this.edutainment.contentView.component, this.core.services.productService.productAPI)\n            ]);\n        }();\n\n        backendSystems = new class {\n            contentful = new class {\n                content = node(\"Site Content\");\n                catalogContent = node(\"Catalog specific Content\");\n                productContent = node(\"Product specific Content\");\n\n                element: Element<unknown> = {\n                    kind: \"row\", name: \"Contentful\", shape: \"deployment-box\",\n                    elements: [\n                        this.content,\n                        this.catalogContent,\n                        this.productContent\n                    ]\n                };\n            }();\n\n            tds = new class {\n                shopNowDB = new class {\n                    mediaData = dbTable(\"Media Data\");\n\n                    element: Element<unknown> = {\n                        kind: \"row\", name: \"ShopNow DB\", shape: \"db-cylinder\",\n                        elements: [this.mediaData]\n                    };\n                }();\n\n                mediathek = new class {\n                    element = system(\"Mediathek\");\n                }();\n\n                mercator = new class {\n                    mercatorStagingDB = db(\"Mercator Staging DB\");\n                    mercatorDB = db(\"Mercator DB\");\n                    mercatorComponent = system(\"Mercator\");\n\n                    element: Element<unknown> = {\n                        kind: \"column\",\n                        elements: [{\n                            kind: \"row\",\n                            elements: [this.mercatorStagingDB, this.mercatorDB]\n                        }, {\n                            kind: \"row\",\n                            elements: [gap(), this.mercatorComponent]\n                        }]\n                    };\n\n                    edges = [\n                        edge(this.mercatorComponent, this.mercatorDB),\n                        edge(this.mercatorDB, this.mercatorStagingDB)\n                    ];\n                }();\n\n                sapERP = new class {\n                    articleReport = component(\"Article Report\");\n\n                    element: Element<unknown> = {\n                        kind: \"column\", name: \"SAP ERP / Retail\", shape: \"deployment-box\",\n                        elements: [this.articleReport]\n                    };\n                }();\n\n                sapCRM = new class {\n                    sellAPI = component(\"SELL API\");\n\n                    element: Element<unknown> = {\n                        kind: \"column\", name: \"SAP CRM\", shape: \"deployment-box\",\n                        elements: [this.sellAPI]\n                    };\n                }();\n\n                element: Element<unknown> = {\n                    kind: \"row\", shape: \"rectangle\", name: \"TDS\", elements: [\n                        {\n                            kind: \"column\", elements: [\n                                this.shopNowDB.element,\n                                this.mediathek.element\n                            ]\n                        },\n                        this.mercator.element, gap(), gap(),\n                        this.sapERP.element,\n                        this.sapCRM.element\n                    ]\n                };\n\n                edges = this.mercator.edges.concat([\n                    edge(this.mediathek.element, this.shopNowDB.mediaData)\n                ]);\n            }();\n\n            element: Element<unknown> = {\n                kind: \"row\", elements: [this.contentful.element, gap(), gap(), gap(), gap(), gap(), this.tds.element]\n            };\n        }();\n\n        element: Element<unknown> = {\n            kind: \"column\", elements: [\n                this.customerBrowser.element,\n                this.coreAccount.element,\n                this.backendSystems.element\n            ]\n        };\n\n        edges = this.coreAccount.edges.concat(this.backendSystems.tds.edges).concat([\n            edge(this.coreAccount.edutainment.contentView.component, this.customerBrowser.contentViewComponent),\n            edge(this.coreAccount.core.pdpView.searchViewComponent, this.customerBrowser.searchViewComponent),\n            edge(this.coreAccount.core.pdpView.pdpViewComponent, this.customerBrowser.pdpViewComponent),\n            edge(this.coreAccount.edutainment.contentView.component, this.backendSystems.contentful.content),\n            edge(this.coreAccount.core.pdpView.searchViewComponent, this.backendSystems.contentful.catalogContent),\n            edge(this.coreAccount.core.pdpView.pdpViewComponent, this.backendSystems.contentful.productContent),\n            edge(this.coreAccount.core.exporter.productExporterService.productExporter, this.backendSystems.tds.shopNowDB.mediaData),\n            edge(this.coreAccount.core.exporter.productExporterService.productExporter, this.backendSystems.tds.mercator.mercatorStagingDB),\n            edge(this.coreAccount.core.exporter.productExporterService.productCampaignsExporter, this.backendSystems.tds.mercator.mercatorStagingDB),\n            edge(this.coreAccount.core.exporter.productExporterService.nightlyStockExporter, this.backendSystems.tds.mercator.mercatorStagingDB),\n            edge(this.backendSystems.tds.sapERP.articleReport, this.coreAccount.core.exporter.categoryExporterService.articleS3Bucket),\n            edge(this.coreAccount.core.exporter.stockExporterService.stockExporter, this.backendSystems.tds.sapCRM.sellAPI),\n            edge(this.coreAccount.core.exporter.deliveryTimeExporterService.deliveryTimeExporter, this.backendSystems.tds.sapCRM.sellAPI)\n        ]);\n    }();\n\n    return graph(overall.element, overall.edges);\n}\n\nexport const NewArchitecture: React.FC = () => {\n    return (\n        <Diagram initialGraph={createInitialGraph()}/>\n    );\n};","import React from 'react';\nimport {HashRouter as Router, Link, Route, Switch} from \"react-router-dom\";\nimport {Editor} from \"./v1/Editor\";\nimport {Architecture} from \"./v1/Architecture\";\nimport {Sample} from \"./v2/Sample\";\nimport {NewArchitecture} from \"./v2/NewArchitecture\";\n\nconst App: React.FC = () => {\n    return (\n        <Router>\n            <div>\n                <ul>\n                    <li>\n                        <Link to=\"/\">Editor</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/architecture\">Sample Architecture</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/new-layouting\">New Layouting</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/new-architecture\">New Sample Architecture</Link>\n                    </li>\n                </ul>\n\n                <hr/>\n\n                <Switch>\n                    <Route exact path=\"/\">\n                        <Editor/>\n                    </Route>\n                    <Route path=\"/architecture\">\n                        <Architecture/>\n                    </Route>\n                    <Route path=\"/new-layouting\">\n                        <Sample/>\n                    </Route>\n                    <Route path=\"/new-architecture\">\n                        <NewArchitecture/>\n                    </Route>\n                </Switch>\n            </div>\n        </Router>\n    );\n};\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import {Edge, Stack} from \"./graphModel\";\n\nexport type IndexPair = {\n    from: number[]\n    to: number[]\n}\n\nfunction indexToReference<N, G>(stack: Stack<N, G>, index: number[]): any {\n    // It is necessary to go through the array by index,\n    // because the array operations `every`, `map` and `flat` bypass empty array elements.\n    for (let i = 0; i < index.length; i++) {\n        if (index[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n    }\n\n    let element: any = stack;\n    index.forEach(i => {\n        if (element.elements[i] === undefined)\n            throw new Error(\"Indices must refer to a node that does exist. Index \" + i  + \" Array length \" + element.elements.length);\n        element = element.elements[i];\n    });\n    return element;\n}\n\nfunction indexPairToReference<N, G>(stack: Stack<N, G>, indexPair: IndexPair): Edge<N> {\n    return {\n        from: indexToReference(stack, indexPair.from),\n        to: indexToReference(stack, indexPair.to)\n    };\n}\n\nexport function indicesToReferences<N, G>(stack: Stack<N, G>, indexPairs: IndexPair[]): Edge<N>[] {\n    return indexPairs.map(indexPair => indexPairToReference(stack, indexPair));\n}","import {Group, Layer, Node, Stack} from \"./graphModel\";\n\nfunction convertStringsToNodes(\n    element: string | Node | Group<string | Node, unknown> | Layer<Node, unknown> | Stack<Node, unknown>\n): Node | Group<Node, unknown> | Layer<Node, unknown> | Stack<Node, unknown> {\n    if (typeof element === 'string') {\n        return {\n            kind: 'node',\n            name: element\n        }\n    } else if (\"elements\" in element) {\n        // It is necessary to go through the array by index,\n        // because the array operations `every`, `map` and `flat` bypass empty array elements.\n        for (let i = 0; i < element.elements.length; i++) {\n            if (element.elements[i] === undefined) throw new Error(\"Empty array elements are not allowed.\");\n        }\n        if (\"name\" in element) {\n            return {\n                kind: \"group\",\n                name: element.name,\n                elements: element.elements.map(convertStringsToNodes) as (Group<Node, unknown> | Node)[]\n            }\n        }\n        switch (element.kind) {\n            default:\n            case \"stack\":  {\n                return {\n                    kind: element.kind,\n                    elements: element.elements.map(convertStringsToNodes) as Layer<Node, unknown>[]\n                }\n            }\n            case \"layer\": {\n                return {\n                    kind: element.kind,\n                    elements: element.elements.map(convertStringsToNodes) as (Node | Group<Node, unknown> | Stack<Node, unknown>)[]\n                }\n            }\n        }\n    } else {\n        return Object.assign(element, {\n            kind: 'node'\n        });\n    }\n}\n\nexport function stringsToNodes(\n    strings: (string | Node | Group<string | Node, unknown> | Stack<Node, unknown>)[][]\n): Stack<Node, unknown> {\n    return {\n        kind: 'stack',\n        elements: strings.map(layer => {\n            return {\n                kind: 'layer',\n                elements: layer.map(convertStringsToNodes) as (Node | Group<Node, unknown> | Stack<Node, unknown>)[]\n            }\n        })\n    };\n}","export const MARGIN_TOP = 5;\nexport const MARGIN_SIDE = 5;\nexport const ELEMENT_WIDTH = 150;\nexport const ELEMENT_HEIGHT = 40;\nexport const SYMBOL_WIDTH = 12;\nexport const SYMBOL_SPACING = 3;\nexport const GROUP_MARGIN_TOP = 30;\nexport const GROUP_MARGIN_BOTTOM = 10;\nexport const GROUP_MARGIN_SIDE = 10;\nexport const HORIZONTAL_SPACING = 10;\nexport const VERTICAL_SPACING = 20;\nexport const TEXT_PADDING = 5;\nexport const EDGE_SPACING = 10;\nexport const STROKE_WIDTH = 0.5;","import {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING} from \"./styling\";\nimport {Group, Layer, Node, Stack} from \"./graphModel\";\n\nexport function width(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return Math.max(...element.elements.map(width));\n        case \"layer\":\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"group\": {\n            return element.elements\n                .map(width)\n                .map((width, index) => width + (index > 0 ? HORIZONTAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0) + 2 * GROUP_MARGIN_SIDE;\n        }\n        case \"node\":\n            return ELEMENT_WIDTH * (element.size || 1);\n    }\n}","import {width} from \"./width\";\nimport {ELEMENT_WIDTH, GROUP_MARGIN_SIDE, HORIZONTAL_SPACING, MARGIN_SIDE} from \"./styling\";\nimport {Graph, Group, Layer, Node, Stack, X} from \"./graphModel\";\n\nexport function addXToNodeG<N extends Node, E, G>(\n    graph: Graph<N, E, G>\n): Graph<N & X, E, G & X> {\n    addXToNode(graph.stack, {x: MARGIN_SIDE});\n    return graph as unknown as Graph<N & X, E, G & X>;\n}\n\nexport function addXToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { x: number },\n    fullWidth: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let fullWidth = width(element);\n            element.elements.forEach(layer => {\n                addXToNode(layer, accumulator, fullWidth);\n            });\n            accumulator.x += fullWidth + HORIZONTAL_SPACING;\n            return;\n        }\n        case \"layer\": {\n            let oldX = accumulator.x;\n            accumulator.x = oldX + (fullWidth - width(element)) / 2;\n            element.elements.forEach(group => {\n                addXToNode(group, accumulator, fullWidth);\n            });\n            accumulator.x = oldX;\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n\n            accumulator.x += GROUP_MARGIN_SIDE;\n            element.elements.forEach(node => {\n                addXToNode(node, accumulator, fullWidth);\n            });\n            accumulator.x += GROUP_MARGIN_SIDE;\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                x: accumulator.x\n            });\n            accumulator.x += ELEMENT_WIDTH * (element.size || 1) + HORIZONTAL_SPACING;\n            return;\n        }\n    }\n}","export function ascending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o1) - property(o2);\n}\n\nexport function descending<T>(property: (obj: T) => number) {\n    return (o1: T, o2: T) => property(o2) - property(o1);\n}\n\nexport function and<T>(...sortFunctions: ((o1: T, o2: T) => number)[]) {\n    return (o1: T, o2: T) => {\n        let i = 0;\n        while (true) {\n            if (i === sortFunctions.length) return 0;\n            let result = sortFunctions[i](o1, o2);\n            if (result !== 0) return result;\n            i++;\n        }\n    }\n}","export type X = {\n    x: number\n}\nexport type Y = {\n    y: number\n}\nexport type Height = {\n    height: number\n}\nexport type LayerDimensions = {\n    belowLayerY: number\n}\nexport type LayerIndex = {\n    layerIndex: number\n}\nexport type Index = {\n    index: number\n}\nexport type Key = {\n    key: string\n}\nexport type LayerPosition = LayerIndex & Index & Key\ntype Symbols = \"component\"\nexport type Node = {\n    kind: 'node'\n    name: string\n    symbol?: Symbols\n    size?: number\n    isPlaceholder?: boolean\n}\nexport type Edge<T> = {\n    from: T\n    to: T\n}\nexport type EdgeIndex = {\n    edgeIndex: number\n}\nexport type ConnectionIndex = {\n    fromIndex: number\n    toIndex: number\n}\nexport type NumberOfEdges = {\n    upperSideEdges: number\n    lowerSideEdges: number\n}\nexport type Group<N, G> = {\n    kind: 'group'\n    name: string\n    elements: ((Group<N, G> & G) | N)[]\n}\nexport type Layer<N, G> = {\n    kind: 'layer'\n    elements: ((Group<N, G> & G) | Stack<N, G> | N)[]\n}\nexport type Stack<N, G> = {\n    kind: 'stack'\n    elements: Layer<N, G>[]\n}\nexport type Graph<N, E, G> = {\n    stack: Stack<N, G>\n    edges: (Edge<N> & E)[]\n}\n\nfunction fromIsUpperLeft<T extends LayerIndex & X>(edge: Edge<T>) {\n    if (edge.from.layerIndex === edge.to.layerIndex) {\n        return edge.from.x <= edge.to.x;\n    }\n    return edge.from.layerIndex < edge.to.layerIndex;\n}\n\nexport function getUpperLeftNode<T extends LayerIndex & X>(edge: Edge<T>): T {\n    return fromIsUpperLeft(edge) ? edge.from : edge.to;\n}\n\nexport function getLowerRightNode<T extends LayerIndex & X>(edge: Edge<T>): T {\n    return fromIsUpperLeft(edge) ? edge.to : edge.from;\n}","import {and, ascending, descending} from \"./sorting\";\nimport {Edge, EdgeIndex, getLowerRightNode, getUpperLeftNode, Graph, Key, LayerIndex, LayerPosition, X} from \"./graphModel\";\n\nexport function addLayerPositionToEdgeG<N extends LayerIndex & X & Key, E, G>(graph: Graph<N, E, G>):\n    Graph<N, E & LayerPosition, G> {\n    addLayerPositionToEdge(graph.edges);\n    return graph as unknown as Graph<N, E & LayerPosition, G>;\n}\n\nexport function addLayerPositionToEdge(edges: Edge<LayerIndex & X & Key>[]) {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerIndex & X & Key> & EdgeIndex)[]>();\n\n    edges\n        .map((edge, index) => Object.assign(edge, {edgeIndex: index}))\n        .forEach(edge => {\n            let key = getUpperLeftNode(edge).layerIndex;\n            let edges = groupedByLayerIndex.get(key) || [];\n            edges.push(edge);\n            groupedByLayerIndex.set(key, edges);\n        });\n\n    Array.from(groupedByLayerIndex.values()).forEach(addLayerPositionToEdgeForLayer);\n}\n\nfunction addLayerPositionToEdgeForLayer(edges: (Edge<LayerIndex & X & Key> & EdgeIndex)[]) {\n    let groupedByUpperNode = new Map<string, (Edge<LayerIndex & X & Key> & EdgeIndex)[]>();\n\n    edges.forEach(edge => {\n        let key = getUpperLeftNode(edge).key;\n        let edges = groupedByUpperNode.get(key) || [];\n        edges.push(edge);\n        groupedByUpperNode.set(key, edges);\n    });\n\n    let nodeKeys = Array.from(groupedByUpperNode.keys());\n    nodeKeys.sort();\n\n    let indexOffset = 0;\n    nodeKeys.forEach(nodeKey => {\n        let edges = groupedByUpperNode.get(nodeKey)!;\n\n        let sameLayer = edges.filter(edge => getLowerRightNode(edge).layerIndex === getUpperLeftNode(edge).layerIndex);\n        let sameLayerBefore = sameLayer.filter(edge => getLowerRightNode(edge).x <= getUpperLeftNode(edge).x);\n        let sameLayerAfter = sameLayer.filter(edge => getLowerRightNode(edge).x > getUpperLeftNode(edge).x);\n        let otherLayer = edges.filter(edge => getLowerRightNode(edge).layerIndex !== getUpperLeftNode(edge).layerIndex);\n        let otherLayerBefore = otherLayer.filter(edge => getLowerRightNode(edge).x <= getUpperLeftNode(edge).x);\n        let otherLayerAfter = otherLayer.filter(edge => getLowerRightNode(edge).x > getUpperLeftNode(edge).x);\n\n        sameLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n        otherLayerBefore.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n        otherLayerAfter.sort(and(descending(edge => getLowerRightNode(edge).x), descending(edge => edge.edgeIndex)));\n        sameLayerAfter.sort(and(ascending(edge => getLowerRightNode(edge).x), ascending(edge => edge.edgeIndex)));\n\n        let before = sameLayerBefore.concat(otherLayerBefore);\n        let after = sameLayerAfter.concat(otherLayerAfter);\n\n        function addLayerPosition(edge: Edge<LayerIndex & X>, indexInArray: number, beforeOrAfter: \"A\" | \"B\") {\n            let layerIndex = getUpperLeftNode(edge).layerIndex;\n            let index = indexOffset + indexInArray;\n            Object.assign(edge, {\n                key: nodeKey + \"_\" + beforeOrAfter + \"_\" + index,\n                index: index,\n                layerIndex: layerIndex\n            });\n        }\n\n        before.forEach((edge, index) => addLayerPosition(edge, index, \"B\"));\n        after.forEach((edge, index) => addLayerPosition(edge, index, \"A\"));\n\n        indexOffset += Math.max(before.length, after.length);\n    });\n}","import {EDGE_SPACING} from \"./styling\";\nimport {Edge, getUpperLeftNode, LayerIndex, LayerPosition, X} from \"./graphModel\";\n\nexport function heightOfEdges(edges: (Edge<LayerIndex & X> & LayerPosition)[], numberOfLayers: number): number[] {\n    let groupedByLayerIndex = new Map<number, (Edge<LayerIndex & X> & LayerPosition)[]>();\n    edges.forEach(edge => {\n        let layerIndex = getUpperLeftNode(edge).layerIndex;\n        let grouped = groupedByLayerIndex.get(layerIndex) || [];\n        grouped.push(edge);\n        groupedByLayerIndex.set(layerIndex, grouped);\n    });\n    let layerIndices = Array.from(Array(numberOfLayers).keys());\n    return layerIndices.map(layerIndex => {\n        let edgeIndices = groupedByLayerIndex.get(layerIndex)?.map(edge => edge.index) || [0];\n        return Math.max(...edgeIndices) * EDGE_SPACING;\n    })\n}","import {heightOfEdges} from \"./heightOfEdges\";\nimport {\n    ELEMENT_HEIGHT,\n    GROUP_MARGIN_BOTTOM,\n    GROUP_MARGIN_TOP,\n    MARGIN_TOP,\n    VERTICAL_SPACING\n} from \"./styling\";\nimport {Graph, Group, Height, Layer, LayerDimensions, LayerIndex, LayerPosition, Node, Stack, X, Y} from \"./graphModel\";\n\nexport function heightOfNodes(\n    element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>\n): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(heightOfNodes)\n                .map((height, index) => height + (index > 0 ? VERTICAL_SPACING : 0))\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodes));\n        case \"group\": {\n            return GROUP_MARGIN_TOP + Math.max(...element.elements.map(heightOfNodes)) + GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nexport function heightOfNodesOnlyFirstLayerOfNestedStacks(\n    element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>\n): number {\n    switch (element.kind) {\n        case \"stack\":\n            if (element.elements.length === 0) return 0;\n            return heightOfNodesOnlyFirstLayerOfNestedStacks(element.elements[0]);\n        case \"layer\":\n            return Math.max(...element.elements.map(heightOfNodesOnlyFirstLayerOfNestedStacks));\n        case \"group\": {\n            return GROUP_MARGIN_TOP +\n                Math.max(...element.elements.map(heightOfNodesOnlyFirstLayerOfNestedStacks)) +\n                GROUP_MARGIN_BOTTOM;\n        }\n        case \"node\":\n            if (element.isPlaceholder) return 0;\n            return ELEMENT_HEIGHT;\n    }\n}\n\nfunction groupNestingLevel(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\": {\n            if (element.elements.length === 0) return 0;\n            // Ignore the nesting of the elements below the first one\n            return groupNestingLevel(element.elements[0]);\n        }\n        case \"layer\":\n            return Math.max(...element.elements.map(groupNestingLevel));\n        case \"group\":\n            return Math.max(...element.elements.map(groupNestingLevel)) + 1;\n        case \"node\":\n            return 0;\n    }\n}\n\nexport function addYToNodeG<N extends (Node & LayerIndex & X), E extends LayerPosition, G extends LayerIndex>(\n    graph: Graph<N, E, G>\n): Graph<N & Y & LayerDimensions, E, G & Y & Height> {\n    let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n    addYToNode(graph.stack, {y: MARGIN_TOP, nodeY: 0, groupHeight: 0, belowLayerY: 0}, heightOfAllEdges);\n    return graph as unknown as Graph<N & Y & LayerDimensions, E, G & Y & Height>;\n}\n\nexport function addYToNode<N extends Node & LayerIndex, G extends LayerIndex>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { y: number, nodeY: number, groupHeight: number, belowLayerY: number },\n    heightOfEdges: number[]\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            let old = {\n                y: accumulator.y,\n                nodeY: accumulator.nodeY,\n                belowLayerY: accumulator.belowLayerY\n            };\n            element.elements.forEach((layer, layerIndex) => {\n                addYToNode(layer, accumulator, heightOfEdges);\n            });\n            accumulator.y = old.y;\n            accumulator.nodeY = old.nodeY;\n            accumulator.belowLayerY = old.belowLayerY;\n            return;\n        }\n        case \"layer\": {\n            accumulator.nodeY = accumulator.y + groupNestingLevel(element) * GROUP_MARGIN_TOP;\n            accumulator.groupHeight = groupNestingLevel(element) * (GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM) + ELEMENT_HEIGHT;\n            accumulator.belowLayerY = accumulator.y + heightOfNodesOnlyFirstLayerOfNestedStacks(element) + VERTICAL_SPACING;\n            element.elements.forEach(nestedElement => {\n                addYToNode(nestedElement, accumulator, heightOfEdges);\n            });\n            accumulator.y += heightOfNodes(element) + VERTICAL_SPACING;\n            return;\n        }\n        case \"group\": {\n            let additionalEdgeHeight = heightOfEdges.slice(0, element.layerIndex).reduce((sum, add) => sum + add, 0);\n            Object.assign(element, {\n                y: accumulator.y + additionalEdgeHeight,\n                height: accumulator.groupHeight\n            });\n\n            accumulator.y += GROUP_MARGIN_TOP;\n            accumulator.groupHeight -= GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            element.elements.forEach(node => {\n                addYToNode(node, accumulator, heightOfEdges);\n            });\n            accumulator.y -= GROUP_MARGIN_TOP;\n            accumulator.groupHeight += GROUP_MARGIN_TOP + GROUP_MARGIN_BOTTOM;\n            return;\n        }\n        case \"node\": {\n            let additionalEdgeHeight = heightOfEdges.slice(0, element.layerIndex).reduce((sum, add) => sum + add, 0);\n            Object.assign(element, {\n                y: accumulator.nodeY + additionalEdgeHeight,\n                belowLayerY: accumulator.belowLayerY + additionalEdgeHeight\n            });\n            return;\n        }\n    }\n}","import {ascending, descending} from \"./sorting\";\nimport {ConnectionIndex, Edge, Graph, Key, LayerIndex, NumberOfEdges, X} from \"./graphModel\";\n\nexport function addConnectionIndexAndNumberOfEdgesG<N extends LayerIndex & X & Key, E, G>(graph: Graph<N, E, G>):\n    Graph<N & NumberOfEdges, E & ConnectionIndex, G> {\n    addConnectionIndexAndNumberOfEdges(graph.edges);\n    return graph as unknown as Graph<N & NumberOfEdges, E & ConnectionIndex, G>;\n}\n\nexport function addConnectionIndexAndNumberOfEdges(edges: Edge<LayerIndex & X & Key>[]) {\n    type NodeSide = {\n        node: LayerIndex & X\n        side: \"LOWER\" | \"UPPER\"\n        edgeEnds: EdgeEnd[]\n    }\n\n    type EdgeEnd = {\n        reverseNode: LayerIndex & X\n        setIndex: (index: number) => void\n    }\n\n    let groupedByNodeAndSide = new Map<string, NodeSide>();\n\n    function addEdgeEnd(firstNode: LayerIndex & X & Key, secondNode: LayerIndex & X, setIndex: (index: number) => void) {\n        let side: \"LOWER\" | \"UPPER\" = firstNode.layerIndex <= secondNode.layerIndex ? \"LOWER\" : \"UPPER\";\n        let key = firstNode.key + side;\n        let nodeSide: NodeSide = groupedByNodeAndSide.get(key) || {\n            node: firstNode,\n            side: side,\n            edgeEnds: []\n        };\n        nodeSide.edgeEnds.push({\n            reverseNode: secondNode,\n            setIndex: setIndex\n        });\n        groupedByNodeAndSide.set(key, nodeSide);\n    }\n\n    edges.forEach(edge => {\n        addEdgeEnd(edge.from, edge.to, index => Object.assign(edge, {fromIndex: index}));\n        addEdgeEnd(edge.to, edge.from, index => Object.assign(edge, {toIndex: index}));\n    });\n\n    Array.from(groupedByNodeAndSide.values()).forEach(({edgeEnds, node, side}) => {\n        let sameLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex === node.layerIndex);\n        let before = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.x <= node.x);\n        let after = sameLayer.filter(edgeEnd => edgeEnd.reverseNode.x >= node.x);\n        let otherLayer = edgeEnds.filter(edgeEnd => edgeEnd.reverseNode.layerIndex !== node.layerIndex);\n\n        before.sort(descending(e => e.reverseNode.x));\n        otherLayer.sort(ascending(e => e.reverseNode.x));\n        after.sort(descending(e => e.reverseNode.x));\n\n        let all = before.concat(otherLayer).concat(after);\n        all.forEach((edgeEnd, index) => {\n            edgeEnd.setIndex(index);\n        });\n        if (side === \"UPPER\") {\n            Object.assign(node, {\n                upperSideEdges: edgeEnds.length\n            });\n        } else {\n            Object.assign(node, {\n                lowerSideEdges: edgeEnds.length\n            });\n        }\n    });\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allNodes<N extends Node, G, E>(element: Stack<N, G> | Group<N, G> | N): N[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allNodes);\n        case \"group\":\n            return element.elements.flatMap(allNodes);\n        case \"node\":\n            return [element];\n    }\n}","import {Group, Node, Stack} from \"./graphModel\";\n\nexport function allGroups<N extends Node, G, E>(element: Stack<N, G> | (Group<N, G> & G) | N): (Group<N, G> & G)[] {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements.flatMap(layer => layer.elements).flatMap(allGroups);\n        case \"group\":\n            return [element].concat(element.elements.flatMap(allGroups));\n        case \"node\":\n            return [];\n    }\n}","import React from \"react\";\nimport {STROKE_WIDTH} from \"./styling\";\n\nexport type Symbol = {\n    x: number\n    y: number\n    width: number\n    symbolKey: string\n}\nexport const ComponentSymbol: React.FC<Symbol> = symbol => {\n    const symbolHeightRelative = 1.1;\n    const barWidthRelative = 0.4;\n    const barHeightRelative = 0.15;\n    const barWidthAbsolute = symbol.width * barWidthRelative;\n    const barHeightAbsolute = symbol.width * barHeightRelative;\n    return (\n        <g key={symbol.symbolKey}>\n            <rect\n                x={symbol.x + barWidthAbsolute / 2} y={symbol.y}\n                width={symbol.width * (1 - barWidthRelative / 2)} height={symbol.width * symbolHeightRelative}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n            <rect\n                x={symbol.x} y={symbol.y + barHeightAbsolute * 3}\n                width={barWidthAbsolute} height={barHeightAbsolute}\n                fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, STROKE_WIDTH, SYMBOL_SPACING, SYMBOL_WIDTH, TEXT_PADDING} from \"./styling\";\nimport {Key, Node, X, Y} from \"./graphModel\";\nimport {ComponentSymbol} from \"./Symbols\";\n\nexport const NodeShape: React.FC<Node & X & Y & Key> = node => {\n    if (node.isPlaceholder) return null;\n\n    let isComponent = node.symbol === \"component\";\n    return (\n        <g key={node.key}>\n            <rect data-testid=\"rect\"\n                  x={node.x} y={node.y}\n                  width={width(node)} height={ELEMENT_HEIGHT}\n                  fill=\"lightgrey\" strokeWidth={STROKE_WIDTH} stroke=\"black\"/>\n\n            <text x={node.x + TEXT_PADDING} y={node.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + node.key + \")\"}>{node.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + node.key}>\n                <rect\n                    x={node.x + TEXT_PADDING} y={node.y}\n                    width={width(node) - 2 * TEXT_PADDING - (isComponent ? (SYMBOL_WIDTH + SYMBOL_SPACING) : 0)}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n\n            {isComponent ?\n                <ComponentSymbol\n                    symbolKey={node.key + \"CS\"}\n                    x={node.x + width(node) - SYMBOL_WIDTH - SYMBOL_SPACING}\n                    y={node.y + SYMBOL_SPACING}\n                    width={SYMBOL_WIDTH}/>\n                : \"\"}\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {ELEMENT_HEIGHT, GROUP_MARGIN_SIDE, STROKE_WIDTH} from \"./styling\";\nimport {Group, Height, Key, Node, X, Y} from \"./graphModel\";\n\nexport const GroupShape: React.FC<Group<Node, unknown> & X & Y & Key & Height> = group => {\n    return (\n        <g key={group.key}>\n            <rect\n                x={group.x} y={group.y}\n                width={width(group)}\n                height={group.height}\n                fill=\"none\" strokeWidth={STROKE_WIDTH} stroke=\"grey\"/>\n\n            <text x={group.x + GROUP_MARGIN_SIDE} y={group.y + ELEMENT_HEIGHT / 2} fill=\"black\"\n                  clipPath={\"url(#clip-element-text-\" + group.key + \")\"}>{group.name}\n            </text>\n\n            <clipPath id={\"clip-element-text-\" + group.key}>\n                <rect\n                    x={group.x + GROUP_MARGIN_SIDE} y={group.y}\n                    width={width(group) - 2 * GROUP_MARGIN_SIDE}\n                    height={ELEMENT_HEIGHT}/>\n            </clipPath>\n        </g>\n    );\n};","import React from \"react\";\nimport {width} from \"./width\";\nimport {EDGE_SPACING, STROKE_WIDTH, VERTICAL_SPACING} from \"./styling\";\nimport {\n    ConnectionIndex,\n    Edge,\n    getUpperLeftNode,\n    LayerDimensions, LayerIndex,\n    LayerPosition,\n    Node,\n    NumberOfEdges, X,\n    Y\n} from \"./graphModel\";\nimport {heightOfNodes} from \"./addYToNode\";\n\nfunction edgeEndCoordinates<N extends Node & LayerIndex & X & Y & NumberOfEdges>(\n    node: N, edgeIndex: number, otherNode: N\n) {\n    let onLowerSide = node.layerIndex <= otherNode.layerIndex;\n    let nodeCenteringOffset = (width(node) - ((onLowerSide ? node.lowerSideEdges : node.upperSideEdges) - 1) * EDGE_SPACING) / 2;\n    return {\n        x: node.x + nodeCenteringOffset + edgeIndex * EDGE_SPACING,\n        y: node.y + (onLowerSide ? heightOfNodes(node) : 0)\n    };\n}\n\nexport const EdgeShape: React.FC<Edge<Node & LayerIndex & X & Y & LayerDimensions & NumberOfEdges> & LayerPosition & ConnectionIndex> = edge => {\n    let fromNode = edgeEndCoordinates(edge.from, edge.fromIndex, edge.to);\n    let upperNodeEdgesY = getUpperLeftNode(edge).belowLayerY - VERTICAL_SPACING / 2 + edge.index * EDGE_SPACING;\n    let toNode = edgeEndCoordinates(edge.to, edge.toIndex, edge.from);\n    return (\n        <path key={edge.key} d={\n            \"M \" + fromNode.x + \" \" + fromNode.y + \" \" +\n            \"L \" + fromNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + upperNodeEdgesY + \" \" +\n            \"L \" + toNode.x + \" \" + toNode.y\n        }\n              stroke=\"black\"\n              strokeWidth={STROKE_WIDTH}\n              fill=\"none\"\n        />\n    );\n};","import {Graph, Group, Layer, LayerIndex, Node, Stack} from \"./graphModel\";\n\nfunction numberOfLayers(element: Node | Stack<Node, unknown> | Layer<Node, unknown> | Group<Node, unknown>): number {\n    switch (element.kind) {\n        case \"stack\":\n            return element.elements\n                .map(numberOfLayers)\n                .reduce((sum, add) => sum + add, 0);\n        case \"layer\":\n            return Math.max(...element.elements.map(numberOfLayers));\n        case \"group\": {\n            return Math.max(...element.elements.map(numberOfLayers));\n        }\n        case \"node\":\n            return 1;\n    }\n}\n\nexport function addLayerIndexToNodeG<N extends Node, E, G>(graph: Graph<N, E, G>):\n    Graph<N & LayerIndex, E, G & LayerIndex> {\n    addLayerIndexToNode(graph.stack);\n    return graph as unknown as Graph<N & LayerIndex, E, G & LayerIndex>;\n}\n\nexport function addLayerIndexToNode<N extends Node, G>(\n    element: N | Group<N, G> | Layer<N, G> | Stack<N, G>,\n    layerIndex: number = 0\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach(nestedElement => {\n                addLayerIndexToNode(nestedElement, layerIndex);\n                layerIndex += numberOfLayers(nestedElement);\n            });\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => {\n                addLayerIndexToNode(group, layerIndex);\n            });\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n\n            element.elements.forEach(node => {\n                addLayerIndexToNode(node, layerIndex);\n            });\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                layerIndex: layerIndex\n            });\n            return;\n        }\n    }\n}","import {Graph, Layer, LayerIndex, Node} from \"./graphModel\";\n\nexport function insertPlaceholdersInMultilayerEdges(graph: Graph<Node & LayerIndex, unknown, LayerIndex>): Graph<Node & LayerIndex, unknown, LayerIndex> {\n    return {\n        stack: graph.stack,\n        edges: graph.edges\n            .flatMap(edge => {\n                if (Math.abs(edge.from.layerIndex - edge.to.layerIndex) <= 1) return edge;\n\n                let from = Math.min(edge.from.layerIndex, edge.to.layerIndex);\n                let to = Math.max(edge.from.layerIndex, edge.to.layerIndex);\n                let newEdges = [];\n                let last = edge.from.layerIndex < edge.to.layerIndex ? edge.from : edge.to;\n                let end = edge.from.layerIndex >= edge.to.layerIndex ? edge.from : edge.to;\n                for (let i = from + 1; i < to; i++) {\n                    let placeholder: Node & LayerIndex = {\n                        kind: \"node\",\n                        name: \"\",\n                        size: 0.01,\n                        isPlaceholder: true,\n                        layerIndex: i\n                    };\n                    let layer: Layer<Node & LayerIndex, LayerIndex> = graph.stack.elements[i];\n                    layer.elements.splice(0, 0, placeholder);\n                    newEdges.push({from: last, to: placeholder});\n                    last = placeholder;\n                }\n                newEdges.push({from: last, to: end});\n                return newEdges;\n            })\n    };\n}","import {Graph, Group, Key, Layer, Node, Stack} from \"./graphModel\";\n\nexport function addKeyToNodeG<N extends Node, E, G>(\n    graph: Graph<N, E, G>\n): Graph<N & Key, E, G & Key> {\n    addKeyToNode(graph.stack);\n    return graph as unknown as Graph<N & Key, E, G & Key>;\n}\n\nexport function addKeyToNode<N extends Node, G>(\n    element: N | (Group<N, G> & G) | Layer<N, G> | Stack<N, G>,\n    accumulator: { globalCounter: number } = {globalCounter: 0}\n) {\n    switch (element.kind) {\n        case \"stack\": {\n            element.elements.forEach(groups => addKeyToNode(groups, accumulator));\n            return;\n        }\n        case \"layer\": {\n            element.elements.forEach(group => addKeyToNode(group, accumulator));\n            return;\n        }\n        case \"group\": {\n            Object.assign(element, {\n                key: \"\" + accumulator.globalCounter\n            });\n            accumulator.globalCounter++;\n\n            element.elements.forEach(node => addKeyToNode(node, accumulator));\n            return;\n        }\n        case \"node\": {\n            Object.assign(element, {\n                key: \"\" + accumulator.globalCounter\n            });\n            accumulator.globalCounter++;\n            return;\n        }\n    }\n}","import React from \"react\";\nimport {addXToNodeG} from \"./addXToNode\";\nimport {addLayerPositionToEdgeG} from \"./addLayerPositionToEdge\";\nimport {addYToNodeG, heightOfNodes} from \"./addYToNode\";\nimport {addConnectionIndexAndNumberOfEdgesG} from \"./addConnectionIndexAndNumberOfEdges\";\nimport {allNodes} from \"./allNodes\";\nimport {allGroups} from \"./allGroups\";\nimport {heightOfEdges} from \"./heightOfEdges\";\nimport {NodeShape} from \"./NodeShape\";\nimport {GroupShape} from \"./GroupShape\";\nimport {EdgeShape} from \"./EdgeShape\";\nimport {width} from \"./width\";\nimport {MARGIN_SIDE, MARGIN_TOP, VERTICAL_SPACING} from \"./styling\";\nimport {Graph, Node} from \"./graphModel\";\nimport {addLayerIndexToNodeG} from \"./addLayerIndexToNode\";\nimport {insertPlaceholdersInMultilayerEdges} from \"./insertPlaceholdersInMultilayerEdges\";\nimport {addKeyToNodeG} from \"./addKeyToNode\";\n\nexport const Diagram: React.FC<Graph<Node, unknown, unknown>> = graph => {\n    return [graph]\n        .map(addLayerIndexToNodeG)\n        .map(insertPlaceholdersInMultilayerEdges)\n        .map(addKeyToNodeG)\n        .map(addXToNodeG)\n        .map(addLayerPositionToEdgeG)\n        .map(addYToNodeG)\n        .map(addConnectionIndexAndNumberOfEdgesG)\n        .map(graph => {\n            let heightOfAllEdges = heightOfEdges(graph.edges, graph.stack.elements.length);\n            let overallWidth = width(graph.stack) + 2 * MARGIN_SIDE;\n            let height = heightOfNodes(graph.stack) + VERTICAL_SPACING +\n                heightOfAllEdges.reduce((sum, add) => sum + add) +\n                2 * MARGIN_TOP;\n\n            return (\n                <svg viewBox={\"0 0 \" + overallWidth + \" \" + height}>\n                    {allNodes(graph.stack).map(NodeShape)}\n                    {allGroups(graph.stack).map(GroupShape)}\n                    {graph.edges.map(EdgeShape)}\n                </svg>\n            );\n        })[0];\n};"],"sourceRoot":""}